"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@vercel";
exports.ids = ["vendor-chunks/@vercel"];
exports.modules = {

/***/ "(ssr)/./node_modules/@vercel/blob/dist/chunk-FN6XFH6R.js":
/*!**********************************************************!*\
  !*** ./node_modules/@vercel/blob/dist/chunk-FN6XFH6R.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BlobAccessError: () => (/* binding */ BlobAccessError),\n/* harmony export */   BlobClientTokenExpiredError: () => (/* binding */ BlobClientTokenExpiredError),\n/* harmony export */   BlobContentTypeNotAllowedError: () => (/* binding */ BlobContentTypeNotAllowedError),\n/* harmony export */   BlobError: () => (/* binding */ BlobError),\n/* harmony export */   BlobFileTooLargeError: () => (/* binding */ BlobFileTooLargeError),\n/* harmony export */   BlobNotFoundError: () => (/* binding */ BlobNotFoundError),\n/* harmony export */   BlobPathnameMismatchError: () => (/* binding */ BlobPathnameMismatchError),\n/* harmony export */   BlobRequestAbortedError: () => (/* binding */ BlobRequestAbortedError),\n/* harmony export */   BlobServiceNotAvailable: () => (/* binding */ BlobServiceNotAvailable),\n/* harmony export */   BlobServiceRateLimited: () => (/* binding */ BlobServiceRateLimited),\n/* harmony export */   BlobStoreNotFoundError: () => (/* binding */ BlobStoreNotFoundError),\n/* harmony export */   BlobStoreSuspendedError: () => (/* binding */ BlobStoreSuspendedError),\n/* harmony export */   BlobUnknownError: () => (/* binding */ BlobUnknownError),\n/* harmony export */   MAXIMUM_PATHNAME_LENGTH: () => (/* binding */ MAXIMUM_PATHNAME_LENGTH),\n/* harmony export */   createCompleteMultipartUploadMethod: () => (/* binding */ createCompleteMultipartUploadMethod),\n/* harmony export */   createCreateMultipartUploadMethod: () => (/* binding */ createCreateMultipartUploadMethod),\n/* harmony export */   createCreateMultipartUploaderMethod: () => (/* binding */ createCreateMultipartUploaderMethod),\n/* harmony export */   createFolder: () => (/* binding */ createFolder),\n/* harmony export */   createPutMethod: () => (/* binding */ createPutMethod),\n/* harmony export */   createUploadPartMethod: () => (/* binding */ createUploadPartMethod),\n/* harmony export */   disallowedPathnameCharacters: () => (/* binding */ disallowedPathnameCharacters),\n/* harmony export */   getDownloadUrl: () => (/* binding */ getDownloadUrl),\n/* harmony export */   getTokenFromOptionsOrEnv: () => (/* binding */ getTokenFromOptionsOrEnv),\n/* harmony export */   requestApi: () => (/* binding */ requestApi)\n/* harmony export */ });\n/* harmony import */ var is_node_process__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! is-node-process */ \"(ssr)/./node_modules/is-node-process/lib/index.mjs\");\n/* harmony import */ var is_buffer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! is-buffer */ \"(ssr)/./node_modules/is-buffer/index.js\");\n/* harmony import */ var stream__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! stream */ \"stream\");\n/* harmony import */ var async_retry__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! async-retry */ \"(ssr)/./node_modules/async-retry/lib/index.js\");\n/* harmony import */ var undici__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! undici */ \"(ssr)/./node_modules/undici/index.js\");\n/* harmony import */ var throttleit__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! throttleit */ \"(ssr)/./node_modules/throttleit/index.js\");\n// src/helpers.ts\n\n\n// src/multipart/helpers.ts\n\n\nvar supportsNewBlobFromArrayBuffer = new Promise((resolve) => {\n  try {\n    const helloAsArrayBuffer = new Uint8Array([104, 101, 108, 108, 111]);\n    const blob = new Blob([helloAsArrayBuffer]);\n    blob.text().then((text) => {\n      resolve(text === \"hello\");\n    }).catch(() => {\n      resolve(false);\n    });\n  } catch {\n    resolve(false);\n  }\n});\nasync function toReadableStream(value) {\n  if (value instanceof ReadableStream) {\n    return value;\n  }\n  if (value instanceof Blob) {\n    return value.stream();\n  }\n  if (isNodeJsReadableStream(value)) {\n    return stream__WEBPACK_IMPORTED_MODULE_2__.Readable.toWeb(value);\n  }\n  let streamValue;\n  if (value instanceof ArrayBuffer) {\n    streamValue = new Uint8Array(value);\n  } else if (isNodeJsBuffer(value)) {\n    streamValue = value;\n  } else {\n    streamValue = stringToUint8Array(value);\n  }\n  if (await supportsNewBlobFromArrayBuffer) {\n    return new Blob([streamValue]).stream();\n  }\n  return new ReadableStream({\n    start(controller) {\n      controller.enqueue(streamValue);\n      controller.close();\n    }\n  });\n}\nfunction isNodeJsReadableStream(value) {\n  return typeof value === \"object\" && typeof value.pipe === \"function\" && value.readable && typeof value._read === \"function\" && // @ts-expect-error _readableState does exists on Readable\n  typeof value._readableState === \"object\";\n}\nfunction stringToUint8Array(s) {\n  const enc = new TextEncoder();\n  return enc.encode(s);\n}\nfunction isNodeJsBuffer(value) {\n  return is_buffer__WEBPACK_IMPORTED_MODULE_1__(value);\n}\n\n// src/bytes.ts\nvar parseRegExp = /^((-|\\+)?(\\d+(?:\\.\\d+)?)) *(kb|mb|gb|tb|pb)$/i;\nvar map = {\n  b: 1,\n  kb: 1 << 10,\n  mb: 1 << 20,\n  gb: 1 << 30,\n  tb: 1024 ** 4,\n  pb: 1024 ** 5\n};\nfunction bytes(val) {\n  if (typeof val === \"number\" && !Number.isNaN(val)) {\n    return val;\n  }\n  if (typeof val !== \"string\") {\n    return null;\n  }\n  const results = parseRegExp.exec(val);\n  let floatValue;\n  let unit = \"b\";\n  if (!results) {\n    floatValue = parseInt(val, 10);\n  } else {\n    const [, res, , , unitMatch] = results;\n    if (!res) {\n      return null;\n    }\n    floatValue = parseFloat(res);\n    if (unitMatch) {\n      unit = unitMatch.toLowerCase();\n    }\n  }\n  if (Number.isNaN(floatValue)) {\n    return null;\n  }\n  return Math.floor(map[unit] * floatValue);\n}\n\n// src/helpers.ts\nvar defaultVercelBlobApiUrl = \"https://vercel.com/api/blob\";\nfunction getTokenFromOptionsOrEnv(options) {\n  if (options == null ? void 0 : options.token) {\n    return options.token;\n  }\n  if (process.env.BLOB_READ_WRITE_TOKEN) {\n    return process.env.BLOB_READ_WRITE_TOKEN;\n  }\n  throw new BlobError(\n    \"No token found. Either configure the `BLOB_READ_WRITE_TOKEN` environment variable, or pass a `token` option to your calls.\"\n  );\n}\nvar BlobError = class extends Error {\n  constructor(message) {\n    super(`Vercel Blob: ${message}`);\n  }\n};\nfunction getDownloadUrl(blobUrl) {\n  const url = new URL(blobUrl);\n  url.searchParams.set(\"download\", \"1\");\n  return url.toString();\n}\nfunction isPlainObject(value) {\n  if (typeof value !== \"object\" || value === null) {\n    return false;\n  }\n  const prototype = Object.getPrototypeOf(value);\n  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);\n}\nvar disallowedPathnameCharacters = [\"//\"];\nvar supportsRequestStreams = (() => {\n  if ((0,is_node_process__WEBPACK_IMPORTED_MODULE_0__.isNodeProcess)()) {\n    return true;\n  }\n  const apiUrl = getApiUrl();\n  if (apiUrl.startsWith(\"http://localhost\")) {\n    return false;\n  }\n  let duplexAccessed = false;\n  const hasContentType = new Request(getApiUrl(), {\n    body: new ReadableStream(),\n    method: \"POST\",\n    // @ts-expect-error -- TypeScript doesn't yet have duplex but it's in the spec: https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1729\n    get duplex() {\n      duplexAccessed = true;\n      return \"half\";\n    }\n  }).headers.has(\"Content-Type\");\n  return duplexAccessed && !hasContentType;\n})();\nfunction getApiUrl(pathname = \"\") {\n  let baseUrl = null;\n  try {\n    baseUrl = process.env.VERCEL_BLOB_API_URL || process.env.NEXT_PUBLIC_VERCEL_BLOB_API_URL;\n  } catch {\n  }\n  return `${baseUrl || defaultVercelBlobApiUrl}${pathname}`;\n}\nvar TEXT_ENCODER = typeof TextEncoder === \"function\" ? new TextEncoder() : null;\nfunction computeBodyLength(body) {\n  if (!body) {\n    return 0;\n  }\n  if (typeof body === \"string\") {\n    if (TEXT_ENCODER) {\n      return TEXT_ENCODER.encode(body).byteLength;\n    }\n    return new Blob([body]).size;\n  }\n  if (\"byteLength\" in body && typeof body.byteLength === \"number\") {\n    return body.byteLength;\n  }\n  if (\"size\" in body && typeof body.size === \"number\") {\n    return body.size;\n  }\n  return 0;\n}\nvar createChunkTransformStream = (chunkSize, onProgress) => {\n  let buffer = new Uint8Array(0);\n  return new TransformStream({\n    transform(chunk, controller) {\n      queueMicrotask(() => {\n        const newBuffer = new Uint8Array(buffer.length + chunk.byteLength);\n        newBuffer.set(buffer);\n        newBuffer.set(new Uint8Array(chunk), buffer.length);\n        buffer = newBuffer;\n        while (buffer.length >= chunkSize) {\n          const newChunk = buffer.slice(0, chunkSize);\n          controller.enqueue(newChunk);\n          onProgress == null ? void 0 : onProgress(newChunk.byteLength);\n          buffer = buffer.slice(chunkSize);\n        }\n      });\n    },\n    flush(controller) {\n      queueMicrotask(() => {\n        if (buffer.length > 0) {\n          controller.enqueue(buffer);\n          onProgress == null ? void 0 : onProgress(buffer.byteLength);\n        }\n      });\n    }\n  });\n};\nfunction isReadableStream(value) {\n  return globalThis.ReadableStream && // TODO: Can be removed once Node.js 16 is no more required internally\n  value instanceof ReadableStream;\n}\nfunction isStream(value) {\n  if (isReadableStream(value)) {\n    return true;\n  }\n  if (isNodeJsReadableStream(value)) {\n    return true;\n  }\n  return false;\n}\n\n// src/api.ts\n\n\n// src/debug.ts\nvar debugIsActive = false;\nvar _a, _b;\ntry {\n  if (((_a = process.env.DEBUG) == null ? void 0 : _a.includes(\"blob\")) || ((_b = process.env.NEXT_PUBLIC_DEBUG) == null ? void 0 : _b.includes(\"blob\"))) {\n    debugIsActive = true;\n  }\n} catch {\n}\nfunction debug(message, ...args) {\n  if (debugIsActive) {\n    console.debug(`vercel-blob: ${message}`, ...args);\n  }\n}\n\n// src/dom-exception.ts\nvar _a2;\nvar DOMException2 = (_a2 = globalThis.DOMException) != null ? _a2 : (() => {\n  try {\n    atob(\"~\");\n  } catch (err) {\n    return Object.getPrototypeOf(err).constructor;\n  }\n})();\n\n// src/is-network-error.ts\nvar objectToString = Object.prototype.toString;\nvar isError = (value) => objectToString.call(value) === \"[object Error]\";\nvar errorMessages = /* @__PURE__ */ new Set([\n  \"network error\",\n  // Chrome\n  \"Failed to fetch\",\n  // Chrome\n  \"NetworkError when attempting to fetch resource.\",\n  // Firefox\n  \"The Internet connection appears to be offline.\",\n  // Safari 16\n  \"Load failed\",\n  // Safari 17+\n  \"Network request failed\",\n  // `cross-fetch`\n  \"fetch failed\",\n  // Undici (Node.js)\n  \"terminated\"\n  // Undici (Node.js)\n]);\nfunction isNetworkError(error) {\n  const isValid = error && isError(error) && error.name === \"TypeError\" && typeof error.message === \"string\";\n  if (!isValid) {\n    return false;\n  }\n  if (error.message === \"Load failed\") {\n    return error.stack === void 0;\n  }\n  return errorMessages.has(error.message);\n}\n\n// src/fetch.ts\n\nvar hasFetch = typeof undici__WEBPACK_IMPORTED_MODULE_4__.fetch === \"function\";\nvar hasFetchWithUploadProgress = hasFetch && supportsRequestStreams;\nvar CHUNK_SIZE = 64 * 1024;\nvar blobFetch = async ({\n  input,\n  init,\n  onUploadProgress\n}) => {\n  debug(\"using fetch\");\n  let body;\n  if (init.body) {\n    if (onUploadProgress) {\n      const stream = await toReadableStream(init.body);\n      let loaded = 0;\n      const chunkTransformStream = createChunkTransformStream(\n        CHUNK_SIZE,\n        (newLoaded) => {\n          loaded += newLoaded;\n          onUploadProgress(loaded);\n        }\n      );\n      body = stream.pipeThrough(chunkTransformStream);\n    } else {\n      body = init.body;\n    }\n  }\n  const duplex = supportsRequestStreams && body && isStream(body) ? \"half\" : void 0;\n  return (0,undici__WEBPACK_IMPORTED_MODULE_4__.fetch)(\n    input,\n    // @ts-expect-error -- Blob and Nodejs Blob are triggering type errors, fine with it\n    {\n      ...init,\n      ...init.body ? { body } : {},\n      duplex\n    }\n  );\n};\n\n// src/xhr.ts\nvar hasXhr = typeof XMLHttpRequest !== \"undefined\";\nvar blobXhr = async ({\n  input,\n  init,\n  onUploadProgress\n}) => {\n  debug(\"using xhr\");\n  let body = null;\n  if (init.body) {\n    if (isReadableStream(init.body)) {\n      body = await new Response(init.body).blob();\n    } else {\n      body = init.body;\n    }\n  }\n  return new Promise((resolve, reject) => {\n    const xhr = new XMLHttpRequest();\n    xhr.open(init.method || \"GET\", input.toString(), true);\n    if (onUploadProgress) {\n      xhr.upload.addEventListener(\"progress\", (event) => {\n        if (event.lengthComputable) {\n          onUploadProgress(event.loaded);\n        }\n      });\n    }\n    xhr.onload = () => {\n      var _a3;\n      if ((_a3 = init.signal) == null ? void 0 : _a3.aborted) {\n        reject(new DOMException(\"The user aborted the request.\", \"AbortError\"));\n        return;\n      }\n      const headers = new Headers();\n      const rawHeaders = xhr.getAllResponseHeaders().trim().split(/[\\r\\n]+/);\n      rawHeaders.forEach((line) => {\n        const parts = line.split(\": \");\n        const key = parts.shift();\n        const value = parts.join(\": \");\n        if (key) headers.set(key.toLowerCase(), value);\n      });\n      const response = new Response(xhr.response, {\n        status: xhr.status,\n        statusText: xhr.statusText,\n        headers\n      });\n      resolve(response);\n    };\n    xhr.onerror = () => {\n      reject(new TypeError(\"Network request failed\"));\n    };\n    xhr.ontimeout = () => {\n      reject(new TypeError(\"Network request timed out\"));\n    };\n    xhr.onabort = () => {\n      reject(new DOMException(\"The user aborted a request.\", \"AbortError\"));\n    };\n    if (init.headers) {\n      const headers = new Headers(init.headers);\n      headers.forEach((value, key) => {\n        xhr.setRequestHeader(key, value);\n      });\n    }\n    if (init.signal) {\n      init.signal.addEventListener(\"abort\", () => {\n        xhr.abort();\n      });\n      if (init.signal.aborted) {\n        xhr.abort();\n        return;\n      }\n    }\n    xhr.send(body);\n  });\n};\n\n// src/request.ts\nvar blobRequest = async ({\n  input,\n  init,\n  onUploadProgress\n}) => {\n  if (onUploadProgress) {\n    if (hasFetchWithUploadProgress) {\n      return blobFetch({ input, init, onUploadProgress });\n    }\n    if (hasXhr) {\n      return blobXhr({ input, init, onUploadProgress });\n    }\n  }\n  if (hasFetch) {\n    return blobFetch({ input, init });\n  }\n  if (hasXhr) {\n    return blobXhr({ input, init });\n  }\n  throw new Error(\"No request implementation available\");\n};\n\n// src/api.ts\nvar MAXIMUM_PATHNAME_LENGTH = 950;\nvar BlobAccessError = class extends BlobError {\n  constructor() {\n    super(\"Access denied, please provide a valid token for this resource.\");\n  }\n};\nvar BlobContentTypeNotAllowedError = class extends BlobError {\n  constructor(message) {\n    super(`Content type mismatch, ${message}.`);\n  }\n};\nvar BlobPathnameMismatchError = class extends BlobError {\n  constructor(message) {\n    super(\n      `Pathname mismatch, ${message}. Check the pathname used in upload() or put() matches the one from the client token.`\n    );\n  }\n};\nvar BlobClientTokenExpiredError = class extends BlobError {\n  constructor() {\n    super(\"Client token has expired.\");\n  }\n};\nvar BlobFileTooLargeError = class extends BlobError {\n  constructor(message) {\n    super(`File is too large, ${message}.`);\n  }\n};\nvar BlobStoreNotFoundError = class extends BlobError {\n  constructor() {\n    super(\"This store does not exist.\");\n  }\n};\nvar BlobStoreSuspendedError = class extends BlobError {\n  constructor() {\n    super(\"This store has been suspended.\");\n  }\n};\nvar BlobUnknownError = class extends BlobError {\n  constructor() {\n    super(\"Unknown error, please visit https://vercel.com/help.\");\n  }\n};\nvar BlobNotFoundError = class extends BlobError {\n  constructor() {\n    super(\"The requested blob does not exist\");\n  }\n};\nvar BlobServiceNotAvailable = class extends BlobError {\n  constructor() {\n    super(\"The blob service is currently not available. Please try again.\");\n  }\n};\nvar BlobServiceRateLimited = class extends BlobError {\n  constructor(seconds) {\n    super(\n      `Too many requests please lower the number of concurrent requests ${seconds ? ` - try again in ${seconds} seconds` : \"\"}.`\n    );\n    this.retryAfter = seconds != null ? seconds : 0;\n  }\n};\nvar BlobRequestAbortedError = class extends BlobError {\n  constructor() {\n    super(\"The request was aborted.\");\n  }\n};\nvar BLOB_API_VERSION = 11;\nfunction getApiVersion() {\n  let versionOverride = null;\n  try {\n    versionOverride = process.env.VERCEL_BLOB_API_VERSION_OVERRIDE || process.env.NEXT_PUBLIC_VERCEL_BLOB_API_VERSION_OVERRIDE;\n  } catch {\n  }\n  return `${versionOverride != null ? versionOverride : BLOB_API_VERSION}`;\n}\nfunction getRetries() {\n  try {\n    const retries = process.env.VERCEL_BLOB_RETRIES || \"10\";\n    return parseInt(retries, 10);\n  } catch {\n    return 10;\n  }\n}\nfunction createBlobServiceRateLimited(response) {\n  const retryAfter = response.headers.get(\"retry-after\");\n  return new BlobServiceRateLimited(\n    retryAfter ? parseInt(retryAfter, 10) : void 0\n  );\n}\nasync function getBlobError(response) {\n  var _a3, _b2, _c;\n  let code;\n  let message;\n  try {\n    const data = await response.json();\n    code = (_b2 = (_a3 = data.error) == null ? void 0 : _a3.code) != null ? _b2 : \"unknown_error\";\n    message = (_c = data.error) == null ? void 0 : _c.message;\n  } catch {\n    code = \"unknown_error\";\n  }\n  if ((message == null ? void 0 : message.includes(\"contentType\")) && message.includes(\"is not allowed\")) {\n    code = \"content_type_not_allowed\";\n  }\n  if ((message == null ? void 0 : message.includes('\"pathname\"')) && message.includes(\"does not match the token payload\")) {\n    code = \"client_token_pathname_mismatch\";\n  }\n  if (message === \"Token expired\") {\n    code = \"client_token_expired\";\n  }\n  if (message == null ? void 0 : message.includes(\"the file length cannot be greater than\")) {\n    code = \"file_too_large\";\n  }\n  let error;\n  switch (code) {\n    case \"store_suspended\":\n      error = new BlobStoreSuspendedError();\n      break;\n    case \"forbidden\":\n      error = new BlobAccessError();\n      break;\n    case \"content_type_not_allowed\":\n      error = new BlobContentTypeNotAllowedError(message);\n      break;\n    case \"client_token_pathname_mismatch\":\n      error = new BlobPathnameMismatchError(message);\n      break;\n    case \"client_token_expired\":\n      error = new BlobClientTokenExpiredError();\n      break;\n    case \"file_too_large\":\n      error = new BlobFileTooLargeError(message);\n      break;\n    case \"not_found\":\n      error = new BlobNotFoundError();\n      break;\n    case \"store_not_found\":\n      error = new BlobStoreNotFoundError();\n      break;\n    case \"bad_request\":\n      error = new BlobError(message != null ? message : \"Bad request\");\n      break;\n    case \"service_unavailable\":\n      error = new BlobServiceNotAvailable();\n      break;\n    case \"rate_limited\":\n      error = createBlobServiceRateLimited(response);\n      break;\n    case \"unknown_error\":\n    case \"not_allowed\":\n    default:\n      error = new BlobUnknownError();\n      break;\n  }\n  return { code, error };\n}\nasync function requestApi(pathname, init, commandOptions) {\n  const apiVersion = getApiVersion();\n  const token = getTokenFromOptionsOrEnv(commandOptions);\n  const extraHeaders = getProxyThroughAlternativeApiHeaderFromEnv();\n  const [, , , storeId = \"\"] = token.split(\"_\");\n  const requestId = `${storeId}:${Date.now()}:${Math.random().toString(16).slice(2)}`;\n  let retryCount = 0;\n  let bodyLength = 0;\n  let totalLoaded = 0;\n  const sendBodyLength = (commandOptions == null ? void 0 : commandOptions.onUploadProgress) || shouldUseXContentLength();\n  if (init.body && // 1. For upload progress we always need to know the total size of the body\n  // 2. In development we need the header for put() to work correctly when passing a stream\n  sendBodyLength) {\n    bodyLength = computeBodyLength(init.body);\n  }\n  if (commandOptions == null ? void 0 : commandOptions.onUploadProgress) {\n    commandOptions.onUploadProgress({\n      loaded: 0,\n      total: bodyLength,\n      percentage: 0\n    });\n  }\n  const apiResponse = await async_retry__WEBPACK_IMPORTED_MODULE_3__(\n    async (bail) => {\n      let res;\n      try {\n        res = await blobRequest({\n          input: getApiUrl(pathname),\n          init: {\n            ...init,\n            headers: {\n              \"x-api-blob-request-id\": requestId,\n              \"x-api-blob-request-attempt\": String(retryCount),\n              \"x-api-version\": apiVersion,\n              ...sendBodyLength ? { \"x-content-length\": String(bodyLength) } : {},\n              authorization: `Bearer ${token}`,\n              ...extraHeaders,\n              ...init.headers\n            }\n          },\n          onUploadProgress: (commandOptions == null ? void 0 : commandOptions.onUploadProgress) ? (loaded) => {\n            var _a3;\n            const total = bodyLength !== 0 ? bodyLength : loaded;\n            totalLoaded = loaded;\n            const percentage = bodyLength > 0 ? Number((loaded / total * 100).toFixed(2)) : 0;\n            if (percentage === 100 && bodyLength > 0) {\n              return;\n            }\n            (_a3 = commandOptions.onUploadProgress) == null ? void 0 : _a3.call(commandOptions, {\n              loaded,\n              // When passing a stream to put(), we have no way to know the total size of the body.\n              // Instead of defining total as total?: number we decided to set the total to the currently\n              // loaded number. This is not inaccurate and way more practical for DX.\n              // Passing down a stream to put() is very rare\n              total,\n              percentage\n            });\n          } : void 0\n        });\n      } catch (error2) {\n        if (error2 instanceof DOMException2 && error2.name === \"AbortError\") {\n          bail(new BlobRequestAbortedError());\n          return;\n        }\n        if (isNetworkError(error2)) {\n          throw error2;\n        }\n        if (error2 instanceof TypeError) {\n          bail(error2);\n          return;\n        }\n        throw error2;\n      }\n      if (res.ok) {\n        return res;\n      }\n      const { code, error } = await getBlobError(res);\n      if (code === \"unknown_error\" || code === \"service_unavailable\" || code === \"internal_server_error\") {\n        throw error;\n      }\n      bail(error);\n    },\n    {\n      retries: getRetries(),\n      onRetry: (error) => {\n        if (error instanceof Error) {\n          debug(`retrying API request to ${pathname}`, error.message);\n        }\n        retryCount = retryCount + 1;\n      }\n    }\n  );\n  if (!apiResponse) {\n    throw new BlobUnknownError();\n  }\n  if (commandOptions == null ? void 0 : commandOptions.onUploadProgress) {\n    commandOptions.onUploadProgress({\n      loaded: totalLoaded,\n      total: totalLoaded,\n      percentage: 100\n    });\n  }\n  return await apiResponse.json();\n}\nfunction getProxyThroughAlternativeApiHeaderFromEnv() {\n  const extraHeaders = {};\n  try {\n    if (\"VERCEL_BLOB_PROXY_THROUGH_ALTERNATIVE_API\" in process.env && process.env.VERCEL_BLOB_PROXY_THROUGH_ALTERNATIVE_API !== void 0) {\n      extraHeaders[\"x-proxy-through-alternative-api\"] = process.env.VERCEL_BLOB_PROXY_THROUGH_ALTERNATIVE_API;\n    } else if (\"NEXT_PUBLIC_VERCEL_BLOB_PROXY_THROUGH_ALTERNATIVE_API\" in process.env && process.env.NEXT_PUBLIC_VERCEL_BLOB_PROXY_THROUGH_ALTERNATIVE_API !== void 0) {\n      extraHeaders[\"x-proxy-through-alternative-api\"] = process.env.NEXT_PUBLIC_VERCEL_BLOB_PROXY_THROUGH_ALTERNATIVE_API;\n    }\n  } catch {\n  }\n  return extraHeaders;\n}\nfunction shouldUseXContentLength() {\n  try {\n    return process.env.VERCEL_BLOB_USE_X_CONTENT_LENGTH === \"1\";\n  } catch {\n    return false;\n  }\n}\n\n// src/put-helpers.ts\nvar putOptionHeaderMap = {\n  cacheControlMaxAge: \"x-cache-control-max-age\",\n  addRandomSuffix: \"x-add-random-suffix\",\n  allowOverwrite: \"x-allow-overwrite\",\n  contentType: \"x-content-type\"\n};\nfunction createPutHeaders(allowedOptions, options) {\n  const headers = {};\n  if (allowedOptions.includes(\"contentType\") && options.contentType) {\n    headers[putOptionHeaderMap.contentType] = options.contentType;\n  }\n  if (allowedOptions.includes(\"addRandomSuffix\") && options.addRandomSuffix !== void 0) {\n    headers[putOptionHeaderMap.addRandomSuffix] = options.addRandomSuffix ? \"1\" : \"0\";\n  }\n  if (allowedOptions.includes(\"allowOverwrite\") && options.allowOverwrite !== void 0) {\n    headers[putOptionHeaderMap.allowOverwrite] = options.allowOverwrite ? \"1\" : \"0\";\n  }\n  if (allowedOptions.includes(\"cacheControlMaxAge\") && options.cacheControlMaxAge !== void 0) {\n    headers[putOptionHeaderMap.cacheControlMaxAge] = options.cacheControlMaxAge.toString();\n  }\n  return headers;\n}\nasync function createPutOptions({\n  pathname,\n  options,\n  extraChecks,\n  getToken\n}) {\n  if (!pathname) {\n    throw new BlobError(\"pathname is required\");\n  }\n  if (pathname.length > MAXIMUM_PATHNAME_LENGTH) {\n    throw new BlobError(\n      `pathname is too long, maximum length is ${MAXIMUM_PATHNAME_LENGTH}`\n    );\n  }\n  for (const invalidCharacter of disallowedPathnameCharacters) {\n    if (pathname.includes(invalidCharacter)) {\n      throw new BlobError(\n        `pathname cannot contain \"${invalidCharacter}\", please encode it if needed`\n      );\n    }\n  }\n  if (!options) {\n    throw new BlobError(\"missing options, see usage\");\n  }\n  if (options.access !== \"public\") {\n    throw new BlobError('access must be \"public\"');\n  }\n  if (extraChecks) {\n    extraChecks(options);\n  }\n  if (getToken) {\n    options.token = await getToken(pathname, options);\n  }\n  return options;\n}\n\n// src/multipart/complete.ts\nfunction createCompleteMultipartUploadMethod({ allowedOptions, getToken, extraChecks }) {\n  return async (pathname, parts, optionsInput) => {\n    const options = await createPutOptions({\n      pathname,\n      options: optionsInput,\n      extraChecks,\n      getToken\n    });\n    const headers = createPutHeaders(allowedOptions, options);\n    return completeMultipartUpload({\n      uploadId: options.uploadId,\n      key: options.key,\n      pathname,\n      headers,\n      options,\n      parts\n    });\n  };\n}\nasync function completeMultipartUpload({\n  uploadId,\n  key,\n  pathname,\n  parts,\n  headers,\n  options\n}) {\n  const params = new URLSearchParams({ pathname });\n  try {\n    const response = await requestApi(\n      `/mpu?${params.toString()}`,\n      {\n        method: \"POST\",\n        headers: {\n          ...headers,\n          \"content-type\": \"application/json\",\n          \"x-mpu-action\": \"complete\",\n          \"x-mpu-upload-id\": uploadId,\n          // key can be any utf8 character so we need to encode it as HTTP headers can only be us-ascii\n          // https://www.rfc-editor.org/rfc/rfc7230#swection-3.2.4\n          \"x-mpu-key\": encodeURIComponent(key)\n        },\n        body: JSON.stringify(parts),\n        signal: options.abortSignal\n      },\n      options\n    );\n    debug(\"mpu: complete\", response);\n    return response;\n  } catch (error) {\n    if (error instanceof TypeError && (error.message === \"Failed to fetch\" || error.message === \"fetch failed\")) {\n      throw new BlobServiceNotAvailable();\n    } else {\n      throw error;\n    }\n  }\n}\n\n// src/multipart/create.ts\nfunction createCreateMultipartUploadMethod({ allowedOptions, getToken, extraChecks }) {\n  return async (pathname, optionsInput) => {\n    const options = await createPutOptions({\n      pathname,\n      options: optionsInput,\n      extraChecks,\n      getToken\n    });\n    const headers = createPutHeaders(allowedOptions, options);\n    const createMultipartUploadResponse = await createMultipartUpload(\n      pathname,\n      headers,\n      options\n    );\n    return {\n      key: createMultipartUploadResponse.key,\n      uploadId: createMultipartUploadResponse.uploadId\n    };\n  };\n}\nasync function createMultipartUpload(pathname, headers, options) {\n  debug(\"mpu: create\", \"pathname:\", pathname);\n  const params = new URLSearchParams({ pathname });\n  try {\n    const response = await requestApi(\n      `/mpu?${params.toString()}`,\n      {\n        method: \"POST\",\n        headers: {\n          ...headers,\n          \"x-mpu-action\": \"create\"\n        },\n        signal: options.abortSignal\n      },\n      options\n    );\n    debug(\"mpu: create\", response);\n    return response;\n  } catch (error) {\n    if (error instanceof TypeError && (error.message === \"Failed to fetch\" || error.message === \"fetch failed\")) {\n      throw new BlobServiceNotAvailable();\n    }\n    throw error;\n  }\n}\n\n// src/multipart/upload.ts\n\nfunction createUploadPartMethod({ allowedOptions, getToken, extraChecks }) {\n  return async (pathname, body, optionsInput) => {\n    const options = await createPutOptions({\n      pathname,\n      options: optionsInput,\n      extraChecks,\n      getToken\n    });\n    const headers = createPutHeaders(allowedOptions, options);\n    if (isPlainObject(body)) {\n      throw new BlobError(\n        \"Body must be a string, buffer or stream. You sent a plain JavaScript object, double check what you're trying to upload.\"\n      );\n    }\n    const result = await uploadPart({\n      uploadId: options.uploadId,\n      key: options.key,\n      pathname,\n      part: { blob: body, partNumber: options.partNumber },\n      headers,\n      options\n    });\n    return {\n      etag: result.etag,\n      partNumber: options.partNumber\n    };\n  };\n}\nasync function uploadPart({\n  uploadId,\n  key,\n  pathname,\n  headers,\n  options,\n  internalAbortController = new AbortController(),\n  part\n}) {\n  var _a3, _b2, _c;\n  const params = new URLSearchParams({ pathname });\n  const responsePromise = requestApi(\n    `/mpu?${params.toString()}`,\n    {\n      signal: internalAbortController.signal,\n      method: \"POST\",\n      headers: {\n        ...headers,\n        \"x-mpu-action\": \"upload\",\n        \"x-mpu-key\": encodeURIComponent(key),\n        \"x-mpu-upload-id\": uploadId,\n        \"x-mpu-part-number\": part.partNumber.toString()\n      },\n      // weird things between undici types and native fetch types\n      body: part.blob\n    },\n    options\n  );\n  function handleAbort() {\n    internalAbortController.abort();\n  }\n  if ((_a3 = options.abortSignal) == null ? void 0 : _a3.aborted) {\n    handleAbort();\n  } else {\n    (_b2 = options.abortSignal) == null ? void 0 : _b2.addEventListener(\"abort\", handleAbort);\n  }\n  const response = await responsePromise;\n  (_c = options.abortSignal) == null ? void 0 : _c.removeEventListener(\"abort\", handleAbort);\n  return response;\n}\nvar maxConcurrentUploads = typeof window !== \"undefined\" ? 6 : 8;\nvar partSizeInBytes = 8 * 1024 * 1024;\nvar maxBytesInMemory = maxConcurrentUploads * partSizeInBytes * 2;\nfunction uploadAllParts({\n  uploadId,\n  key,\n  pathname,\n  stream,\n  headers,\n  options,\n  totalToLoad\n}) {\n  debug(\"mpu: upload init\", \"key:\", key);\n  const internalAbortController = new AbortController();\n  return new Promise((resolve, reject) => {\n    const partsToUpload = [];\n    const completedParts = [];\n    const reader = stream.getReader();\n    let activeUploads = 0;\n    let reading = false;\n    let currentPartNumber = 1;\n    let rejected = false;\n    let currentBytesInMemory = 0;\n    let doneReading = false;\n    let bytesSent = 0;\n    let arrayBuffers = [];\n    let currentPartBytesRead = 0;\n    let onUploadProgress;\n    const totalLoadedPerPartNumber = {};\n    if (options.onUploadProgress) {\n      onUploadProgress = throttleit__WEBPACK_IMPORTED_MODULE_5__(() => {\n        var _a3;\n        const loaded = Object.values(totalLoadedPerPartNumber).reduce(\n          (acc, cur) => {\n            return acc + cur;\n          },\n          0\n        );\n        const total = totalToLoad || loaded;\n        const percentage = totalToLoad > 0 ? Number(((loaded / totalToLoad || loaded) * 100).toFixed(2)) : 0;\n        (_a3 = options.onUploadProgress) == null ? void 0 : _a3.call(options, { loaded, total, percentage });\n      }, 150);\n    }\n    read().catch(cancel);\n    async function read() {\n      debug(\n        \"mpu: upload read start\",\n        \"activeUploads:\",\n        activeUploads,\n        \"currentBytesInMemory:\",\n        `${bytes(currentBytesInMemory)}/${bytes(maxBytesInMemory)}`,\n        \"bytesSent:\",\n        bytes(bytesSent)\n      );\n      reading = true;\n      while (currentBytesInMemory < maxBytesInMemory && !rejected) {\n        try {\n          const { value, done } = await reader.read();\n          if (done) {\n            doneReading = true;\n            debug(\"mpu: upload read consumed the whole stream\");\n            if (arrayBuffers.length > 0) {\n              partsToUpload.push({\n                partNumber: currentPartNumber++,\n                blob: new Blob(arrayBuffers, {\n                  type: \"application/octet-stream\"\n                })\n              });\n              sendParts();\n            }\n            reading = false;\n            return;\n          }\n          currentBytesInMemory += value.byteLength;\n          let valueOffset = 0;\n          while (valueOffset < value.byteLength) {\n            const remainingPartSize = partSizeInBytes - currentPartBytesRead;\n            const endOffset = Math.min(\n              valueOffset + remainingPartSize,\n              value.byteLength\n            );\n            const chunk = value.slice(valueOffset, endOffset);\n            arrayBuffers.push(chunk);\n            currentPartBytesRead += chunk.byteLength;\n            valueOffset = endOffset;\n            if (currentPartBytesRead === partSizeInBytes) {\n              partsToUpload.push({\n                partNumber: currentPartNumber++,\n                blob: new Blob(arrayBuffers, {\n                  type: \"application/octet-stream\"\n                })\n              });\n              arrayBuffers = [];\n              currentPartBytesRead = 0;\n              sendParts();\n            }\n          }\n        } catch (error) {\n          cancel(error);\n        }\n      }\n      debug(\n        \"mpu: upload read end\",\n        \"activeUploads:\",\n        activeUploads,\n        \"currentBytesInMemory:\",\n        `${bytes(currentBytesInMemory)}/${bytes(maxBytesInMemory)}`,\n        \"bytesSent:\",\n        bytes(bytesSent)\n      );\n      reading = false;\n    }\n    async function sendPart(part) {\n      activeUploads++;\n      debug(\n        \"mpu: upload send part start\",\n        \"partNumber:\",\n        part.partNumber,\n        \"size:\",\n        part.blob.size,\n        \"activeUploads:\",\n        activeUploads,\n        \"currentBytesInMemory:\",\n        `${bytes(currentBytesInMemory)}/${bytes(maxBytesInMemory)}`,\n        \"bytesSent:\",\n        bytes(bytesSent)\n      );\n      try {\n        const uploadProgressForPart = options.onUploadProgress ? (event) => {\n          totalLoadedPerPartNumber[part.partNumber] = event.loaded;\n          if (onUploadProgress) {\n            onUploadProgress();\n          }\n        } : void 0;\n        const completedPart = await uploadPart({\n          uploadId,\n          key,\n          pathname,\n          headers,\n          options: {\n            ...options,\n            onUploadProgress: uploadProgressForPart\n          },\n          internalAbortController,\n          part\n        });\n        debug(\n          \"mpu: upload send part end\",\n          \"partNumber:\",\n          part.partNumber,\n          \"activeUploads\",\n          activeUploads,\n          \"currentBytesInMemory:\",\n          `${bytes(currentBytesInMemory)}/${bytes(maxBytesInMemory)}`,\n          \"bytesSent:\",\n          bytes(bytesSent)\n        );\n        if (rejected) {\n          return;\n        }\n        completedParts.push({\n          partNumber: part.partNumber,\n          etag: completedPart.etag\n        });\n        currentBytesInMemory -= part.blob.size;\n        activeUploads--;\n        bytesSent += part.blob.size;\n        if (partsToUpload.length > 0) {\n          sendParts();\n        }\n        if (doneReading) {\n          if (activeUploads === 0) {\n            reader.releaseLock();\n            resolve(completedParts);\n          }\n          return;\n        }\n        if (!reading) {\n          read().catch(cancel);\n        }\n      } catch (error) {\n        cancel(error);\n      }\n    }\n    function sendParts() {\n      if (rejected) {\n        return;\n      }\n      debug(\n        \"send parts\",\n        \"activeUploads\",\n        activeUploads,\n        \"partsToUpload\",\n        partsToUpload.length\n      );\n      while (activeUploads < maxConcurrentUploads && partsToUpload.length > 0) {\n        const partToSend = partsToUpload.shift();\n        if (partToSend) {\n          void sendPart(partToSend);\n        }\n      }\n    }\n    function cancel(error) {\n      if (rejected) {\n        return;\n      }\n      rejected = true;\n      internalAbortController.abort();\n      reader.releaseLock();\n      if (error instanceof TypeError && (error.message === \"Failed to fetch\" || error.message === \"fetch failed\")) {\n        reject(new BlobServiceNotAvailable());\n      } else {\n        reject(error);\n      }\n    }\n  });\n}\n\n// src/multipart/create-uploader.ts\nfunction createCreateMultipartUploaderMethod({ allowedOptions, getToken, extraChecks }) {\n  return async (pathname, optionsInput) => {\n    const options = await createPutOptions({\n      pathname,\n      options: optionsInput,\n      extraChecks,\n      getToken\n    });\n    const headers = createPutHeaders(allowedOptions, options);\n    const createMultipartUploadResponse = await createMultipartUpload(\n      pathname,\n      headers,\n      options\n    );\n    return {\n      key: createMultipartUploadResponse.key,\n      uploadId: createMultipartUploadResponse.uploadId,\n      async uploadPart(partNumber, body) {\n        if (isPlainObject(body)) {\n          throw new BlobError(\n            \"Body must be a string, buffer or stream. You sent a plain JavaScript object, double check what you're trying to upload.\"\n          );\n        }\n        const result = await uploadPart({\n          uploadId: createMultipartUploadResponse.uploadId,\n          key: createMultipartUploadResponse.key,\n          pathname,\n          part: { partNumber, blob: body },\n          headers,\n          options\n        });\n        return {\n          etag: result.etag,\n          partNumber\n        };\n      },\n      async complete(parts) {\n        return completeMultipartUpload({\n          uploadId: createMultipartUploadResponse.uploadId,\n          key: createMultipartUploadResponse.key,\n          pathname,\n          parts,\n          headers,\n          options\n        });\n      }\n    };\n  };\n}\n\n// src/put.ts\n\n\n// src/multipart/uncontrolled.ts\nasync function uncontrolledMultipartUpload(pathname, body, headers, options) {\n  debug(\"mpu: init\", \"pathname:\", pathname, \"headers:\", headers);\n  const optionsWithoutOnUploadProgress = {\n    ...options,\n    onUploadProgress: void 0\n  };\n  const createMultipartUploadResponse = await createMultipartUpload(\n    pathname,\n    headers,\n    optionsWithoutOnUploadProgress\n  );\n  const totalToLoad = computeBodyLength(body);\n  const stream = await toReadableStream(body);\n  const parts = await uploadAllParts({\n    uploadId: createMultipartUploadResponse.uploadId,\n    key: createMultipartUploadResponse.key,\n    pathname,\n    stream,\n    headers,\n    options,\n    totalToLoad\n  });\n  const blob = await completeMultipartUpload({\n    uploadId: createMultipartUploadResponse.uploadId,\n    key: createMultipartUploadResponse.key,\n    pathname,\n    parts,\n    headers,\n    options: optionsWithoutOnUploadProgress\n  });\n  return blob;\n}\n\n// src/put.ts\nfunction createPutMethod({\n  allowedOptions,\n  getToken,\n  extraChecks\n}) {\n  return async function put(pathname, body, optionsInput) {\n    if (!body) {\n      throw new BlobError(\"body is required\");\n    }\n    if (isPlainObject(body)) {\n      throw new BlobError(\n        \"Body must be a string, buffer or stream. You sent a plain JavaScript object, double check what you're trying to upload.\"\n      );\n    }\n    const options = await createPutOptions({\n      pathname,\n      options: optionsInput,\n      extraChecks,\n      getToken\n    });\n    const headers = createPutHeaders(allowedOptions, options);\n    if (options.multipart === true) {\n      return uncontrolledMultipartUpload(pathname, body, headers, options);\n    }\n    const onUploadProgress = options.onUploadProgress ? throttleit__WEBPACK_IMPORTED_MODULE_5__(options.onUploadProgress, 100) : void 0;\n    const params = new URLSearchParams({ pathname });\n    const response = await requestApi(\n      `/?${params.toString()}`,\n      {\n        method: \"PUT\",\n        body,\n        headers,\n        signal: options.abortSignal\n      },\n      {\n        ...options,\n        onUploadProgress\n      }\n    );\n    return {\n      url: response.url,\n      downloadUrl: response.downloadUrl,\n      pathname: response.pathname,\n      contentType: response.contentType,\n      contentDisposition: response.contentDisposition\n    };\n  };\n}\n\n// src/create-folder.ts\nasync function createFolder(pathname, options = {}) {\n  const folderPathname = pathname.endsWith(\"/\") ? pathname : `${pathname}/`;\n  const headers = {};\n  headers[putOptionHeaderMap.addRandomSuffix] = \"0\";\n  const params = new URLSearchParams({ pathname: folderPathname });\n  const response = await requestApi(\n    `/?${params.toString()}`,\n    {\n      method: \"PUT\",\n      headers,\n      signal: options.abortSignal\n    },\n    options\n  );\n  return {\n    url: response.url,\n    pathname: response.pathname\n  };\n}\n\n\n/*!\n * bytes\n * Copyright(c) 2012-2014 TJ Holowaychuk\n * Copyright(c) 2015 Jed Watson\n * MIT Licensed\n */\n//# sourceMappingURL=chunk-FN6XFH6R.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHZlcmNlbC9ibG9iL2Rpc3QvY2h1bmstRk42WEZINlIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDZ0Q7O0FBRWhEO0FBQ2lDO0FBQ0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDRDQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxzQ0FBUTtBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixRQUFRO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSw4REFBYTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCx1Q0FBUztBQUNqRSx5Q0FBeUMsVUFBVTtBQUNuRDtBQUNBLFdBQVcsa0JBQWtCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtEQUFrRDtBQUNsRCxnRUFBZ0UsU0FBUztBQUN6RTtBQUNBO0FBQ0EsdUNBQXVDLDBCQUEwQjtBQUNqRTtBQUNBLFNBQVMsa0JBQWtCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQTJCRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWFzamlkb3MvLi9ub2RlX21vZHVsZXMvQHZlcmNlbC9ibG9iL2Rpc3QvY2h1bmstRk42WEZINlIuanM/NDg4YyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvaGVscGVycy50c1xuaW1wb3J0IHsgaXNOb2RlUHJvY2VzcyB9IGZyb20gXCJpcy1ub2RlLXByb2Nlc3NcIjtcblxuLy8gc3JjL211bHRpcGFydC9oZWxwZXJzLnRzXG5pbXBvcnQgaXNCdWZmZXIgZnJvbSBcImlzLWJ1ZmZlclwiO1xuaW1wb3J0IHsgUmVhZGFibGUgfSBmcm9tIFwic3RyZWFtXCI7XG52YXIgc3VwcG9ydHNOZXdCbG9iRnJvbUFycmF5QnVmZmVyID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCBoZWxsb0FzQXJyYXlCdWZmZXIgPSBuZXcgVWludDhBcnJheShbMTA0LCAxMDEsIDEwOCwgMTA4LCAxMTFdKTtcbiAgICBjb25zdCBibG9iID0gbmV3IEJsb2IoW2hlbGxvQXNBcnJheUJ1ZmZlcl0pO1xuICAgIGJsb2IudGV4dCgpLnRoZW4oKHRleHQpID0+IHtcbiAgICAgIHJlc29sdmUodGV4dCA9PT0gXCJoZWxsb1wiKTtcbiAgICB9KS5jYXRjaCgoKSA9PiB7XG4gICAgICByZXNvbHZlKGZhbHNlKTtcbiAgICB9KTtcbiAgfSBjYXRjaCB7XG4gICAgcmVzb2x2ZShmYWxzZSk7XG4gIH1cbn0pO1xuYXN5bmMgZnVuY3Rpb24gdG9SZWFkYWJsZVN0cmVhbSh2YWx1ZSkge1xuICBpZiAodmFsdWUgaW5zdGFuY2VvZiBSZWFkYWJsZVN0cmVhbSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAodmFsdWUgaW5zdGFuY2VvZiBCbG9iKSB7XG4gICAgcmV0dXJuIHZhbHVlLnN0cmVhbSgpO1xuICB9XG4gIGlmIChpc05vZGVKc1JlYWRhYmxlU3RyZWFtKHZhbHVlKSkge1xuICAgIHJldHVybiBSZWFkYWJsZS50b1dlYih2YWx1ZSk7XG4gIH1cbiAgbGV0IHN0cmVhbVZhbHVlO1xuICBpZiAodmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHN0cmVhbVZhbHVlID0gbmV3IFVpbnQ4QXJyYXkodmFsdWUpO1xuICB9IGVsc2UgaWYgKGlzTm9kZUpzQnVmZmVyKHZhbHVlKSkge1xuICAgIHN0cmVhbVZhbHVlID0gdmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgc3RyZWFtVmFsdWUgPSBzdHJpbmdUb1VpbnQ4QXJyYXkodmFsdWUpO1xuICB9XG4gIGlmIChhd2FpdCBzdXBwb3J0c05ld0Jsb2JGcm9tQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gbmV3IEJsb2IoW3N0cmVhbVZhbHVlXSkuc3RyZWFtKCk7XG4gIH1cbiAgcmV0dXJuIG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgc3RhcnQoY29udHJvbGxlcikge1xuICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHN0cmVhbVZhbHVlKTtcbiAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gaXNOb2RlSnNSZWFkYWJsZVN0cmVhbSh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiB2YWx1ZS5waXBlID09PSBcImZ1bmN0aW9uXCIgJiYgdmFsdWUucmVhZGFibGUgJiYgdHlwZW9mIHZhbHVlLl9yZWFkID09PSBcImZ1bmN0aW9uXCIgJiYgLy8gQHRzLWV4cGVjdC1lcnJvciBfcmVhZGFibGVTdGF0ZSBkb2VzIGV4aXN0cyBvbiBSZWFkYWJsZVxuICB0eXBlb2YgdmFsdWUuX3JlYWRhYmxlU3RhdGUgPT09IFwib2JqZWN0XCI7XG59XG5mdW5jdGlvbiBzdHJpbmdUb1VpbnQ4QXJyYXkocykge1xuICBjb25zdCBlbmMgPSBuZXcgVGV4dEVuY29kZXIoKTtcbiAgcmV0dXJuIGVuYy5lbmNvZGUocyk7XG59XG5mdW5jdGlvbiBpc05vZGVKc0J1ZmZlcih2YWx1ZSkge1xuICByZXR1cm4gaXNCdWZmZXIodmFsdWUpO1xufVxuXG4vLyBzcmMvYnl0ZXMudHNcbnZhciBwYXJzZVJlZ0V4cCA9IC9eKCgtfFxcKyk/KFxcZCsoPzpcXC5cXGQrKT8pKSAqKGtifG1ifGdifHRifHBiKSQvaTtcbnZhciBtYXAgPSB7XG4gIGI6IDEsXG4gIGtiOiAxIDw8IDEwLFxuICBtYjogMSA8PCAyMCxcbiAgZ2I6IDEgPDwgMzAsXG4gIHRiOiAxMDI0ICoqIDQsXG4gIHBiOiAxMDI0ICoqIDVcbn07XG5mdW5jdGlvbiBieXRlcyh2YWwpIHtcbiAgaWYgKHR5cGVvZiB2YWwgPT09IFwibnVtYmVyXCIgJiYgIU51bWJlci5pc05hTih2YWwpKSB7XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuICBpZiAodHlwZW9mIHZhbCAhPT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IHJlc3VsdHMgPSBwYXJzZVJlZ0V4cC5leGVjKHZhbCk7XG4gIGxldCBmbG9hdFZhbHVlO1xuICBsZXQgdW5pdCA9IFwiYlwiO1xuICBpZiAoIXJlc3VsdHMpIHtcbiAgICBmbG9hdFZhbHVlID0gcGFyc2VJbnQodmFsLCAxMCk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgWywgcmVzLCAsICwgdW5pdE1hdGNoXSA9IHJlc3VsdHM7XG4gICAgaWYgKCFyZXMpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBmbG9hdFZhbHVlID0gcGFyc2VGbG9hdChyZXMpO1xuICAgIGlmICh1bml0TWF0Y2gpIHtcbiAgICAgIHVuaXQgPSB1bml0TWF0Y2gudG9Mb3dlckNhc2UoKTtcbiAgICB9XG4gIH1cbiAgaWYgKE51bWJlci5pc05hTihmbG9hdFZhbHVlKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBNYXRoLmZsb29yKG1hcFt1bml0XSAqIGZsb2F0VmFsdWUpO1xufVxuXG4vLyBzcmMvaGVscGVycy50c1xudmFyIGRlZmF1bHRWZXJjZWxCbG9iQXBpVXJsID0gXCJodHRwczovL3ZlcmNlbC5jb20vYXBpL2Jsb2JcIjtcbmZ1bmN0aW9uIGdldFRva2VuRnJvbU9wdGlvbnNPckVudihvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLnRva2VuKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMudG9rZW47XG4gIH1cbiAgaWYgKHByb2Nlc3MuZW52LkJMT0JfUkVBRF9XUklURV9UT0tFTikge1xuICAgIHJldHVybiBwcm9jZXNzLmVudi5CTE9CX1JFQURfV1JJVEVfVE9LRU47XG4gIH1cbiAgdGhyb3cgbmV3IEJsb2JFcnJvcihcbiAgICBcIk5vIHRva2VuIGZvdW5kLiBFaXRoZXIgY29uZmlndXJlIHRoZSBgQkxPQl9SRUFEX1dSSVRFX1RPS0VOYCBlbnZpcm9ubWVudCB2YXJpYWJsZSwgb3IgcGFzcyBhIGB0b2tlbmAgb3B0aW9uIHRvIHlvdXIgY2FsbHMuXCJcbiAgKTtcbn1cbnZhciBCbG9iRXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgIHN1cGVyKGBWZXJjZWwgQmxvYjogJHttZXNzYWdlfWApO1xuICB9XG59O1xuZnVuY3Rpb24gZ2V0RG93bmxvYWRVcmwoYmxvYlVybCkge1xuICBjb25zdCB1cmwgPSBuZXcgVVJMKGJsb2JVcmwpO1xuICB1cmwuc2VhcmNoUGFyYW1zLnNldChcImRvd25sb2FkXCIsIFwiMVwiKTtcbiAgcmV0dXJuIHVybC50b1N0cmluZygpO1xufVxuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiIHx8IHZhbHVlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IHByb3RvdHlwZSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWx1ZSk7XG4gIHJldHVybiAocHJvdG90eXBlID09PSBudWxsIHx8IHByb3RvdHlwZSA9PT0gT2JqZWN0LnByb3RvdHlwZSB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YocHJvdG90eXBlKSA9PT0gbnVsbCkgJiYgIShTeW1ib2wudG9TdHJpbmdUYWcgaW4gdmFsdWUpICYmICEoU3ltYm9sLml0ZXJhdG9yIGluIHZhbHVlKTtcbn1cbnZhciBkaXNhbGxvd2VkUGF0aG5hbWVDaGFyYWN0ZXJzID0gW1wiLy9cIl07XG52YXIgc3VwcG9ydHNSZXF1ZXN0U3RyZWFtcyA9ICgoKSA9PiB7XG4gIGlmIChpc05vZGVQcm9jZXNzKCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjb25zdCBhcGlVcmwgPSBnZXRBcGlVcmwoKTtcbiAgaWYgKGFwaVVybC5zdGFydHNXaXRoKFwiaHR0cDovL2xvY2FsaG9zdFwiKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBsZXQgZHVwbGV4QWNjZXNzZWQgPSBmYWxzZTtcbiAgY29uc3QgaGFzQ29udGVudFR5cGUgPSBuZXcgUmVxdWVzdChnZXRBcGlVcmwoKSwge1xuICAgIGJvZHk6IG5ldyBSZWFkYWJsZVN0cmVhbSgpLFxuICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciAtLSBUeXBlU2NyaXB0IGRvZXNuJ3QgeWV0IGhhdmUgZHVwbGV4IGJ1dCBpdCdzIGluIHRoZSBzcGVjOiBodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L1R5cGVTY3JpcHQtRE9NLWxpYi1nZW5lcmF0b3IvcHVsbC8xNzI5XG4gICAgZ2V0IGR1cGxleCgpIHtcbiAgICAgIGR1cGxleEFjY2Vzc2VkID0gdHJ1ZTtcbiAgICAgIHJldHVybiBcImhhbGZcIjtcbiAgICB9XG4gIH0pLmhlYWRlcnMuaGFzKFwiQ29udGVudC1UeXBlXCIpO1xuICByZXR1cm4gZHVwbGV4QWNjZXNzZWQgJiYgIWhhc0NvbnRlbnRUeXBlO1xufSkoKTtcbmZ1bmN0aW9uIGdldEFwaVVybChwYXRobmFtZSA9IFwiXCIpIHtcbiAgbGV0IGJhc2VVcmwgPSBudWxsO1xuICB0cnkge1xuICAgIGJhc2VVcmwgPSBwcm9jZXNzLmVudi5WRVJDRUxfQkxPQl9BUElfVVJMIHx8IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1ZFUkNFTF9CTE9CX0FQSV9VUkw7XG4gIH0gY2F0Y2gge1xuICB9XG4gIHJldHVybiBgJHtiYXNlVXJsIHx8IGRlZmF1bHRWZXJjZWxCbG9iQXBpVXJsfSR7cGF0aG5hbWV9YDtcbn1cbnZhciBURVhUX0VOQ09ERVIgPSB0eXBlb2YgVGV4dEVuY29kZXIgPT09IFwiZnVuY3Rpb25cIiA/IG5ldyBUZXh0RW5jb2RlcigpIDogbnVsbDtcbmZ1bmN0aW9uIGNvbXB1dGVCb2R5TGVuZ3RoKGJvZHkpIHtcbiAgaWYgKCFib2R5KSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgaWYgKHR5cGVvZiBib2R5ID09PSBcInN0cmluZ1wiKSB7XG4gICAgaWYgKFRFWFRfRU5DT0RFUikge1xuICAgICAgcmV0dXJuIFRFWFRfRU5DT0RFUi5lbmNvZGUoYm9keSkuYnl0ZUxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBCbG9iKFtib2R5XSkuc2l6ZTtcbiAgfVxuICBpZiAoXCJieXRlTGVuZ3RoXCIgaW4gYm9keSAmJiB0eXBlb2YgYm9keS5ieXRlTGVuZ3RoID09PSBcIm51bWJlclwiKSB7XG4gICAgcmV0dXJuIGJvZHkuYnl0ZUxlbmd0aDtcbiAgfVxuICBpZiAoXCJzaXplXCIgaW4gYm9keSAmJiB0eXBlb2YgYm9keS5zaXplID09PSBcIm51bWJlclwiKSB7XG4gICAgcmV0dXJuIGJvZHkuc2l6ZTtcbiAgfVxuICByZXR1cm4gMDtcbn1cbnZhciBjcmVhdGVDaHVua1RyYW5zZm9ybVN0cmVhbSA9IChjaHVua1NpemUsIG9uUHJvZ3Jlc3MpID0+IHtcbiAgbGV0IGJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KDApO1xuICByZXR1cm4gbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgdHJhbnNmb3JtKGNodW5rLCBjb250cm9sbGVyKSB7XG4gICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG4gICAgICAgIGNvbnN0IG5ld0J1ZmZlciA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlci5sZW5ndGggKyBjaHVuay5ieXRlTGVuZ3RoKTtcbiAgICAgICAgbmV3QnVmZmVyLnNldChidWZmZXIpO1xuICAgICAgICBuZXdCdWZmZXIuc2V0KG5ldyBVaW50OEFycmF5KGNodW5rKSwgYnVmZmVyLmxlbmd0aCk7XG4gICAgICAgIGJ1ZmZlciA9IG5ld0J1ZmZlcjtcbiAgICAgICAgd2hpbGUgKGJ1ZmZlci5sZW5ndGggPj0gY2h1bmtTaXplKSB7XG4gICAgICAgICAgY29uc3QgbmV3Q2h1bmsgPSBidWZmZXIuc2xpY2UoMCwgY2h1bmtTaXplKTtcbiAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUobmV3Q2h1bmspO1xuICAgICAgICAgIG9uUHJvZ3Jlc3MgPT0gbnVsbCA/IHZvaWQgMCA6IG9uUHJvZ3Jlc3MobmV3Q2h1bmsuYnl0ZUxlbmd0aCk7XG4gICAgICAgICAgYnVmZmVyID0gYnVmZmVyLnNsaWNlKGNodW5rU2l6ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sXG4gICAgZmx1c2goY29udHJvbGxlcikge1xuICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgICBpZiAoYnVmZmVyLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoYnVmZmVyKTtcbiAgICAgICAgICBvblByb2dyZXNzID09IG51bGwgPyB2b2lkIDAgOiBvblByb2dyZXNzKGJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbn07XG5mdW5jdGlvbiBpc1JlYWRhYmxlU3RyZWFtKHZhbHVlKSB7XG4gIHJldHVybiBnbG9iYWxUaGlzLlJlYWRhYmxlU3RyZWFtICYmIC8vIFRPRE86IENhbiBiZSByZW1vdmVkIG9uY2UgTm9kZS5qcyAxNiBpcyBubyBtb3JlIHJlcXVpcmVkIGludGVybmFsbHlcbiAgdmFsdWUgaW5zdGFuY2VvZiBSZWFkYWJsZVN0cmVhbTtcbn1cbmZ1bmN0aW9uIGlzU3RyZWFtKHZhbHVlKSB7XG4gIGlmIChpc1JlYWRhYmxlU3RyZWFtKHZhbHVlKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChpc05vZGVKc1JlYWRhYmxlU3RyZWFtKHZhbHVlKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLy8gc3JjL2FwaS50c1xuaW1wb3J0IHJldHJ5IGZyb20gXCJhc3luYy1yZXRyeVwiO1xuXG4vLyBzcmMvZGVidWcudHNcbnZhciBkZWJ1Z0lzQWN0aXZlID0gZmFsc2U7XG52YXIgX2EsIF9iO1xudHJ5IHtcbiAgaWYgKCgoX2EgPSBwcm9jZXNzLmVudi5ERUJVRykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmluY2x1ZGVzKFwiYmxvYlwiKSkgfHwgKChfYiA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0RFQlVHKSA9PSBudWxsID8gdm9pZCAwIDogX2IuaW5jbHVkZXMoXCJibG9iXCIpKSkge1xuICAgIGRlYnVnSXNBY3RpdmUgPSB0cnVlO1xuICB9XG59IGNhdGNoIHtcbn1cbmZ1bmN0aW9uIGRlYnVnKG1lc3NhZ2UsIC4uLmFyZ3MpIHtcbiAgaWYgKGRlYnVnSXNBY3RpdmUpIHtcbiAgICBjb25zb2xlLmRlYnVnKGB2ZXJjZWwtYmxvYjogJHttZXNzYWdlfWAsIC4uLmFyZ3MpO1xuICB9XG59XG5cbi8vIHNyYy9kb20tZXhjZXB0aW9uLnRzXG52YXIgX2EyO1xudmFyIERPTUV4Y2VwdGlvbjIgPSAoX2EyID0gZ2xvYmFsVGhpcy5ET01FeGNlcHRpb24pICE9IG51bGwgPyBfYTIgOiAoKCkgPT4ge1xuICB0cnkge1xuICAgIGF0b2IoXCJ+XCIpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gT2JqZWN0LmdldFByb3RvdHlwZU9mKGVycikuY29uc3RydWN0b3I7XG4gIH1cbn0pKCk7XG5cbi8vIHNyYy9pcy1uZXR3b3JrLWVycm9yLnRzXG52YXIgb2JqZWN0VG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIGlzRXJyb3IgPSAodmFsdWUpID0+IG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpID09PSBcIltvYmplY3QgRXJyb3JdXCI7XG52YXIgZXJyb3JNZXNzYWdlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcbiAgXCJuZXR3b3JrIGVycm9yXCIsXG4gIC8vIENocm9tZVxuICBcIkZhaWxlZCB0byBmZXRjaFwiLFxuICAvLyBDaHJvbWVcbiAgXCJOZXR3b3JrRXJyb3Igd2hlbiBhdHRlbXB0aW5nIHRvIGZldGNoIHJlc291cmNlLlwiLFxuICAvLyBGaXJlZm94XG4gIFwiVGhlIEludGVybmV0IGNvbm5lY3Rpb24gYXBwZWFycyB0byBiZSBvZmZsaW5lLlwiLFxuICAvLyBTYWZhcmkgMTZcbiAgXCJMb2FkIGZhaWxlZFwiLFxuICAvLyBTYWZhcmkgMTcrXG4gIFwiTmV0d29yayByZXF1ZXN0IGZhaWxlZFwiLFxuICAvLyBgY3Jvc3MtZmV0Y2hgXG4gIFwiZmV0Y2ggZmFpbGVkXCIsXG4gIC8vIFVuZGljaSAoTm9kZS5qcylcbiAgXCJ0ZXJtaW5hdGVkXCJcbiAgLy8gVW5kaWNpIChOb2RlLmpzKVxuXSk7XG5mdW5jdGlvbiBpc05ldHdvcmtFcnJvcihlcnJvcikge1xuICBjb25zdCBpc1ZhbGlkID0gZXJyb3IgJiYgaXNFcnJvcihlcnJvcikgJiYgZXJyb3IubmFtZSA9PT0gXCJUeXBlRXJyb3JcIiAmJiB0eXBlb2YgZXJyb3IubWVzc2FnZSA9PT0gXCJzdHJpbmdcIjtcbiAgaWYgKCFpc1ZhbGlkKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChlcnJvci5tZXNzYWdlID09PSBcIkxvYWQgZmFpbGVkXCIpIHtcbiAgICByZXR1cm4gZXJyb3Iuc3RhY2sgPT09IHZvaWQgMDtcbiAgfVxuICByZXR1cm4gZXJyb3JNZXNzYWdlcy5oYXMoZXJyb3IubWVzc2FnZSk7XG59XG5cbi8vIHNyYy9mZXRjaC50c1xuaW1wb3J0IHsgZmV0Y2ggfSBmcm9tIFwidW5kaWNpXCI7XG52YXIgaGFzRmV0Y2ggPSB0eXBlb2YgZmV0Y2ggPT09IFwiZnVuY3Rpb25cIjtcbnZhciBoYXNGZXRjaFdpdGhVcGxvYWRQcm9ncmVzcyA9IGhhc0ZldGNoICYmIHN1cHBvcnRzUmVxdWVzdFN0cmVhbXM7XG52YXIgQ0hVTktfU0laRSA9IDY0ICogMTAyNDtcbnZhciBibG9iRmV0Y2ggPSBhc3luYyAoe1xuICBpbnB1dCxcbiAgaW5pdCxcbiAgb25VcGxvYWRQcm9ncmVzc1xufSkgPT4ge1xuICBkZWJ1ZyhcInVzaW5nIGZldGNoXCIpO1xuICBsZXQgYm9keTtcbiAgaWYgKGluaXQuYm9keSkge1xuICAgIGlmIChvblVwbG9hZFByb2dyZXNzKSB7XG4gICAgICBjb25zdCBzdHJlYW0gPSBhd2FpdCB0b1JlYWRhYmxlU3RyZWFtKGluaXQuYm9keSk7XG4gICAgICBsZXQgbG9hZGVkID0gMDtcbiAgICAgIGNvbnN0IGNodW5rVHJhbnNmb3JtU3RyZWFtID0gY3JlYXRlQ2h1bmtUcmFuc2Zvcm1TdHJlYW0oXG4gICAgICAgIENIVU5LX1NJWkUsXG4gICAgICAgIChuZXdMb2FkZWQpID0+IHtcbiAgICAgICAgICBsb2FkZWQgKz0gbmV3TG9hZGVkO1xuICAgICAgICAgIG9uVXBsb2FkUHJvZ3Jlc3MobG9hZGVkKTtcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICAgIGJvZHkgPSBzdHJlYW0ucGlwZVRocm91Z2goY2h1bmtUcmFuc2Zvcm1TdHJlYW0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBib2R5ID0gaW5pdC5ib2R5O1xuICAgIH1cbiAgfVxuICBjb25zdCBkdXBsZXggPSBzdXBwb3J0c1JlcXVlc3RTdHJlYW1zICYmIGJvZHkgJiYgaXNTdHJlYW0oYm9keSkgPyBcImhhbGZcIiA6IHZvaWQgMDtcbiAgcmV0dXJuIGZldGNoKFxuICAgIGlucHV0LFxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgLS0gQmxvYiBhbmQgTm9kZWpzIEJsb2IgYXJlIHRyaWdnZXJpbmcgdHlwZSBlcnJvcnMsIGZpbmUgd2l0aCBpdFxuICAgIHtcbiAgICAgIC4uLmluaXQsXG4gICAgICAuLi5pbml0LmJvZHkgPyB7IGJvZHkgfSA6IHt9LFxuICAgICAgZHVwbGV4XG4gICAgfVxuICApO1xufTtcblxuLy8gc3JjL3hoci50c1xudmFyIGhhc1hociA9IHR5cGVvZiBYTUxIdHRwUmVxdWVzdCAhPT0gXCJ1bmRlZmluZWRcIjtcbnZhciBibG9iWGhyID0gYXN5bmMgKHtcbiAgaW5wdXQsXG4gIGluaXQsXG4gIG9uVXBsb2FkUHJvZ3Jlc3Ncbn0pID0+IHtcbiAgZGVidWcoXCJ1c2luZyB4aHJcIik7XG4gIGxldCBib2R5ID0gbnVsbDtcbiAgaWYgKGluaXQuYm9keSkge1xuICAgIGlmIChpc1JlYWRhYmxlU3RyZWFtKGluaXQuYm9keSkpIHtcbiAgICAgIGJvZHkgPSBhd2FpdCBuZXcgUmVzcG9uc2UoaW5pdC5ib2R5KS5ibG9iKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJvZHkgPSBpbml0LmJvZHk7XG4gICAgfVxuICB9XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgY29uc3QgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgeGhyLm9wZW4oaW5pdC5tZXRob2QgfHwgXCJHRVRcIiwgaW5wdXQudG9TdHJpbmcoKSwgdHJ1ZSk7XG4gICAgaWYgKG9uVXBsb2FkUHJvZ3Jlc3MpIHtcbiAgICAgIHhoci51cGxvYWQuYWRkRXZlbnRMaXN0ZW5lcihcInByb2dyZXNzXCIsIChldmVudCkgPT4ge1xuICAgICAgICBpZiAoZXZlbnQubGVuZ3RoQ29tcHV0YWJsZSkge1xuICAgICAgICAgIG9uVXBsb2FkUHJvZ3Jlc3MoZXZlbnQubG9hZGVkKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHhoci5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICB2YXIgX2EzO1xuICAgICAgaWYgKChfYTMgPSBpbml0LnNpZ25hbCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMy5hYm9ydGVkKSB7XG4gICAgICAgIHJlamVjdChuZXcgRE9NRXhjZXB0aW9uKFwiVGhlIHVzZXIgYWJvcnRlZCB0aGUgcmVxdWVzdC5cIiwgXCJBYm9ydEVycm9yXCIpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgaGVhZGVycyA9IG5ldyBIZWFkZXJzKCk7XG4gICAgICBjb25zdCByYXdIZWFkZXJzID0geGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpLnRyaW0oKS5zcGxpdCgvW1xcclxcbl0rLyk7XG4gICAgICByYXdIZWFkZXJzLmZvckVhY2goKGxpbmUpID0+IHtcbiAgICAgICAgY29uc3QgcGFydHMgPSBsaW5lLnNwbGl0KFwiOiBcIik7XG4gICAgICAgIGNvbnN0IGtleSA9IHBhcnRzLnNoaWZ0KCk7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gcGFydHMuam9pbihcIjogXCIpO1xuICAgICAgICBpZiAoa2V5KSBoZWFkZXJzLnNldChrZXkudG9Mb3dlckNhc2UoKSwgdmFsdWUpO1xuICAgICAgfSk7XG4gICAgICBjb25zdCByZXNwb25zZSA9IG5ldyBSZXNwb25zZSh4aHIucmVzcG9uc2UsIHtcbiAgICAgICAgc3RhdHVzOiB4aHIuc3RhdHVzLFxuICAgICAgICBzdGF0dXNUZXh0OiB4aHIuc3RhdHVzVGV4dCxcbiAgICAgICAgaGVhZGVyc1xuICAgICAgfSk7XG4gICAgICByZXNvbHZlKHJlc3BvbnNlKTtcbiAgICB9O1xuICAgIHhoci5vbmVycm9yID0gKCkgPT4ge1xuICAgICAgcmVqZWN0KG5ldyBUeXBlRXJyb3IoXCJOZXR3b3JrIHJlcXVlc3QgZmFpbGVkXCIpKTtcbiAgICB9O1xuICAgIHhoci5vbnRpbWVvdXQgPSAoKSA9PiB7XG4gICAgICByZWplY3QobmV3IFR5cGVFcnJvcihcIk5ldHdvcmsgcmVxdWVzdCB0aW1lZCBvdXRcIikpO1xuICAgIH07XG4gICAgeGhyLm9uYWJvcnQgPSAoKSA9PiB7XG4gICAgICByZWplY3QobmV3IERPTUV4Y2VwdGlvbihcIlRoZSB1c2VyIGFib3J0ZWQgYSByZXF1ZXN0LlwiLCBcIkFib3J0RXJyb3JcIikpO1xuICAgIH07XG4gICAgaWYgKGluaXQuaGVhZGVycykge1xuICAgICAgY29uc3QgaGVhZGVycyA9IG5ldyBIZWFkZXJzKGluaXQuaGVhZGVycyk7XG4gICAgICBoZWFkZXJzLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoa2V5LCB2YWx1ZSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGluaXQuc2lnbmFsKSB7XG4gICAgICBpbml0LnNpZ25hbC5hZGRFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgKCkgPT4ge1xuICAgICAgICB4aHIuYWJvcnQoKTtcbiAgICAgIH0pO1xuICAgICAgaWYgKGluaXQuc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgeGhyLmFib3J0KCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgeGhyLnNlbmQoYm9keSk7XG4gIH0pO1xufTtcblxuLy8gc3JjL3JlcXVlc3QudHNcbnZhciBibG9iUmVxdWVzdCA9IGFzeW5jICh7XG4gIGlucHV0LFxuICBpbml0LFxuICBvblVwbG9hZFByb2dyZXNzXG59KSA9PiB7XG4gIGlmIChvblVwbG9hZFByb2dyZXNzKSB7XG4gICAgaWYgKGhhc0ZldGNoV2l0aFVwbG9hZFByb2dyZXNzKSB7XG4gICAgICByZXR1cm4gYmxvYkZldGNoKHsgaW5wdXQsIGluaXQsIG9uVXBsb2FkUHJvZ3Jlc3MgfSk7XG4gICAgfVxuICAgIGlmIChoYXNYaHIpIHtcbiAgICAgIHJldHVybiBibG9iWGhyKHsgaW5wdXQsIGluaXQsIG9uVXBsb2FkUHJvZ3Jlc3MgfSk7XG4gICAgfVxuICB9XG4gIGlmIChoYXNGZXRjaCkge1xuICAgIHJldHVybiBibG9iRmV0Y2goeyBpbnB1dCwgaW5pdCB9KTtcbiAgfVxuICBpZiAoaGFzWGhyKSB7XG4gICAgcmV0dXJuIGJsb2JYaHIoeyBpbnB1dCwgaW5pdCB9KTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXCJObyByZXF1ZXN0IGltcGxlbWVudGF0aW9uIGF2YWlsYWJsZVwiKTtcbn07XG5cbi8vIHNyYy9hcGkudHNcbnZhciBNQVhJTVVNX1BBVEhOQU1FX0xFTkdUSCA9IDk1MDtcbnZhciBCbG9iQWNjZXNzRXJyb3IgPSBjbGFzcyBleHRlbmRzIEJsb2JFcnJvciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKFwiQWNjZXNzIGRlbmllZCwgcGxlYXNlIHByb3ZpZGUgYSB2YWxpZCB0b2tlbiBmb3IgdGhpcyByZXNvdXJjZS5cIik7XG4gIH1cbn07XG52YXIgQmxvYkNvbnRlbnRUeXBlTm90QWxsb3dlZEVycm9yID0gY2xhc3MgZXh0ZW5kcyBCbG9iRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgc3VwZXIoYENvbnRlbnQgdHlwZSBtaXNtYXRjaCwgJHttZXNzYWdlfS5gKTtcbiAgfVxufTtcbnZhciBCbG9iUGF0aG5hbWVNaXNtYXRjaEVycm9yID0gY2xhc3MgZXh0ZW5kcyBCbG9iRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgc3VwZXIoXG4gICAgICBgUGF0aG5hbWUgbWlzbWF0Y2gsICR7bWVzc2FnZX0uIENoZWNrIHRoZSBwYXRobmFtZSB1c2VkIGluIHVwbG9hZCgpIG9yIHB1dCgpIG1hdGNoZXMgdGhlIG9uZSBmcm9tIHRoZSBjbGllbnQgdG9rZW4uYFxuICAgICk7XG4gIH1cbn07XG52YXIgQmxvYkNsaWVudFRva2VuRXhwaXJlZEVycm9yID0gY2xhc3MgZXh0ZW5kcyBCbG9iRXJyb3Ige1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihcIkNsaWVudCB0b2tlbiBoYXMgZXhwaXJlZC5cIik7XG4gIH1cbn07XG52YXIgQmxvYkZpbGVUb29MYXJnZUVycm9yID0gY2xhc3MgZXh0ZW5kcyBCbG9iRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgc3VwZXIoYEZpbGUgaXMgdG9vIGxhcmdlLCAke21lc3NhZ2V9LmApO1xuICB9XG59O1xudmFyIEJsb2JTdG9yZU5vdEZvdW5kRXJyb3IgPSBjbGFzcyBleHRlbmRzIEJsb2JFcnJvciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKFwiVGhpcyBzdG9yZSBkb2VzIG5vdCBleGlzdC5cIik7XG4gIH1cbn07XG52YXIgQmxvYlN0b3JlU3VzcGVuZGVkRXJyb3IgPSBjbGFzcyBleHRlbmRzIEJsb2JFcnJvciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKFwiVGhpcyBzdG9yZSBoYXMgYmVlbiBzdXNwZW5kZWQuXCIpO1xuICB9XG59O1xudmFyIEJsb2JVbmtub3duRXJyb3IgPSBjbGFzcyBleHRlbmRzIEJsb2JFcnJvciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKFwiVW5rbm93biBlcnJvciwgcGxlYXNlIHZpc2l0IGh0dHBzOi8vdmVyY2VsLmNvbS9oZWxwLlwiKTtcbiAgfVxufTtcbnZhciBCbG9iTm90Rm91bmRFcnJvciA9IGNsYXNzIGV4dGVuZHMgQmxvYkVycm9yIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoXCJUaGUgcmVxdWVzdGVkIGJsb2IgZG9lcyBub3QgZXhpc3RcIik7XG4gIH1cbn07XG52YXIgQmxvYlNlcnZpY2VOb3RBdmFpbGFibGUgPSBjbGFzcyBleHRlbmRzIEJsb2JFcnJvciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKFwiVGhlIGJsb2Igc2VydmljZSBpcyBjdXJyZW50bHkgbm90IGF2YWlsYWJsZS4gUGxlYXNlIHRyeSBhZ2Fpbi5cIik7XG4gIH1cbn07XG52YXIgQmxvYlNlcnZpY2VSYXRlTGltaXRlZCA9IGNsYXNzIGV4dGVuZHMgQmxvYkVycm9yIHtcbiAgY29uc3RydWN0b3Ioc2Vjb25kcykge1xuICAgIHN1cGVyKFxuICAgICAgYFRvbyBtYW55IHJlcXVlc3RzIHBsZWFzZSBsb3dlciB0aGUgbnVtYmVyIG9mIGNvbmN1cnJlbnQgcmVxdWVzdHMgJHtzZWNvbmRzID8gYCAtIHRyeSBhZ2FpbiBpbiAke3NlY29uZHN9IHNlY29uZHNgIDogXCJcIn0uYFxuICAgICk7XG4gICAgdGhpcy5yZXRyeUFmdGVyID0gc2Vjb25kcyAhPSBudWxsID8gc2Vjb25kcyA6IDA7XG4gIH1cbn07XG52YXIgQmxvYlJlcXVlc3RBYm9ydGVkRXJyb3IgPSBjbGFzcyBleHRlbmRzIEJsb2JFcnJvciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKFwiVGhlIHJlcXVlc3Qgd2FzIGFib3J0ZWQuXCIpO1xuICB9XG59O1xudmFyIEJMT0JfQVBJX1ZFUlNJT04gPSAxMTtcbmZ1bmN0aW9uIGdldEFwaVZlcnNpb24oKSB7XG4gIGxldCB2ZXJzaW9uT3ZlcnJpZGUgPSBudWxsO1xuICB0cnkge1xuICAgIHZlcnNpb25PdmVycmlkZSA9IHByb2Nlc3MuZW52LlZFUkNFTF9CTE9CX0FQSV9WRVJTSU9OX09WRVJSSURFIHx8IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1ZFUkNFTF9CTE9CX0FQSV9WRVJTSU9OX09WRVJSSURFO1xuICB9IGNhdGNoIHtcbiAgfVxuICByZXR1cm4gYCR7dmVyc2lvbk92ZXJyaWRlICE9IG51bGwgPyB2ZXJzaW9uT3ZlcnJpZGUgOiBCTE9CX0FQSV9WRVJTSU9OfWA7XG59XG5mdW5jdGlvbiBnZXRSZXRyaWVzKCkge1xuICB0cnkge1xuICAgIGNvbnN0IHJldHJpZXMgPSBwcm9jZXNzLmVudi5WRVJDRUxfQkxPQl9SRVRSSUVTIHx8IFwiMTBcIjtcbiAgICByZXR1cm4gcGFyc2VJbnQocmV0cmllcywgMTApO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gMTA7XG4gIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZUJsb2JTZXJ2aWNlUmF0ZUxpbWl0ZWQocmVzcG9uc2UpIHtcbiAgY29uc3QgcmV0cnlBZnRlciA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwicmV0cnktYWZ0ZXJcIik7XG4gIHJldHVybiBuZXcgQmxvYlNlcnZpY2VSYXRlTGltaXRlZChcbiAgICByZXRyeUFmdGVyID8gcGFyc2VJbnQocmV0cnlBZnRlciwgMTApIDogdm9pZCAwXG4gICk7XG59XG5hc3luYyBmdW5jdGlvbiBnZXRCbG9iRXJyb3IocmVzcG9uc2UpIHtcbiAgdmFyIF9hMywgX2IyLCBfYztcbiAgbGV0IGNvZGU7XG4gIGxldCBtZXNzYWdlO1xuICB0cnkge1xuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgY29kZSA9IChfYjIgPSAoX2EzID0gZGF0YS5lcnJvcikgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMy5jb2RlKSAhPSBudWxsID8gX2IyIDogXCJ1bmtub3duX2Vycm9yXCI7XG4gICAgbWVzc2FnZSA9IChfYyA9IGRhdGEuZXJyb3IpID09IG51bGwgPyB2b2lkIDAgOiBfYy5tZXNzYWdlO1xuICB9IGNhdGNoIHtcbiAgICBjb2RlID0gXCJ1bmtub3duX2Vycm9yXCI7XG4gIH1cbiAgaWYgKChtZXNzYWdlID09IG51bGwgPyB2b2lkIDAgOiBtZXNzYWdlLmluY2x1ZGVzKFwiY29udGVudFR5cGVcIikpICYmIG1lc3NhZ2UuaW5jbHVkZXMoXCJpcyBub3QgYWxsb3dlZFwiKSkge1xuICAgIGNvZGUgPSBcImNvbnRlbnRfdHlwZV9ub3RfYWxsb3dlZFwiO1xuICB9XG4gIGlmICgobWVzc2FnZSA9PSBudWxsID8gdm9pZCAwIDogbWVzc2FnZS5pbmNsdWRlcygnXCJwYXRobmFtZVwiJykpICYmIG1lc3NhZ2UuaW5jbHVkZXMoXCJkb2VzIG5vdCBtYXRjaCB0aGUgdG9rZW4gcGF5bG9hZFwiKSkge1xuICAgIGNvZGUgPSBcImNsaWVudF90b2tlbl9wYXRobmFtZV9taXNtYXRjaFwiO1xuICB9XG4gIGlmIChtZXNzYWdlID09PSBcIlRva2VuIGV4cGlyZWRcIikge1xuICAgIGNvZGUgPSBcImNsaWVudF90b2tlbl9leHBpcmVkXCI7XG4gIH1cbiAgaWYgKG1lc3NhZ2UgPT0gbnVsbCA/IHZvaWQgMCA6IG1lc3NhZ2UuaW5jbHVkZXMoXCJ0aGUgZmlsZSBsZW5ndGggY2Fubm90IGJlIGdyZWF0ZXIgdGhhblwiKSkge1xuICAgIGNvZGUgPSBcImZpbGVfdG9vX2xhcmdlXCI7XG4gIH1cbiAgbGV0IGVycm9yO1xuICBzd2l0Y2ggKGNvZGUpIHtcbiAgICBjYXNlIFwic3RvcmVfc3VzcGVuZGVkXCI6XG4gICAgICBlcnJvciA9IG5ldyBCbG9iU3RvcmVTdXNwZW5kZWRFcnJvcigpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImZvcmJpZGRlblwiOlxuICAgICAgZXJyb3IgPSBuZXcgQmxvYkFjY2Vzc0Vycm9yKCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiY29udGVudF90eXBlX25vdF9hbGxvd2VkXCI6XG4gICAgICBlcnJvciA9IG5ldyBCbG9iQ29udGVudFR5cGVOb3RBbGxvd2VkRXJyb3IobWVzc2FnZSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiY2xpZW50X3Rva2VuX3BhdGhuYW1lX21pc21hdGNoXCI6XG4gICAgICBlcnJvciA9IG5ldyBCbG9iUGF0aG5hbWVNaXNtYXRjaEVycm9yKG1lc3NhZ2UpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImNsaWVudF90b2tlbl9leHBpcmVkXCI6XG4gICAgICBlcnJvciA9IG5ldyBCbG9iQ2xpZW50VG9rZW5FeHBpcmVkRXJyb3IoKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJmaWxlX3Rvb19sYXJnZVwiOlxuICAgICAgZXJyb3IgPSBuZXcgQmxvYkZpbGVUb29MYXJnZUVycm9yKG1lc3NhZ2UpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIm5vdF9mb3VuZFwiOlxuICAgICAgZXJyb3IgPSBuZXcgQmxvYk5vdEZvdW5kRXJyb3IoKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJzdG9yZV9ub3RfZm91bmRcIjpcbiAgICAgIGVycm9yID0gbmV3IEJsb2JTdG9yZU5vdEZvdW5kRXJyb3IoKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJiYWRfcmVxdWVzdFwiOlxuICAgICAgZXJyb3IgPSBuZXcgQmxvYkVycm9yKG1lc3NhZ2UgIT0gbnVsbCA/IG1lc3NhZ2UgOiBcIkJhZCByZXF1ZXN0XCIpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcInNlcnZpY2VfdW5hdmFpbGFibGVcIjpcbiAgICAgIGVycm9yID0gbmV3IEJsb2JTZXJ2aWNlTm90QXZhaWxhYmxlKCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwicmF0ZV9saW1pdGVkXCI6XG4gICAgICBlcnJvciA9IGNyZWF0ZUJsb2JTZXJ2aWNlUmF0ZUxpbWl0ZWQocmVzcG9uc2UpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcInVua25vd25fZXJyb3JcIjpcbiAgICBjYXNlIFwibm90X2FsbG93ZWRcIjpcbiAgICBkZWZhdWx0OlxuICAgICAgZXJyb3IgPSBuZXcgQmxvYlVua25vd25FcnJvcigpO1xuICAgICAgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIHsgY29kZSwgZXJyb3IgfTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHJlcXVlc3RBcGkocGF0aG5hbWUsIGluaXQsIGNvbW1hbmRPcHRpb25zKSB7XG4gIGNvbnN0IGFwaVZlcnNpb24gPSBnZXRBcGlWZXJzaW9uKCk7XG4gIGNvbnN0IHRva2VuID0gZ2V0VG9rZW5Gcm9tT3B0aW9uc09yRW52KGNvbW1hbmRPcHRpb25zKTtcbiAgY29uc3QgZXh0cmFIZWFkZXJzID0gZ2V0UHJveHlUaHJvdWdoQWx0ZXJuYXRpdmVBcGlIZWFkZXJGcm9tRW52KCk7XG4gIGNvbnN0IFssICwgLCBzdG9yZUlkID0gXCJcIl0gPSB0b2tlbi5zcGxpdChcIl9cIik7XG4gIGNvbnN0IHJlcXVlc3RJZCA9IGAke3N0b3JlSWR9OiR7RGF0ZS5ub3coKX06JHtNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDE2KS5zbGljZSgyKX1gO1xuICBsZXQgcmV0cnlDb3VudCA9IDA7XG4gIGxldCBib2R5TGVuZ3RoID0gMDtcbiAgbGV0IHRvdGFsTG9hZGVkID0gMDtcbiAgY29uc3Qgc2VuZEJvZHlMZW5ndGggPSAoY29tbWFuZE9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IGNvbW1hbmRPcHRpb25zLm9uVXBsb2FkUHJvZ3Jlc3MpIHx8IHNob3VsZFVzZVhDb250ZW50TGVuZ3RoKCk7XG4gIGlmIChpbml0LmJvZHkgJiYgLy8gMS4gRm9yIHVwbG9hZCBwcm9ncmVzcyB3ZSBhbHdheXMgbmVlZCB0byBrbm93IHRoZSB0b3RhbCBzaXplIG9mIHRoZSBib2R5XG4gIC8vIDIuIEluIGRldmVsb3BtZW50IHdlIG5lZWQgdGhlIGhlYWRlciBmb3IgcHV0KCkgdG8gd29yayBjb3JyZWN0bHkgd2hlbiBwYXNzaW5nIGEgc3RyZWFtXG4gIHNlbmRCb2R5TGVuZ3RoKSB7XG4gICAgYm9keUxlbmd0aCA9IGNvbXB1dGVCb2R5TGVuZ3RoKGluaXQuYm9keSk7XG4gIH1cbiAgaWYgKGNvbW1hbmRPcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBjb21tYW5kT3B0aW9ucy5vblVwbG9hZFByb2dyZXNzKSB7XG4gICAgY29tbWFuZE9wdGlvbnMub25VcGxvYWRQcm9ncmVzcyh7XG4gICAgICBsb2FkZWQ6IDAsXG4gICAgICB0b3RhbDogYm9keUxlbmd0aCxcbiAgICAgIHBlcmNlbnRhZ2U6IDBcbiAgICB9KTtcbiAgfVxuICBjb25zdCBhcGlSZXNwb25zZSA9IGF3YWl0IHJldHJ5KFxuICAgIGFzeW5jIChiYWlsKSA9PiB7XG4gICAgICBsZXQgcmVzO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmVzID0gYXdhaXQgYmxvYlJlcXVlc3Qoe1xuICAgICAgICAgIGlucHV0OiBnZXRBcGlVcmwocGF0aG5hbWUpLFxuICAgICAgICAgIGluaXQ6IHtcbiAgICAgICAgICAgIC4uLmluaXQsXG4gICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgIFwieC1hcGktYmxvYi1yZXF1ZXN0LWlkXCI6IHJlcXVlc3RJZCxcbiAgICAgICAgICAgICAgXCJ4LWFwaS1ibG9iLXJlcXVlc3QtYXR0ZW1wdFwiOiBTdHJpbmcocmV0cnlDb3VudCksXG4gICAgICAgICAgICAgIFwieC1hcGktdmVyc2lvblwiOiBhcGlWZXJzaW9uLFxuICAgICAgICAgICAgICAuLi5zZW5kQm9keUxlbmd0aCA/IHsgXCJ4LWNvbnRlbnQtbGVuZ3RoXCI6IFN0cmluZyhib2R5TGVuZ3RoKSB9IDoge30sXG4gICAgICAgICAgICAgIGF1dGhvcml6YXRpb246IGBCZWFyZXIgJHt0b2tlbn1gLFxuICAgICAgICAgICAgICAuLi5leHRyYUhlYWRlcnMsXG4gICAgICAgICAgICAgIC4uLmluaXQuaGVhZGVyc1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgb25VcGxvYWRQcm9ncmVzczogKGNvbW1hbmRPcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBjb21tYW5kT3B0aW9ucy5vblVwbG9hZFByb2dyZXNzKSA/IChsb2FkZWQpID0+IHtcbiAgICAgICAgICAgIHZhciBfYTM7XG4gICAgICAgICAgICBjb25zdCB0b3RhbCA9IGJvZHlMZW5ndGggIT09IDAgPyBib2R5TGVuZ3RoIDogbG9hZGVkO1xuICAgICAgICAgICAgdG90YWxMb2FkZWQgPSBsb2FkZWQ7XG4gICAgICAgICAgICBjb25zdCBwZXJjZW50YWdlID0gYm9keUxlbmd0aCA+IDAgPyBOdW1iZXIoKGxvYWRlZCAvIHRvdGFsICogMTAwKS50b0ZpeGVkKDIpKSA6IDA7XG4gICAgICAgICAgICBpZiAocGVyY2VudGFnZSA9PT0gMTAwICYmIGJvZHlMZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIChfYTMgPSBjb21tYW5kT3B0aW9ucy5vblVwbG9hZFByb2dyZXNzKSA9PSBudWxsID8gdm9pZCAwIDogX2EzLmNhbGwoY29tbWFuZE9wdGlvbnMsIHtcbiAgICAgICAgICAgICAgbG9hZGVkLFxuICAgICAgICAgICAgICAvLyBXaGVuIHBhc3NpbmcgYSBzdHJlYW0gdG8gcHV0KCksIHdlIGhhdmUgbm8gd2F5IHRvIGtub3cgdGhlIHRvdGFsIHNpemUgb2YgdGhlIGJvZHkuXG4gICAgICAgICAgICAgIC8vIEluc3RlYWQgb2YgZGVmaW5pbmcgdG90YWwgYXMgdG90YWw/OiBudW1iZXIgd2UgZGVjaWRlZCB0byBzZXQgdGhlIHRvdGFsIHRvIHRoZSBjdXJyZW50bHlcbiAgICAgICAgICAgICAgLy8gbG9hZGVkIG51bWJlci4gVGhpcyBpcyBub3QgaW5hY2N1cmF0ZSBhbmQgd2F5IG1vcmUgcHJhY3RpY2FsIGZvciBEWC5cbiAgICAgICAgICAgICAgLy8gUGFzc2luZyBkb3duIGEgc3RyZWFtIHRvIHB1dCgpIGlzIHZlcnkgcmFyZVxuICAgICAgICAgICAgICB0b3RhbCxcbiAgICAgICAgICAgICAgcGVyY2VudGFnZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSA6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yMikge1xuICAgICAgICBpZiAoZXJyb3IyIGluc3RhbmNlb2YgRE9NRXhjZXB0aW9uMiAmJiBlcnJvcjIubmFtZSA9PT0gXCJBYm9ydEVycm9yXCIpIHtcbiAgICAgICAgICBiYWlsKG5ldyBCbG9iUmVxdWVzdEFib3J0ZWRFcnJvcigpKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTmV0d29ya0Vycm9yKGVycm9yMikpIHtcbiAgICAgICAgICB0aHJvdyBlcnJvcjI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVycm9yMiBpbnN0YW5jZW9mIFR5cGVFcnJvcikge1xuICAgICAgICAgIGJhaWwoZXJyb3IyKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZXJyb3IyO1xuICAgICAgfVxuICAgICAgaWYgKHJlcy5vaykge1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgfVxuICAgICAgY29uc3QgeyBjb2RlLCBlcnJvciB9ID0gYXdhaXQgZ2V0QmxvYkVycm9yKHJlcyk7XG4gICAgICBpZiAoY29kZSA9PT0gXCJ1bmtub3duX2Vycm9yXCIgfHwgY29kZSA9PT0gXCJzZXJ2aWNlX3VuYXZhaWxhYmxlXCIgfHwgY29kZSA9PT0gXCJpbnRlcm5hbF9zZXJ2ZXJfZXJyb3JcIikge1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICAgIGJhaWwoZXJyb3IpO1xuICAgIH0sXG4gICAge1xuICAgICAgcmV0cmllczogZ2V0UmV0cmllcygpLFxuICAgICAgb25SZXRyeTogKGVycm9yKSA9PiB7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgZGVidWcoYHJldHJ5aW5nIEFQSSByZXF1ZXN0IHRvICR7cGF0aG5hbWV9YCwgZXJyb3IubWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0cnlDb3VudCA9IHJldHJ5Q291bnQgKyAxO1xuICAgICAgfVxuICAgIH1cbiAgKTtcbiAgaWYgKCFhcGlSZXNwb25zZSkge1xuICAgIHRocm93IG5ldyBCbG9iVW5rbm93bkVycm9yKCk7XG4gIH1cbiAgaWYgKGNvbW1hbmRPcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBjb21tYW5kT3B0aW9ucy5vblVwbG9hZFByb2dyZXNzKSB7XG4gICAgY29tbWFuZE9wdGlvbnMub25VcGxvYWRQcm9ncmVzcyh7XG4gICAgICBsb2FkZWQ6IHRvdGFsTG9hZGVkLFxuICAgICAgdG90YWw6IHRvdGFsTG9hZGVkLFxuICAgICAgcGVyY2VudGFnZTogMTAwXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGF3YWl0IGFwaVJlc3BvbnNlLmpzb24oKTtcbn1cbmZ1bmN0aW9uIGdldFByb3h5VGhyb3VnaEFsdGVybmF0aXZlQXBpSGVhZGVyRnJvbUVudigpIHtcbiAgY29uc3QgZXh0cmFIZWFkZXJzID0ge307XG4gIHRyeSB7XG4gICAgaWYgKFwiVkVSQ0VMX0JMT0JfUFJPWFlfVEhST1VHSF9BTFRFUk5BVElWRV9BUElcIiBpbiBwcm9jZXNzLmVudiAmJiBwcm9jZXNzLmVudi5WRVJDRUxfQkxPQl9QUk9YWV9USFJPVUdIX0FMVEVSTkFUSVZFX0FQSSAhPT0gdm9pZCAwKSB7XG4gICAgICBleHRyYUhlYWRlcnNbXCJ4LXByb3h5LXRocm91Z2gtYWx0ZXJuYXRpdmUtYXBpXCJdID0gcHJvY2Vzcy5lbnYuVkVSQ0VMX0JMT0JfUFJPWFlfVEhST1VHSF9BTFRFUk5BVElWRV9BUEk7XG4gICAgfSBlbHNlIGlmIChcIk5FWFRfUFVCTElDX1ZFUkNFTF9CTE9CX1BST1hZX1RIUk9VR0hfQUxURVJOQVRJVkVfQVBJXCIgaW4gcHJvY2Vzcy5lbnYgJiYgcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfVkVSQ0VMX0JMT0JfUFJPWFlfVEhST1VHSF9BTFRFUk5BVElWRV9BUEkgIT09IHZvaWQgMCkge1xuICAgICAgZXh0cmFIZWFkZXJzW1wieC1wcm94eS10aHJvdWdoLWFsdGVybmF0aXZlLWFwaVwiXSA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1ZFUkNFTF9CTE9CX1BST1hZX1RIUk9VR0hfQUxURVJOQVRJVkVfQVBJO1xuICAgIH1cbiAgfSBjYXRjaCB7XG4gIH1cbiAgcmV0dXJuIGV4dHJhSGVhZGVycztcbn1cbmZ1bmN0aW9uIHNob3VsZFVzZVhDb250ZW50TGVuZ3RoKCkge1xuICB0cnkge1xuICAgIHJldHVybiBwcm9jZXNzLmVudi5WRVJDRUxfQkxPQl9VU0VfWF9DT05URU5UX0xFTkdUSCA9PT0gXCIxXCI7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vLyBzcmMvcHV0LWhlbHBlcnMudHNcbnZhciBwdXRPcHRpb25IZWFkZXJNYXAgPSB7XG4gIGNhY2hlQ29udHJvbE1heEFnZTogXCJ4LWNhY2hlLWNvbnRyb2wtbWF4LWFnZVwiLFxuICBhZGRSYW5kb21TdWZmaXg6IFwieC1hZGQtcmFuZG9tLXN1ZmZpeFwiLFxuICBhbGxvd092ZXJ3cml0ZTogXCJ4LWFsbG93LW92ZXJ3cml0ZVwiLFxuICBjb250ZW50VHlwZTogXCJ4LWNvbnRlbnQtdHlwZVwiXG59O1xuZnVuY3Rpb24gY3JlYXRlUHV0SGVhZGVycyhhbGxvd2VkT3B0aW9ucywgb3B0aW9ucykge1xuICBjb25zdCBoZWFkZXJzID0ge307XG4gIGlmIChhbGxvd2VkT3B0aW9ucy5pbmNsdWRlcyhcImNvbnRlbnRUeXBlXCIpICYmIG9wdGlvbnMuY29udGVudFR5cGUpIHtcbiAgICBoZWFkZXJzW3B1dE9wdGlvbkhlYWRlck1hcC5jb250ZW50VHlwZV0gPSBvcHRpb25zLmNvbnRlbnRUeXBlO1xuICB9XG4gIGlmIChhbGxvd2VkT3B0aW9ucy5pbmNsdWRlcyhcImFkZFJhbmRvbVN1ZmZpeFwiKSAmJiBvcHRpb25zLmFkZFJhbmRvbVN1ZmZpeCAhPT0gdm9pZCAwKSB7XG4gICAgaGVhZGVyc1twdXRPcHRpb25IZWFkZXJNYXAuYWRkUmFuZG9tU3VmZml4XSA9IG9wdGlvbnMuYWRkUmFuZG9tU3VmZml4ID8gXCIxXCIgOiBcIjBcIjtcbiAgfVxuICBpZiAoYWxsb3dlZE9wdGlvbnMuaW5jbHVkZXMoXCJhbGxvd092ZXJ3cml0ZVwiKSAmJiBvcHRpb25zLmFsbG93T3ZlcndyaXRlICE9PSB2b2lkIDApIHtcbiAgICBoZWFkZXJzW3B1dE9wdGlvbkhlYWRlck1hcC5hbGxvd092ZXJ3cml0ZV0gPSBvcHRpb25zLmFsbG93T3ZlcndyaXRlID8gXCIxXCIgOiBcIjBcIjtcbiAgfVxuICBpZiAoYWxsb3dlZE9wdGlvbnMuaW5jbHVkZXMoXCJjYWNoZUNvbnRyb2xNYXhBZ2VcIikgJiYgb3B0aW9ucy5jYWNoZUNvbnRyb2xNYXhBZ2UgIT09IHZvaWQgMCkge1xuICAgIGhlYWRlcnNbcHV0T3B0aW9uSGVhZGVyTWFwLmNhY2hlQ29udHJvbE1heEFnZV0gPSBvcHRpb25zLmNhY2hlQ29udHJvbE1heEFnZS50b1N0cmluZygpO1xuICB9XG4gIHJldHVybiBoZWFkZXJzO1xufVxuYXN5bmMgZnVuY3Rpb24gY3JlYXRlUHV0T3B0aW9ucyh7XG4gIHBhdGhuYW1lLFxuICBvcHRpb25zLFxuICBleHRyYUNoZWNrcyxcbiAgZ2V0VG9rZW5cbn0pIHtcbiAgaWYgKCFwYXRobmFtZSkge1xuICAgIHRocm93IG5ldyBCbG9iRXJyb3IoXCJwYXRobmFtZSBpcyByZXF1aXJlZFwiKTtcbiAgfVxuICBpZiAocGF0aG5hbWUubGVuZ3RoID4gTUFYSU1VTV9QQVRITkFNRV9MRU5HVEgpIHtcbiAgICB0aHJvdyBuZXcgQmxvYkVycm9yKFxuICAgICAgYHBhdGhuYW1lIGlzIHRvbyBsb25nLCBtYXhpbXVtIGxlbmd0aCBpcyAke01BWElNVU1fUEFUSE5BTUVfTEVOR1RIfWBcbiAgICApO1xuICB9XG4gIGZvciAoY29uc3QgaW52YWxpZENoYXJhY3RlciBvZiBkaXNhbGxvd2VkUGF0aG5hbWVDaGFyYWN0ZXJzKSB7XG4gICAgaWYgKHBhdGhuYW1lLmluY2x1ZGVzKGludmFsaWRDaGFyYWN0ZXIpKSB7XG4gICAgICB0aHJvdyBuZXcgQmxvYkVycm9yKFxuICAgICAgICBgcGF0aG5hbWUgY2Fubm90IGNvbnRhaW4gXCIke2ludmFsaWRDaGFyYWN0ZXJ9XCIsIHBsZWFzZSBlbmNvZGUgaXQgaWYgbmVlZGVkYFxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgaWYgKCFvcHRpb25zKSB7XG4gICAgdGhyb3cgbmV3IEJsb2JFcnJvcihcIm1pc3Npbmcgb3B0aW9ucywgc2VlIHVzYWdlXCIpO1xuICB9XG4gIGlmIChvcHRpb25zLmFjY2VzcyAhPT0gXCJwdWJsaWNcIikge1xuICAgIHRocm93IG5ldyBCbG9iRXJyb3IoJ2FjY2VzcyBtdXN0IGJlIFwicHVibGljXCInKTtcbiAgfVxuICBpZiAoZXh0cmFDaGVja3MpIHtcbiAgICBleHRyYUNoZWNrcyhvcHRpb25zKTtcbiAgfVxuICBpZiAoZ2V0VG9rZW4pIHtcbiAgICBvcHRpb25zLnRva2VuID0gYXdhaXQgZ2V0VG9rZW4ocGF0aG5hbWUsIG9wdGlvbnMpO1xuICB9XG4gIHJldHVybiBvcHRpb25zO1xufVxuXG4vLyBzcmMvbXVsdGlwYXJ0L2NvbXBsZXRlLnRzXG5mdW5jdGlvbiBjcmVhdGVDb21wbGV0ZU11bHRpcGFydFVwbG9hZE1ldGhvZCh7IGFsbG93ZWRPcHRpb25zLCBnZXRUb2tlbiwgZXh0cmFDaGVja3MgfSkge1xuICByZXR1cm4gYXN5bmMgKHBhdGhuYW1lLCBwYXJ0cywgb3B0aW9uc0lucHV0KSA9PiB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IGF3YWl0IGNyZWF0ZVB1dE9wdGlvbnMoe1xuICAgICAgcGF0aG5hbWUsXG4gICAgICBvcHRpb25zOiBvcHRpb25zSW5wdXQsXG4gICAgICBleHRyYUNoZWNrcyxcbiAgICAgIGdldFRva2VuXG4gICAgfSk7XG4gICAgY29uc3QgaGVhZGVycyA9IGNyZWF0ZVB1dEhlYWRlcnMoYWxsb3dlZE9wdGlvbnMsIG9wdGlvbnMpO1xuICAgIHJldHVybiBjb21wbGV0ZU11bHRpcGFydFVwbG9hZCh7XG4gICAgICB1cGxvYWRJZDogb3B0aW9ucy51cGxvYWRJZCxcbiAgICAgIGtleTogb3B0aW9ucy5rZXksXG4gICAgICBwYXRobmFtZSxcbiAgICAgIGhlYWRlcnMsXG4gICAgICBvcHRpb25zLFxuICAgICAgcGFydHNcbiAgICB9KTtcbiAgfTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGNvbXBsZXRlTXVsdGlwYXJ0VXBsb2FkKHtcbiAgdXBsb2FkSWQsXG4gIGtleSxcbiAgcGF0aG5hbWUsXG4gIHBhcnRzLFxuICBoZWFkZXJzLFxuICBvcHRpb25zXG59KSB7XG4gIGNvbnN0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoeyBwYXRobmFtZSB9KTtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHJlcXVlc3RBcGkoXG4gICAgICBgL21wdT8ke3BhcmFtcy50b1N0cmluZygpfWAsXG4gICAgICB7XG4gICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAuLi5oZWFkZXJzLFxuICAgICAgICAgIFwiY29udGVudC10eXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgIFwieC1tcHUtYWN0aW9uXCI6IFwiY29tcGxldGVcIixcbiAgICAgICAgICBcIngtbXB1LXVwbG9hZC1pZFwiOiB1cGxvYWRJZCxcbiAgICAgICAgICAvLyBrZXkgY2FuIGJlIGFueSB1dGY4IGNoYXJhY3RlciBzbyB3ZSBuZWVkIHRvIGVuY29kZSBpdCBhcyBIVFRQIGhlYWRlcnMgY2FuIG9ubHkgYmUgdXMtYXNjaWlcbiAgICAgICAgICAvLyBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjNzIzMCNzd2VjdGlvbi0zLjIuNFxuICAgICAgICAgIFwieC1tcHUta2V5XCI6IGVuY29kZVVSSUNvbXBvbmVudChrZXkpXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHBhcnRzKSxcbiAgICAgICAgc2lnbmFsOiBvcHRpb25zLmFib3J0U2lnbmFsXG4gICAgICB9LFxuICAgICAgb3B0aW9uc1xuICAgICk7XG4gICAgZGVidWcoXCJtcHU6IGNvbXBsZXRlXCIsIHJlc3BvbnNlKTtcbiAgICByZXR1cm4gcmVzcG9uc2U7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaWYgKGVycm9yIGluc3RhbmNlb2YgVHlwZUVycm9yICYmIChlcnJvci5tZXNzYWdlID09PSBcIkZhaWxlZCB0byBmZXRjaFwiIHx8IGVycm9yLm1lc3NhZ2UgPT09IFwiZmV0Y2ggZmFpbGVkXCIpKSB7XG4gICAgICB0aHJvdyBuZXcgQmxvYlNlcnZpY2VOb3RBdmFpbGFibGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG59XG5cbi8vIHNyYy9tdWx0aXBhcnQvY3JlYXRlLnRzXG5mdW5jdGlvbiBjcmVhdGVDcmVhdGVNdWx0aXBhcnRVcGxvYWRNZXRob2QoeyBhbGxvd2VkT3B0aW9ucywgZ2V0VG9rZW4sIGV4dHJhQ2hlY2tzIH0pIHtcbiAgcmV0dXJuIGFzeW5jIChwYXRobmFtZSwgb3B0aW9uc0lucHV0KSA9PiB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IGF3YWl0IGNyZWF0ZVB1dE9wdGlvbnMoe1xuICAgICAgcGF0aG5hbWUsXG4gICAgICBvcHRpb25zOiBvcHRpb25zSW5wdXQsXG4gICAgICBleHRyYUNoZWNrcyxcbiAgICAgIGdldFRva2VuXG4gICAgfSk7XG4gICAgY29uc3QgaGVhZGVycyA9IGNyZWF0ZVB1dEhlYWRlcnMoYWxsb3dlZE9wdGlvbnMsIG9wdGlvbnMpO1xuICAgIGNvbnN0IGNyZWF0ZU11bHRpcGFydFVwbG9hZFJlc3BvbnNlID0gYXdhaXQgY3JlYXRlTXVsdGlwYXJ0VXBsb2FkKFxuICAgICAgcGF0aG5hbWUsXG4gICAgICBoZWFkZXJzLFxuICAgICAgb3B0aW9uc1xuICAgICk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGtleTogY3JlYXRlTXVsdGlwYXJ0VXBsb2FkUmVzcG9uc2Uua2V5LFxuICAgICAgdXBsb2FkSWQ6IGNyZWF0ZU11bHRpcGFydFVwbG9hZFJlc3BvbnNlLnVwbG9hZElkXG4gICAgfTtcbiAgfTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGNyZWF0ZU11bHRpcGFydFVwbG9hZChwYXRobmFtZSwgaGVhZGVycywgb3B0aW9ucykge1xuICBkZWJ1ZyhcIm1wdTogY3JlYXRlXCIsIFwicGF0aG5hbWU6XCIsIHBhdGhuYW1lKTtcbiAgY29uc3QgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh7IHBhdGhuYW1lIH0pO1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcmVxdWVzdEFwaShcbiAgICAgIGAvbXB1PyR7cGFyYW1zLnRvU3RyaW5nKCl9YCxcbiAgICAgIHtcbiAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIC4uLmhlYWRlcnMsXG4gICAgICAgICAgXCJ4LW1wdS1hY3Rpb25cIjogXCJjcmVhdGVcIlxuICAgICAgICB9LFxuICAgICAgICBzaWduYWw6IG9wdGlvbnMuYWJvcnRTaWduYWxcbiAgICAgIH0sXG4gICAgICBvcHRpb25zXG4gICAgKTtcbiAgICBkZWJ1ZyhcIm1wdTogY3JlYXRlXCIsIHJlc3BvbnNlKTtcbiAgICByZXR1cm4gcmVzcG9uc2U7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaWYgKGVycm9yIGluc3RhbmNlb2YgVHlwZUVycm9yICYmIChlcnJvci5tZXNzYWdlID09PSBcIkZhaWxlZCB0byBmZXRjaFwiIHx8IGVycm9yLm1lc3NhZ2UgPT09IFwiZmV0Y2ggZmFpbGVkXCIpKSB7XG4gICAgICB0aHJvdyBuZXcgQmxvYlNlcnZpY2VOb3RBdmFpbGFibGUoKTtcbiAgICB9XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cblxuLy8gc3JjL211bHRpcGFydC91cGxvYWQudHNcbmltcG9ydCB0aHJvdHRsZSBmcm9tIFwidGhyb3R0bGVpdFwiO1xuZnVuY3Rpb24gY3JlYXRlVXBsb2FkUGFydE1ldGhvZCh7IGFsbG93ZWRPcHRpb25zLCBnZXRUb2tlbiwgZXh0cmFDaGVja3MgfSkge1xuICByZXR1cm4gYXN5bmMgKHBhdGhuYW1lLCBib2R5LCBvcHRpb25zSW5wdXQpID0+IHtcbiAgICBjb25zdCBvcHRpb25zID0gYXdhaXQgY3JlYXRlUHV0T3B0aW9ucyh7XG4gICAgICBwYXRobmFtZSxcbiAgICAgIG9wdGlvbnM6IG9wdGlvbnNJbnB1dCxcbiAgICAgIGV4dHJhQ2hlY2tzLFxuICAgICAgZ2V0VG9rZW5cbiAgICB9KTtcbiAgICBjb25zdCBoZWFkZXJzID0gY3JlYXRlUHV0SGVhZGVycyhhbGxvd2VkT3B0aW9ucywgb3B0aW9ucyk7XG4gICAgaWYgKGlzUGxhaW5PYmplY3QoYm9keSkpIHtcbiAgICAgIHRocm93IG5ldyBCbG9iRXJyb3IoXG4gICAgICAgIFwiQm9keSBtdXN0IGJlIGEgc3RyaW5nLCBidWZmZXIgb3Igc3RyZWFtLiBZb3Ugc2VudCBhIHBsYWluIEphdmFTY3JpcHQgb2JqZWN0LCBkb3VibGUgY2hlY2sgd2hhdCB5b3UncmUgdHJ5aW5nIHRvIHVwbG9hZC5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdXBsb2FkUGFydCh7XG4gICAgICB1cGxvYWRJZDogb3B0aW9ucy51cGxvYWRJZCxcbiAgICAgIGtleTogb3B0aW9ucy5rZXksXG4gICAgICBwYXRobmFtZSxcbiAgICAgIHBhcnQ6IHsgYmxvYjogYm9keSwgcGFydE51bWJlcjogb3B0aW9ucy5wYXJ0TnVtYmVyIH0sXG4gICAgICBoZWFkZXJzLFxuICAgICAgb3B0aW9uc1xuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICBldGFnOiByZXN1bHQuZXRhZyxcbiAgICAgIHBhcnROdW1iZXI6IG9wdGlvbnMucGFydE51bWJlclxuICAgIH07XG4gIH07XG59XG5hc3luYyBmdW5jdGlvbiB1cGxvYWRQYXJ0KHtcbiAgdXBsb2FkSWQsXG4gIGtleSxcbiAgcGF0aG5hbWUsXG4gIGhlYWRlcnMsXG4gIG9wdGlvbnMsXG4gIGludGVybmFsQWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpLFxuICBwYXJ0XG59KSB7XG4gIHZhciBfYTMsIF9iMiwgX2M7XG4gIGNvbnN0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoeyBwYXRobmFtZSB9KTtcbiAgY29uc3QgcmVzcG9uc2VQcm9taXNlID0gcmVxdWVzdEFwaShcbiAgICBgL21wdT8ke3BhcmFtcy50b1N0cmluZygpfWAsXG4gICAge1xuICAgICAgc2lnbmFsOiBpbnRlcm5hbEFib3J0Q29udHJvbGxlci5zaWduYWwsXG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICAuLi5oZWFkZXJzLFxuICAgICAgICBcIngtbXB1LWFjdGlvblwiOiBcInVwbG9hZFwiLFxuICAgICAgICBcIngtbXB1LWtleVwiOiBlbmNvZGVVUklDb21wb25lbnQoa2V5KSxcbiAgICAgICAgXCJ4LW1wdS11cGxvYWQtaWRcIjogdXBsb2FkSWQsXG4gICAgICAgIFwieC1tcHUtcGFydC1udW1iZXJcIjogcGFydC5wYXJ0TnVtYmVyLnRvU3RyaW5nKClcbiAgICAgIH0sXG4gICAgICAvLyB3ZWlyZCB0aGluZ3MgYmV0d2VlbiB1bmRpY2kgdHlwZXMgYW5kIG5hdGl2ZSBmZXRjaCB0eXBlc1xuICAgICAgYm9keTogcGFydC5ibG9iXG4gICAgfSxcbiAgICBvcHRpb25zXG4gICk7XG4gIGZ1bmN0aW9uIGhhbmRsZUFib3J0KCkge1xuICAgIGludGVybmFsQWJvcnRDb250cm9sbGVyLmFib3J0KCk7XG4gIH1cbiAgaWYgKChfYTMgPSBvcHRpb25zLmFib3J0U2lnbmFsKSA9PSBudWxsID8gdm9pZCAwIDogX2EzLmFib3J0ZWQpIHtcbiAgICBoYW5kbGVBYm9ydCgpO1xuICB9IGVsc2Uge1xuICAgIChfYjIgPSBvcHRpb25zLmFib3J0U2lnbmFsKSA9PSBudWxsID8gdm9pZCAwIDogX2IyLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBoYW5kbGVBYm9ydCk7XG4gIH1cbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCByZXNwb25zZVByb21pc2U7XG4gIChfYyA9IG9wdGlvbnMuYWJvcnRTaWduYWwpID09IG51bGwgPyB2b2lkIDAgOiBfYy5yZW1vdmVFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgaGFuZGxlQWJvcnQpO1xuICByZXR1cm4gcmVzcG9uc2U7XG59XG52YXIgbWF4Q29uY3VycmVudFVwbG9hZHMgPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gNiA6IDg7XG52YXIgcGFydFNpemVJbkJ5dGVzID0gOCAqIDEwMjQgKiAxMDI0O1xudmFyIG1heEJ5dGVzSW5NZW1vcnkgPSBtYXhDb25jdXJyZW50VXBsb2FkcyAqIHBhcnRTaXplSW5CeXRlcyAqIDI7XG5mdW5jdGlvbiB1cGxvYWRBbGxQYXJ0cyh7XG4gIHVwbG9hZElkLFxuICBrZXksXG4gIHBhdGhuYW1lLFxuICBzdHJlYW0sXG4gIGhlYWRlcnMsXG4gIG9wdGlvbnMsXG4gIHRvdGFsVG9Mb2FkXG59KSB7XG4gIGRlYnVnKFwibXB1OiB1cGxvYWQgaW5pdFwiLCBcImtleTpcIiwga2V5KTtcbiAgY29uc3QgaW50ZXJuYWxBYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgY29uc3QgcGFydHNUb1VwbG9hZCA9IFtdO1xuICAgIGNvbnN0IGNvbXBsZXRlZFBhcnRzID0gW107XG4gICAgY29uc3QgcmVhZGVyID0gc3RyZWFtLmdldFJlYWRlcigpO1xuICAgIGxldCBhY3RpdmVVcGxvYWRzID0gMDtcbiAgICBsZXQgcmVhZGluZyA9IGZhbHNlO1xuICAgIGxldCBjdXJyZW50UGFydE51bWJlciA9IDE7XG4gICAgbGV0IHJlamVjdGVkID0gZmFsc2U7XG4gICAgbGV0IGN1cnJlbnRCeXRlc0luTWVtb3J5ID0gMDtcbiAgICBsZXQgZG9uZVJlYWRpbmcgPSBmYWxzZTtcbiAgICBsZXQgYnl0ZXNTZW50ID0gMDtcbiAgICBsZXQgYXJyYXlCdWZmZXJzID0gW107XG4gICAgbGV0IGN1cnJlbnRQYXJ0Qnl0ZXNSZWFkID0gMDtcbiAgICBsZXQgb25VcGxvYWRQcm9ncmVzcztcbiAgICBjb25zdCB0b3RhbExvYWRlZFBlclBhcnROdW1iZXIgPSB7fTtcbiAgICBpZiAob3B0aW9ucy5vblVwbG9hZFByb2dyZXNzKSB7XG4gICAgICBvblVwbG9hZFByb2dyZXNzID0gdGhyb3R0bGUoKCkgPT4ge1xuICAgICAgICB2YXIgX2EzO1xuICAgICAgICBjb25zdCBsb2FkZWQgPSBPYmplY3QudmFsdWVzKHRvdGFsTG9hZGVkUGVyUGFydE51bWJlcikucmVkdWNlKFxuICAgICAgICAgIChhY2MsIGN1cikgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGFjYyArIGN1cjtcbiAgICAgICAgICB9LFxuICAgICAgICAgIDBcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgdG90YWwgPSB0b3RhbFRvTG9hZCB8fCBsb2FkZWQ7XG4gICAgICAgIGNvbnN0IHBlcmNlbnRhZ2UgPSB0b3RhbFRvTG9hZCA+IDAgPyBOdW1iZXIoKChsb2FkZWQgLyB0b3RhbFRvTG9hZCB8fCBsb2FkZWQpICogMTAwKS50b0ZpeGVkKDIpKSA6IDA7XG4gICAgICAgIChfYTMgPSBvcHRpb25zLm9uVXBsb2FkUHJvZ3Jlc3MpID09IG51bGwgPyB2b2lkIDAgOiBfYTMuY2FsbChvcHRpb25zLCB7IGxvYWRlZCwgdG90YWwsIHBlcmNlbnRhZ2UgfSk7XG4gICAgICB9LCAxNTApO1xuICAgIH1cbiAgICByZWFkKCkuY2F0Y2goY2FuY2VsKTtcbiAgICBhc3luYyBmdW5jdGlvbiByZWFkKCkge1xuICAgICAgZGVidWcoXG4gICAgICAgIFwibXB1OiB1cGxvYWQgcmVhZCBzdGFydFwiLFxuICAgICAgICBcImFjdGl2ZVVwbG9hZHM6XCIsXG4gICAgICAgIGFjdGl2ZVVwbG9hZHMsXG4gICAgICAgIFwiY3VycmVudEJ5dGVzSW5NZW1vcnk6XCIsXG4gICAgICAgIGAke2J5dGVzKGN1cnJlbnRCeXRlc0luTWVtb3J5KX0vJHtieXRlcyhtYXhCeXRlc0luTWVtb3J5KX1gLFxuICAgICAgICBcImJ5dGVzU2VudDpcIixcbiAgICAgICAgYnl0ZXMoYnl0ZXNTZW50KVxuICAgICAgKTtcbiAgICAgIHJlYWRpbmcgPSB0cnVlO1xuICAgICAgd2hpbGUgKGN1cnJlbnRCeXRlc0luTWVtb3J5IDwgbWF4Qnl0ZXNJbk1lbW9yeSAmJiAhcmVqZWN0ZWQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCB7IHZhbHVlLCBkb25lIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICBkb25lUmVhZGluZyA9IHRydWU7XG4gICAgICAgICAgICBkZWJ1ZyhcIm1wdTogdXBsb2FkIHJlYWQgY29uc3VtZWQgdGhlIHdob2xlIHN0cmVhbVwiKTtcbiAgICAgICAgICAgIGlmIChhcnJheUJ1ZmZlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICBwYXJ0c1RvVXBsb2FkLnB1c2goe1xuICAgICAgICAgICAgICAgIHBhcnROdW1iZXI6IGN1cnJlbnRQYXJ0TnVtYmVyKyssXG4gICAgICAgICAgICAgICAgYmxvYjogbmV3IEJsb2IoYXJyYXlCdWZmZXJzLCB7XG4gICAgICAgICAgICAgICAgICB0eXBlOiBcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwiXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHNlbmRQYXJ0cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVhZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjdXJyZW50Qnl0ZXNJbk1lbW9yeSArPSB2YWx1ZS5ieXRlTGVuZ3RoO1xuICAgICAgICAgIGxldCB2YWx1ZU9mZnNldCA9IDA7XG4gICAgICAgICAgd2hpbGUgKHZhbHVlT2Zmc2V0IDwgdmFsdWUuYnl0ZUxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3QgcmVtYWluaW5nUGFydFNpemUgPSBwYXJ0U2l6ZUluQnl0ZXMgLSBjdXJyZW50UGFydEJ5dGVzUmVhZDtcbiAgICAgICAgICAgIGNvbnN0IGVuZE9mZnNldCA9IE1hdGgubWluKFxuICAgICAgICAgICAgICB2YWx1ZU9mZnNldCArIHJlbWFpbmluZ1BhcnRTaXplLFxuICAgICAgICAgICAgICB2YWx1ZS5ieXRlTGVuZ3RoXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgY29uc3QgY2h1bmsgPSB2YWx1ZS5zbGljZSh2YWx1ZU9mZnNldCwgZW5kT2Zmc2V0KTtcbiAgICAgICAgICAgIGFycmF5QnVmZmVycy5wdXNoKGNodW5rKTtcbiAgICAgICAgICAgIGN1cnJlbnRQYXJ0Qnl0ZXNSZWFkICs9IGNodW5rLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgICB2YWx1ZU9mZnNldCA9IGVuZE9mZnNldDtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UGFydEJ5dGVzUmVhZCA9PT0gcGFydFNpemVJbkJ5dGVzKSB7XG4gICAgICAgICAgICAgIHBhcnRzVG9VcGxvYWQucHVzaCh7XG4gICAgICAgICAgICAgICAgcGFydE51bWJlcjogY3VycmVudFBhcnROdW1iZXIrKyxcbiAgICAgICAgICAgICAgICBibG9iOiBuZXcgQmxvYihhcnJheUJ1ZmZlcnMsIHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6IFwiYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtXCJcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgYXJyYXlCdWZmZXJzID0gW107XG4gICAgICAgICAgICAgIGN1cnJlbnRQYXJ0Qnl0ZXNSZWFkID0gMDtcbiAgICAgICAgICAgICAgc2VuZFBhcnRzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGNhbmNlbChlcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGRlYnVnKFxuICAgICAgICBcIm1wdTogdXBsb2FkIHJlYWQgZW5kXCIsXG4gICAgICAgIFwiYWN0aXZlVXBsb2FkczpcIixcbiAgICAgICAgYWN0aXZlVXBsb2FkcyxcbiAgICAgICAgXCJjdXJyZW50Qnl0ZXNJbk1lbW9yeTpcIixcbiAgICAgICAgYCR7Ynl0ZXMoY3VycmVudEJ5dGVzSW5NZW1vcnkpfS8ke2J5dGVzKG1heEJ5dGVzSW5NZW1vcnkpfWAsXG4gICAgICAgIFwiYnl0ZXNTZW50OlwiLFxuICAgICAgICBieXRlcyhieXRlc1NlbnQpXG4gICAgICApO1xuICAgICAgcmVhZGluZyA9IGZhbHNlO1xuICAgIH1cbiAgICBhc3luYyBmdW5jdGlvbiBzZW5kUGFydChwYXJ0KSB7XG4gICAgICBhY3RpdmVVcGxvYWRzKys7XG4gICAgICBkZWJ1ZyhcbiAgICAgICAgXCJtcHU6IHVwbG9hZCBzZW5kIHBhcnQgc3RhcnRcIixcbiAgICAgICAgXCJwYXJ0TnVtYmVyOlwiLFxuICAgICAgICBwYXJ0LnBhcnROdW1iZXIsXG4gICAgICAgIFwic2l6ZTpcIixcbiAgICAgICAgcGFydC5ibG9iLnNpemUsXG4gICAgICAgIFwiYWN0aXZlVXBsb2FkczpcIixcbiAgICAgICAgYWN0aXZlVXBsb2FkcyxcbiAgICAgICAgXCJjdXJyZW50Qnl0ZXNJbk1lbW9yeTpcIixcbiAgICAgICAgYCR7Ynl0ZXMoY3VycmVudEJ5dGVzSW5NZW1vcnkpfS8ke2J5dGVzKG1heEJ5dGVzSW5NZW1vcnkpfWAsXG4gICAgICAgIFwiYnl0ZXNTZW50OlwiLFxuICAgICAgICBieXRlcyhieXRlc1NlbnQpXG4gICAgICApO1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgdXBsb2FkUHJvZ3Jlc3NGb3JQYXJ0ID0gb3B0aW9ucy5vblVwbG9hZFByb2dyZXNzID8gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgdG90YWxMb2FkZWRQZXJQYXJ0TnVtYmVyW3BhcnQucGFydE51bWJlcl0gPSBldmVudC5sb2FkZWQ7XG4gICAgICAgICAgaWYgKG9uVXBsb2FkUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgIG9uVXBsb2FkUHJvZ3Jlc3MoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gOiB2b2lkIDA7XG4gICAgICAgIGNvbnN0IGNvbXBsZXRlZFBhcnQgPSBhd2FpdCB1cGxvYWRQYXJ0KHtcbiAgICAgICAgICB1cGxvYWRJZCxcbiAgICAgICAgICBrZXksXG4gICAgICAgICAgcGF0aG5hbWUsXG4gICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgb25VcGxvYWRQcm9ncmVzczogdXBsb2FkUHJvZ3Jlc3NGb3JQYXJ0XG4gICAgICAgICAgfSxcbiAgICAgICAgICBpbnRlcm5hbEFib3J0Q29udHJvbGxlcixcbiAgICAgICAgICBwYXJ0XG4gICAgICAgIH0pO1xuICAgICAgICBkZWJ1ZyhcbiAgICAgICAgICBcIm1wdTogdXBsb2FkIHNlbmQgcGFydCBlbmRcIixcbiAgICAgICAgICBcInBhcnROdW1iZXI6XCIsXG4gICAgICAgICAgcGFydC5wYXJ0TnVtYmVyLFxuICAgICAgICAgIFwiYWN0aXZlVXBsb2Fkc1wiLFxuICAgICAgICAgIGFjdGl2ZVVwbG9hZHMsXG4gICAgICAgICAgXCJjdXJyZW50Qnl0ZXNJbk1lbW9yeTpcIixcbiAgICAgICAgICBgJHtieXRlcyhjdXJyZW50Qnl0ZXNJbk1lbW9yeSl9LyR7Ynl0ZXMobWF4Qnl0ZXNJbk1lbW9yeSl9YCxcbiAgICAgICAgICBcImJ5dGVzU2VudDpcIixcbiAgICAgICAgICBieXRlcyhieXRlc1NlbnQpXG4gICAgICAgICk7XG4gICAgICAgIGlmIChyZWplY3RlZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb21wbGV0ZWRQYXJ0cy5wdXNoKHtcbiAgICAgICAgICBwYXJ0TnVtYmVyOiBwYXJ0LnBhcnROdW1iZXIsXG4gICAgICAgICAgZXRhZzogY29tcGxldGVkUGFydC5ldGFnXG4gICAgICAgIH0pO1xuICAgICAgICBjdXJyZW50Qnl0ZXNJbk1lbW9yeSAtPSBwYXJ0LmJsb2Iuc2l6ZTtcbiAgICAgICAgYWN0aXZlVXBsb2Fkcy0tO1xuICAgICAgICBieXRlc1NlbnQgKz0gcGFydC5ibG9iLnNpemU7XG4gICAgICAgIGlmIChwYXJ0c1RvVXBsb2FkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBzZW5kUGFydHMoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZG9uZVJlYWRpbmcpIHtcbiAgICAgICAgICBpZiAoYWN0aXZlVXBsb2FkcyA9PT0gMCkge1xuICAgICAgICAgICAgcmVhZGVyLnJlbGVhc2VMb2NrKCk7XG4gICAgICAgICAgICByZXNvbHZlKGNvbXBsZXRlZFBhcnRzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcmVhZGluZykge1xuICAgICAgICAgIHJlYWQoKS5jYXRjaChjYW5jZWwpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjYW5jZWwoZXJyb3IpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBzZW5kUGFydHMoKSB7XG4gICAgICBpZiAocmVqZWN0ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZGVidWcoXG4gICAgICAgIFwic2VuZCBwYXJ0c1wiLFxuICAgICAgICBcImFjdGl2ZVVwbG9hZHNcIixcbiAgICAgICAgYWN0aXZlVXBsb2FkcyxcbiAgICAgICAgXCJwYXJ0c1RvVXBsb2FkXCIsXG4gICAgICAgIHBhcnRzVG9VcGxvYWQubGVuZ3RoXG4gICAgICApO1xuICAgICAgd2hpbGUgKGFjdGl2ZVVwbG9hZHMgPCBtYXhDb25jdXJyZW50VXBsb2FkcyAmJiBwYXJ0c1RvVXBsb2FkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3QgcGFydFRvU2VuZCA9IHBhcnRzVG9VcGxvYWQuc2hpZnQoKTtcbiAgICAgICAgaWYgKHBhcnRUb1NlbmQpIHtcbiAgICAgICAgICB2b2lkIHNlbmRQYXJ0KHBhcnRUb1NlbmQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNhbmNlbChlcnJvcikge1xuICAgICAgaWYgKHJlamVjdGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHJlamVjdGVkID0gdHJ1ZTtcbiAgICAgIGludGVybmFsQWJvcnRDb250cm9sbGVyLmFib3J0KCk7XG4gICAgICByZWFkZXIucmVsZWFzZUxvY2soKTtcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIFR5cGVFcnJvciAmJiAoZXJyb3IubWVzc2FnZSA9PT0gXCJGYWlsZWQgdG8gZmV0Y2hcIiB8fCBlcnJvci5tZXNzYWdlID09PSBcImZldGNoIGZhaWxlZFwiKSkge1xuICAgICAgICByZWplY3QobmV3IEJsb2JTZXJ2aWNlTm90QXZhaWxhYmxlKCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuXG4vLyBzcmMvbXVsdGlwYXJ0L2NyZWF0ZS11cGxvYWRlci50c1xuZnVuY3Rpb24gY3JlYXRlQ3JlYXRlTXVsdGlwYXJ0VXBsb2FkZXJNZXRob2QoeyBhbGxvd2VkT3B0aW9ucywgZ2V0VG9rZW4sIGV4dHJhQ2hlY2tzIH0pIHtcbiAgcmV0dXJuIGFzeW5jIChwYXRobmFtZSwgb3B0aW9uc0lucHV0KSA9PiB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IGF3YWl0IGNyZWF0ZVB1dE9wdGlvbnMoe1xuICAgICAgcGF0aG5hbWUsXG4gICAgICBvcHRpb25zOiBvcHRpb25zSW5wdXQsXG4gICAgICBleHRyYUNoZWNrcyxcbiAgICAgIGdldFRva2VuXG4gICAgfSk7XG4gICAgY29uc3QgaGVhZGVycyA9IGNyZWF0ZVB1dEhlYWRlcnMoYWxsb3dlZE9wdGlvbnMsIG9wdGlvbnMpO1xuICAgIGNvbnN0IGNyZWF0ZU11bHRpcGFydFVwbG9hZFJlc3BvbnNlID0gYXdhaXQgY3JlYXRlTXVsdGlwYXJ0VXBsb2FkKFxuICAgICAgcGF0aG5hbWUsXG4gICAgICBoZWFkZXJzLFxuICAgICAgb3B0aW9uc1xuICAgICk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGtleTogY3JlYXRlTXVsdGlwYXJ0VXBsb2FkUmVzcG9uc2Uua2V5LFxuICAgICAgdXBsb2FkSWQ6IGNyZWF0ZU11bHRpcGFydFVwbG9hZFJlc3BvbnNlLnVwbG9hZElkLFxuICAgICAgYXN5bmMgdXBsb2FkUGFydChwYXJ0TnVtYmVyLCBib2R5KSB7XG4gICAgICAgIGlmIChpc1BsYWluT2JqZWN0KGJvZHkpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEJsb2JFcnJvcihcbiAgICAgICAgICAgIFwiQm9keSBtdXN0IGJlIGEgc3RyaW5nLCBidWZmZXIgb3Igc3RyZWFtLiBZb3Ugc2VudCBhIHBsYWluIEphdmFTY3JpcHQgb2JqZWN0LCBkb3VibGUgY2hlY2sgd2hhdCB5b3UncmUgdHJ5aW5nIHRvIHVwbG9hZC5cIlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdXBsb2FkUGFydCh7XG4gICAgICAgICAgdXBsb2FkSWQ6IGNyZWF0ZU11bHRpcGFydFVwbG9hZFJlc3BvbnNlLnVwbG9hZElkLFxuICAgICAgICAgIGtleTogY3JlYXRlTXVsdGlwYXJ0VXBsb2FkUmVzcG9uc2Uua2V5LFxuICAgICAgICAgIHBhdGhuYW1lLFxuICAgICAgICAgIHBhcnQ6IHsgcGFydE51bWJlciwgYmxvYjogYm9keSB9LFxuICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgb3B0aW9uc1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBldGFnOiByZXN1bHQuZXRhZyxcbiAgICAgICAgICBwYXJ0TnVtYmVyXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgYXN5bmMgY29tcGxldGUocGFydHMpIHtcbiAgICAgICAgcmV0dXJuIGNvbXBsZXRlTXVsdGlwYXJ0VXBsb2FkKHtcbiAgICAgICAgICB1cGxvYWRJZDogY3JlYXRlTXVsdGlwYXJ0VXBsb2FkUmVzcG9uc2UudXBsb2FkSWQsXG4gICAgICAgICAga2V5OiBjcmVhdGVNdWx0aXBhcnRVcGxvYWRSZXNwb25zZS5rZXksXG4gICAgICAgICAgcGF0aG5hbWUsXG4gICAgICAgICAgcGFydHMsXG4gICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICBvcHRpb25zXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gIH07XG59XG5cbi8vIHNyYy9wdXQudHNcbmltcG9ydCB0aHJvdHRsZTIgZnJvbSBcInRocm90dGxlaXRcIjtcblxuLy8gc3JjL211bHRpcGFydC91bmNvbnRyb2xsZWQudHNcbmFzeW5jIGZ1bmN0aW9uIHVuY29udHJvbGxlZE11bHRpcGFydFVwbG9hZChwYXRobmFtZSwgYm9keSwgaGVhZGVycywgb3B0aW9ucykge1xuICBkZWJ1ZyhcIm1wdTogaW5pdFwiLCBcInBhdGhuYW1lOlwiLCBwYXRobmFtZSwgXCJoZWFkZXJzOlwiLCBoZWFkZXJzKTtcbiAgY29uc3Qgb3B0aW9uc1dpdGhvdXRPblVwbG9hZFByb2dyZXNzID0ge1xuICAgIC4uLm9wdGlvbnMsXG4gICAgb25VcGxvYWRQcm9ncmVzczogdm9pZCAwXG4gIH07XG4gIGNvbnN0IGNyZWF0ZU11bHRpcGFydFVwbG9hZFJlc3BvbnNlID0gYXdhaXQgY3JlYXRlTXVsdGlwYXJ0VXBsb2FkKFxuICAgIHBhdGhuYW1lLFxuICAgIGhlYWRlcnMsXG4gICAgb3B0aW9uc1dpdGhvdXRPblVwbG9hZFByb2dyZXNzXG4gICk7XG4gIGNvbnN0IHRvdGFsVG9Mb2FkID0gY29tcHV0ZUJvZHlMZW5ndGgoYm9keSk7XG4gIGNvbnN0IHN0cmVhbSA9IGF3YWl0IHRvUmVhZGFibGVTdHJlYW0oYm9keSk7XG4gIGNvbnN0IHBhcnRzID0gYXdhaXQgdXBsb2FkQWxsUGFydHMoe1xuICAgIHVwbG9hZElkOiBjcmVhdGVNdWx0aXBhcnRVcGxvYWRSZXNwb25zZS51cGxvYWRJZCxcbiAgICBrZXk6IGNyZWF0ZU11bHRpcGFydFVwbG9hZFJlc3BvbnNlLmtleSxcbiAgICBwYXRobmFtZSxcbiAgICBzdHJlYW0sXG4gICAgaGVhZGVycyxcbiAgICBvcHRpb25zLFxuICAgIHRvdGFsVG9Mb2FkXG4gIH0pO1xuICBjb25zdCBibG9iID0gYXdhaXQgY29tcGxldGVNdWx0aXBhcnRVcGxvYWQoe1xuICAgIHVwbG9hZElkOiBjcmVhdGVNdWx0aXBhcnRVcGxvYWRSZXNwb25zZS51cGxvYWRJZCxcbiAgICBrZXk6IGNyZWF0ZU11bHRpcGFydFVwbG9hZFJlc3BvbnNlLmtleSxcbiAgICBwYXRobmFtZSxcbiAgICBwYXJ0cyxcbiAgICBoZWFkZXJzLFxuICAgIG9wdGlvbnM6IG9wdGlvbnNXaXRob3V0T25VcGxvYWRQcm9ncmVzc1xuICB9KTtcbiAgcmV0dXJuIGJsb2I7XG59XG5cbi8vIHNyYy9wdXQudHNcbmZ1bmN0aW9uIGNyZWF0ZVB1dE1ldGhvZCh7XG4gIGFsbG93ZWRPcHRpb25zLFxuICBnZXRUb2tlbixcbiAgZXh0cmFDaGVja3Ncbn0pIHtcbiAgcmV0dXJuIGFzeW5jIGZ1bmN0aW9uIHB1dChwYXRobmFtZSwgYm9keSwgb3B0aW9uc0lucHV0KSB7XG4gICAgaWYgKCFib2R5KSB7XG4gICAgICB0aHJvdyBuZXcgQmxvYkVycm9yKFwiYm9keSBpcyByZXF1aXJlZFwiKTtcbiAgICB9XG4gICAgaWYgKGlzUGxhaW5PYmplY3QoYm9keSkpIHtcbiAgICAgIHRocm93IG5ldyBCbG9iRXJyb3IoXG4gICAgICAgIFwiQm9keSBtdXN0IGJlIGEgc3RyaW5nLCBidWZmZXIgb3Igc3RyZWFtLiBZb3Ugc2VudCBhIHBsYWluIEphdmFTY3JpcHQgb2JqZWN0LCBkb3VibGUgY2hlY2sgd2hhdCB5b3UncmUgdHJ5aW5nIHRvIHVwbG9hZC5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3Qgb3B0aW9ucyA9IGF3YWl0IGNyZWF0ZVB1dE9wdGlvbnMoe1xuICAgICAgcGF0aG5hbWUsXG4gICAgICBvcHRpb25zOiBvcHRpb25zSW5wdXQsXG4gICAgICBleHRyYUNoZWNrcyxcbiAgICAgIGdldFRva2VuXG4gICAgfSk7XG4gICAgY29uc3QgaGVhZGVycyA9IGNyZWF0ZVB1dEhlYWRlcnMoYWxsb3dlZE9wdGlvbnMsIG9wdGlvbnMpO1xuICAgIGlmIChvcHRpb25zLm11bHRpcGFydCA9PT0gdHJ1ZSkge1xuICAgICAgcmV0dXJuIHVuY29udHJvbGxlZE11bHRpcGFydFVwbG9hZChwYXRobmFtZSwgYm9keSwgaGVhZGVycywgb3B0aW9ucyk7XG4gICAgfVxuICAgIGNvbnN0IG9uVXBsb2FkUHJvZ3Jlc3MgPSBvcHRpb25zLm9uVXBsb2FkUHJvZ3Jlc3MgPyB0aHJvdHRsZTIob3B0aW9ucy5vblVwbG9hZFByb2dyZXNzLCAxMDApIDogdm9pZCAwO1xuICAgIGNvbnN0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoeyBwYXRobmFtZSB9KTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHJlcXVlc3RBcGkoXG4gICAgICBgLz8ke3BhcmFtcy50b1N0cmluZygpfWAsXG4gICAgICB7XG4gICAgICAgIG1ldGhvZDogXCJQVVRcIixcbiAgICAgICAgYm9keSxcbiAgICAgICAgaGVhZGVycyxcbiAgICAgICAgc2lnbmFsOiBvcHRpb25zLmFib3J0U2lnbmFsXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICBvblVwbG9hZFByb2dyZXNzXG4gICAgICB9XG4gICAgKTtcbiAgICByZXR1cm4ge1xuICAgICAgdXJsOiByZXNwb25zZS51cmwsXG4gICAgICBkb3dubG9hZFVybDogcmVzcG9uc2UuZG93bmxvYWRVcmwsXG4gICAgICBwYXRobmFtZTogcmVzcG9uc2UucGF0aG5hbWUsXG4gICAgICBjb250ZW50VHlwZTogcmVzcG9uc2UuY29udGVudFR5cGUsXG4gICAgICBjb250ZW50RGlzcG9zaXRpb246IHJlc3BvbnNlLmNvbnRlbnREaXNwb3NpdGlvblxuICAgIH07XG4gIH07XG59XG5cbi8vIHNyYy9jcmVhdGUtZm9sZGVyLnRzXG5hc3luYyBmdW5jdGlvbiBjcmVhdGVGb2xkZXIocGF0aG5hbWUsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCBmb2xkZXJQYXRobmFtZSA9IHBhdGhuYW1lLmVuZHNXaXRoKFwiL1wiKSA/IHBhdGhuYW1lIDogYCR7cGF0aG5hbWV9L2A7XG4gIGNvbnN0IGhlYWRlcnMgPSB7fTtcbiAgaGVhZGVyc1twdXRPcHRpb25IZWFkZXJNYXAuYWRkUmFuZG9tU3VmZml4XSA9IFwiMFwiO1xuICBjb25zdCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHsgcGF0aG5hbWU6IGZvbGRlclBhdGhuYW1lIH0pO1xuICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHJlcXVlc3RBcGkoXG4gICAgYC8/JHtwYXJhbXMudG9TdHJpbmcoKX1gLFxuICAgIHtcbiAgICAgIG1ldGhvZDogXCJQVVRcIixcbiAgICAgIGhlYWRlcnMsXG4gICAgICBzaWduYWw6IG9wdGlvbnMuYWJvcnRTaWduYWxcbiAgICB9LFxuICAgIG9wdGlvbnNcbiAgKTtcbiAgcmV0dXJuIHtcbiAgICB1cmw6IHJlc3BvbnNlLnVybCxcbiAgICBwYXRobmFtZTogcmVzcG9uc2UucGF0aG5hbWVcbiAgfTtcbn1cblxuZXhwb3J0IHtcbiAgZ2V0VG9rZW5Gcm9tT3B0aW9uc09yRW52LFxuICBCbG9iRXJyb3IsXG4gIGdldERvd25sb2FkVXJsLFxuICBkaXNhbGxvd2VkUGF0aG5hbWVDaGFyYWN0ZXJzLFxuICBNQVhJTVVNX1BBVEhOQU1FX0xFTkdUSCxcbiAgQmxvYkFjY2Vzc0Vycm9yLFxuICBCbG9iQ29udGVudFR5cGVOb3RBbGxvd2VkRXJyb3IsXG4gIEJsb2JQYXRobmFtZU1pc21hdGNoRXJyb3IsXG4gIEJsb2JDbGllbnRUb2tlbkV4cGlyZWRFcnJvcixcbiAgQmxvYkZpbGVUb29MYXJnZUVycm9yLFxuICBCbG9iU3RvcmVOb3RGb3VuZEVycm9yLFxuICBCbG9iU3RvcmVTdXNwZW5kZWRFcnJvcixcbiAgQmxvYlVua25vd25FcnJvcixcbiAgQmxvYk5vdEZvdW5kRXJyb3IsXG4gIEJsb2JTZXJ2aWNlTm90QXZhaWxhYmxlLFxuICBCbG9iU2VydmljZVJhdGVMaW1pdGVkLFxuICBCbG9iUmVxdWVzdEFib3J0ZWRFcnJvcixcbiAgcmVxdWVzdEFwaSxcbiAgY3JlYXRlQ29tcGxldGVNdWx0aXBhcnRVcGxvYWRNZXRob2QsXG4gIGNyZWF0ZUNyZWF0ZU11bHRpcGFydFVwbG9hZE1ldGhvZCxcbiAgY3JlYXRlVXBsb2FkUGFydE1ldGhvZCxcbiAgY3JlYXRlQ3JlYXRlTXVsdGlwYXJ0VXBsb2FkZXJNZXRob2QsXG4gIGNyZWF0ZVB1dE1ldGhvZCxcbiAgY3JlYXRlRm9sZGVyXG59O1xuLyohXG4gKiBieXRlc1xuICogQ29weXJpZ2h0KGMpIDIwMTItMjAxNCBUSiBIb2xvd2F5Y2h1a1xuICogQ29weXJpZ2h0KGMpIDIwMTUgSmVkIFdhdHNvblxuICogTUlUIExpY2Vuc2VkXG4gKi9cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNodW5rLUZONlhGSDZSLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@vercel/blob/dist/chunk-FN6XFH6R.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@vercel/blob/dist/client.js":
/*!**************************************************!*\
  !*** ./node_modules/@vercel/blob/dist/client.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   completeMultipartUpload: () => (/* binding */ completeMultipartUpload),\n/* harmony export */   createFolder: () => (/* reexport safe */ _chunk_FN6XFH6R_js__WEBPACK_IMPORTED_MODULE_2__.createFolder),\n/* harmony export */   createMultipartUpload: () => (/* binding */ createMultipartUpload),\n/* harmony export */   createMultipartUploader: () => (/* binding */ createMultipartUploader),\n/* harmony export */   generateClientTokenFromReadWriteToken: () => (/* binding */ generateClientTokenFromReadWriteToken),\n/* harmony export */   getPayloadFromClientToken: () => (/* binding */ getPayloadFromClientToken),\n/* harmony export */   handleUpload: () => (/* binding */ handleUpload),\n/* harmony export */   put: () => (/* binding */ put),\n/* harmony export */   upload: () => (/* binding */ upload),\n/* harmony export */   uploadPart: () => (/* binding */ uploadPart)\n/* harmony export */ });\n/* harmony import */ var _chunk_FN6XFH6R_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./chunk-FN6XFH6R.js */ \"(ssr)/./node_modules/@vercel/blob/dist/chunk-FN6XFH6R.js\");\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! crypto */ \"crypto\");\n/* harmony import */ var undici__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! undici */ \"(ssr)/./node_modules/undici/index.js\");\n\n\n// src/client.ts\n\n\nfunction createPutExtraChecks(methodName) {\n  return function extraChecks(options) {\n    if (!options.token.startsWith(\"vercel_blob_client_\")) {\n      throw new _chunk_FN6XFH6R_js__WEBPACK_IMPORTED_MODULE_2__.BlobError(`${methodName} must be called with a client token`);\n    }\n    if (\n      // @ts-expect-error -- Runtime check for DX.\n      options.addRandomSuffix !== void 0 || // @ts-expect-error -- Runtime check for DX.\n      options.allowOverwrite !== void 0 || // @ts-expect-error -- Runtime check for DX.\n      options.cacheControlMaxAge !== void 0\n    ) {\n      throw new _chunk_FN6XFH6R_js__WEBPACK_IMPORTED_MODULE_2__.BlobError(\n        `${methodName} doesn't allow \\`addRandomSuffix\\`, \\`cacheControlMaxAge\\` or \\`allowOverwrite\\`. Configure these options at the server side when generating client tokens.`\n      );\n    }\n  };\n}\nvar put = (0,_chunk_FN6XFH6R_js__WEBPACK_IMPORTED_MODULE_2__.createPutMethod)({\n  allowedOptions: [\"contentType\"],\n  extraChecks: createPutExtraChecks(\"client/`put`\")\n});\nvar createMultipartUpload = (0,_chunk_FN6XFH6R_js__WEBPACK_IMPORTED_MODULE_2__.createCreateMultipartUploadMethod)({\n  allowedOptions: [\"contentType\"],\n  extraChecks: createPutExtraChecks(\"client/`createMultipartUpload`\")\n});\nvar createMultipartUploader = (0,_chunk_FN6XFH6R_js__WEBPACK_IMPORTED_MODULE_2__.createCreateMultipartUploaderMethod)(\n  {\n    allowedOptions: [\"contentType\"],\n    extraChecks: createPutExtraChecks(\"client/`createMultipartUpload`\")\n  }\n);\nvar uploadPart = (0,_chunk_FN6XFH6R_js__WEBPACK_IMPORTED_MODULE_2__.createUploadPartMethod)({\n  allowedOptions: [\"contentType\"],\n  extraChecks: createPutExtraChecks(\"client/`multipartUpload`\")\n});\nvar completeMultipartUpload = (0,_chunk_FN6XFH6R_js__WEBPACK_IMPORTED_MODULE_2__.createCompleteMultipartUploadMethod)(\n  {\n    allowedOptions: [\"contentType\"],\n    extraChecks: createPutExtraChecks(\"client/`completeMultipartUpload`\")\n  }\n);\nvar upload = (0,_chunk_FN6XFH6R_js__WEBPACK_IMPORTED_MODULE_2__.createPutMethod)({\n  allowedOptions: [\"contentType\"],\n  extraChecks(options) {\n    if (options.handleUploadUrl === void 0) {\n      throw new _chunk_FN6XFH6R_js__WEBPACK_IMPORTED_MODULE_2__.BlobError(\n        \"client/`upload` requires the 'handleUploadUrl' parameter\"\n      );\n    }\n    if (\n      // @ts-expect-error -- Runtime check for DX.\n      options.addRandomSuffix !== void 0 || // @ts-expect-error -- Runtime check for DX.\n      options.createPutExtraChecks !== void 0 || // @ts-expect-error -- Runtime check for DX.\n      options.cacheControlMaxAge !== void 0\n    ) {\n      throw new _chunk_FN6XFH6R_js__WEBPACK_IMPORTED_MODULE_2__.BlobError(\n        \"client/`upload` doesn't allow `addRandomSuffix`, `cacheControlMaxAge` or `allowOverwrite`. Configure these options at the server side when generating client tokens.\"\n      );\n    }\n  },\n  async getToken(pathname, options) {\n    var _a, _b;\n    return retrieveClientToken({\n      handleUploadUrl: options.handleUploadUrl,\n      pathname,\n      clientPayload: (_a = options.clientPayload) != null ? _a : null,\n      multipart: (_b = options.multipart) != null ? _b : false,\n      headers: options.headers\n    });\n  }\n});\nasync function importKey(token) {\n  return globalThis.crypto.subtle.importKey(\n    \"raw\",\n    new TextEncoder().encode(token),\n    { name: \"HMAC\", hash: \"SHA-256\" },\n    false,\n    [\"sign\", \"verify\"]\n  );\n}\nasync function signPayload(payload, token) {\n  if (!globalThis.crypto) {\n    return crypto__WEBPACK_IMPORTED_MODULE_0__.createHmac(\"sha256\", token).update(payload).digest(\"hex\");\n  }\n  const signature = await globalThis.crypto.subtle.sign(\n    \"HMAC\",\n    await importKey(token),\n    new TextEncoder().encode(payload)\n  );\n  return Buffer.from(new Uint8Array(signature)).toString(\"hex\");\n}\nasync function verifyCallbackSignature({\n  token,\n  signature,\n  body\n}) {\n  const secret = token;\n  if (!globalThis.crypto) {\n    const digest = crypto__WEBPACK_IMPORTED_MODULE_0__.createHmac(\"sha256\", secret).update(body).digest(\"hex\");\n    const digestBuffer = Buffer.from(digest);\n    const signatureBuffer = Buffer.from(signature);\n    return digestBuffer.length === signatureBuffer.length && crypto__WEBPACK_IMPORTED_MODULE_0__.timingSafeEqual(digestBuffer, signatureBuffer);\n  }\n  const verified = await globalThis.crypto.subtle.verify(\n    \"HMAC\",\n    await importKey(token),\n    hexToArrayByte(signature),\n    new TextEncoder().encode(body)\n  );\n  return verified;\n}\nfunction hexToArrayByte(input) {\n  if (input.length % 2 !== 0) {\n    throw new RangeError(\"Expected string to be an even number of characters\");\n  }\n  const view = new Uint8Array(input.length / 2);\n  for (let i = 0; i < input.length; i += 2) {\n    view[i / 2] = Number.parseInt(input.substring(i, i + 2), 16);\n  }\n  return Buffer.from(view);\n}\nfunction getPayloadFromClientToken(clientToken) {\n  const [, , , , encodedToken] = clientToken.split(\"_\");\n  const encodedPayload = Buffer.from(encodedToken != null ? encodedToken : \"\", \"base64\").toString().split(\".\")[1];\n  const decodedPayload = Buffer.from(encodedPayload != null ? encodedPayload : \"\", \"base64\").toString();\n  return JSON.parse(decodedPayload);\n}\nvar EventTypes = {\n  generateClientToken: \"blob.generate-client-token\",\n  uploadCompleted: \"blob.upload-completed\"\n};\nasync function handleUpload({\n  token,\n  request,\n  body,\n  onBeforeGenerateToken,\n  onUploadCompleted\n}) {\n  var _a, _b, _c, _d;\n  const resolvedToken = (0,_chunk_FN6XFH6R_js__WEBPACK_IMPORTED_MODULE_2__.getTokenFromOptionsOrEnv)({ token });\n  const type = body.type;\n  switch (type) {\n    case \"blob.generate-client-token\": {\n      const { pathname, clientPayload, multipart } = body.payload;\n      const payload = await onBeforeGenerateToken(\n        pathname,\n        clientPayload,\n        multipart\n      );\n      const tokenPayload = (_a = payload.tokenPayload) != null ? _a : clientPayload;\n      const { callbackUrl: providedCallbackUrl, ...tokenOptions } = payload;\n      let callbackUrl = providedCallbackUrl;\n      if (onUploadCompleted && !callbackUrl) {\n        callbackUrl = getCallbackUrl(request);\n      }\n      if (!onUploadCompleted && callbackUrl) {\n        console.warn(\n          \"callbackUrl was provided but onUploadCompleted is not defined. The callback will not be handled.\"\n        );\n      }\n      const oneHourInSeconds = 60 * 60;\n      const now = /* @__PURE__ */ new Date();\n      const validUntil = (_b = payload.validUntil) != null ? _b : now.setSeconds(now.getSeconds() + oneHourInSeconds);\n      return {\n        type,\n        clientToken: await generateClientTokenFromReadWriteToken({\n          ...tokenOptions,\n          token: resolvedToken,\n          pathname,\n          onUploadCompleted: callbackUrl ? {\n            callbackUrl,\n            tokenPayload\n          } : void 0,\n          validUntil\n        })\n      };\n    }\n    case \"blob.upload-completed\": {\n      const signatureHeader = \"x-vercel-signature\";\n      const signature = \"credentials\" in request ? (_c = request.headers.get(signatureHeader)) != null ? _c : \"\" : (_d = request.headers[signatureHeader]) != null ? _d : \"\";\n      if (!signature) {\n        throw new _chunk_FN6XFH6R_js__WEBPACK_IMPORTED_MODULE_2__.BlobError(\"Missing callback signature\");\n      }\n      const isVerified = await verifyCallbackSignature({\n        token: resolvedToken,\n        signature,\n        body: JSON.stringify(body)\n      });\n      if (!isVerified) {\n        throw new _chunk_FN6XFH6R_js__WEBPACK_IMPORTED_MODULE_2__.BlobError(\"Invalid callback signature\");\n      }\n      if (onUploadCompleted) {\n        await onUploadCompleted(body.payload);\n      }\n      return { type, response: \"ok\" };\n    }\n    default:\n      throw new _chunk_FN6XFH6R_js__WEBPACK_IMPORTED_MODULE_2__.BlobError(\"Invalid event type\");\n  }\n}\nasync function retrieveClientToken(options) {\n  const { handleUploadUrl, pathname } = options;\n  const url = isAbsoluteUrl(handleUploadUrl) ? handleUploadUrl : toAbsoluteUrl(handleUploadUrl);\n  const event = {\n    type: EventTypes.generateClientToken,\n    payload: {\n      pathname,\n      clientPayload: options.clientPayload,\n      multipart: options.multipart\n    }\n  };\n  const res = await (0,undici__WEBPACK_IMPORTED_MODULE_1__.fetch)(url, {\n    method: \"POST\",\n    body: JSON.stringify(event),\n    headers: {\n      \"content-type\": \"application/json\",\n      ...options.headers\n    },\n    signal: options.abortSignal\n  });\n  if (!res.ok) {\n    throw new _chunk_FN6XFH6R_js__WEBPACK_IMPORTED_MODULE_2__.BlobError(\"Failed to  retrieve the client token\");\n  }\n  try {\n    const { clientToken } = await res.json();\n    return clientToken;\n  } catch {\n    throw new _chunk_FN6XFH6R_js__WEBPACK_IMPORTED_MODULE_2__.BlobError(\"Failed to retrieve the client token\");\n  }\n}\nfunction toAbsoluteUrl(url) {\n  return new URL(url, location.href).href;\n}\nfunction isAbsoluteUrl(url) {\n  try {\n    return Boolean(new URL(url));\n  } catch {\n    return false;\n  }\n}\nasync function generateClientTokenFromReadWriteToken({\n  token,\n  ...argsWithoutToken\n}) {\n  var _a;\n  if (typeof window !== \"undefined\") {\n    throw new _chunk_FN6XFH6R_js__WEBPACK_IMPORTED_MODULE_2__.BlobError(\n      '\"generateClientTokenFromReadWriteToken\" must be called from a server environment'\n    );\n  }\n  const timestamp = /* @__PURE__ */ new Date();\n  timestamp.setSeconds(timestamp.getSeconds() + 30);\n  const readWriteToken = (0,_chunk_FN6XFH6R_js__WEBPACK_IMPORTED_MODULE_2__.getTokenFromOptionsOrEnv)({ token });\n  const [, , , storeId = null] = readWriteToken.split(\"_\");\n  if (!storeId) {\n    throw new _chunk_FN6XFH6R_js__WEBPACK_IMPORTED_MODULE_2__.BlobError(\n      token ? \"Invalid `token` parameter\" : \"Invalid `BLOB_READ_WRITE_TOKEN`\"\n    );\n  }\n  const payload = Buffer.from(\n    JSON.stringify({\n      ...argsWithoutToken,\n      validUntil: (_a = argsWithoutToken.validUntil) != null ? _a : timestamp.getTime()\n    })\n  ).toString(\"base64\");\n  const securedKey = await signPayload(payload, readWriteToken);\n  if (!securedKey) {\n    throw new _chunk_FN6XFH6R_js__WEBPACK_IMPORTED_MODULE_2__.BlobError(\"Unable to sign client token\");\n  }\n  return `vercel_blob_client_${storeId}_${Buffer.from(\n    `${securedKey}.${payload}`\n  ).toString(\"base64\")}`;\n}\nfunction getCallbackUrl(request) {\n  const reqPath = getPathFromRequestUrl(request.url);\n  if (!reqPath) {\n    console.warn(\n      \"onUploadCompleted provided but no callbackUrl could be determined. Please provide a callbackUrl in onBeforeGenerateToken or set the VERCEL_BLOB_CALLBACK_URL environment variable.\"\n    );\n    return void 0;\n  }\n  if (process.env.VERCEL_BLOB_CALLBACK_URL) {\n    return `${process.env.VERCEL_BLOB_CALLBACK_URL}${reqPath}`;\n  }\n  if (process.env.VERCEL !== \"1\") {\n    console.warn(\n      \"onUploadCompleted provided but no callbackUrl could be determined. Please provide a callbackUrl in onBeforeGenerateToken or set the VERCEL_BLOB_CALLBACK_URL environment variable.\"\n    );\n    return void 0;\n  }\n  if (process.env.VERCEL_ENV === \"preview\") {\n    if (process.env.VERCEL_BRANCH_URL) {\n      return `https://${process.env.VERCEL_BRANCH_URL}${reqPath}`;\n    }\n    if (process.env.VERCEL_URL) {\n      return `https://${process.env.VERCEL_URL}${reqPath}`;\n    }\n  }\n  if (process.env.VERCEL_ENV === \"production\" && process.env.VERCEL_PROJECT_PRODUCTION_URL) {\n    return `https://${process.env.VERCEL_PROJECT_PRODUCTION_URL}${reqPath}`;\n  }\n  return void 0;\n}\nfunction getPathFromRequestUrl(url) {\n  try {\n    const parsedUrl = new URL(url, \"https://dummy.com\");\n    return parsedUrl.pathname + parsedUrl.search;\n  } catch {\n    return null;\n  }\n}\n\n//# sourceMappingURL=client.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHZlcmNlbC9ibG9iL2Rpc3QvY2xpZW50LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFTNkI7O0FBRTdCO0FBQ2lDO0FBQ0Y7QUFDL0I7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHlEQUFTLElBQUksWUFBWTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix5REFBUztBQUN6QixXQUFXLFlBQVk7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLG1FQUFlO0FBQ3pCO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsNEJBQTRCLHFGQUFpQztBQUM3RDtBQUNBO0FBQ0EsQ0FBQztBQUNELDhCQUE4Qix1RkFBbUM7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiwwRUFBc0I7QUFDdkM7QUFDQTtBQUNBLENBQUM7QUFDRCw4QkFBOEIsdUZBQW1DO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG1FQUFlO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix5REFBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IseURBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLCtCQUErQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDhDQUFpQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLG1CQUFtQiw4Q0FBaUI7QUFDcEM7QUFDQTtBQUNBLDZEQUE2RCxtREFBc0I7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLHdCQUF3Qiw0RUFBd0IsR0FBRyxPQUFPO0FBQzFEO0FBQ0E7QUFDQTtBQUNBLGNBQWMscUNBQXFDO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsb0RBQW9EO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IseURBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLGtCQUFrQix5REFBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0EsZ0JBQWdCLHlEQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLFVBQVUsNEJBQTRCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw2Q0FBSztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0EsY0FBYyx5REFBUztBQUN2QjtBQUNBO0FBQ0EsWUFBWSxjQUFjO0FBQzFCO0FBQ0EsSUFBSTtBQUNKLGNBQWMseURBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGNBQWMseURBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qiw0RUFBd0IsR0FBRyxPQUFPO0FBQzNEO0FBQ0E7QUFDQSxjQUFjLHlEQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGNBQWMseURBQVM7QUFDdkI7QUFDQSwrQkFBK0IsUUFBUSxHQUFHO0FBQzFDLE9BQU8sV0FBVyxHQUFHLFFBQVE7QUFDN0IsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxxQ0FBcUMsRUFBRSxRQUFRO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qiw4QkFBOEIsRUFBRSxRQUFRO0FBQ2hFO0FBQ0E7QUFDQSx3QkFBd0IsdUJBQXVCLEVBQUUsUUFBUTtBQUN6RDtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsMENBQTBDLEVBQUUsUUFBUTtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFZRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWFzamlkb3MvLi9ub2RlX21vZHVsZXMvQHZlcmNlbC9ibG9iL2Rpc3QvY2xpZW50LmpzPzkxMGMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgQmxvYkVycm9yLFxuICBjcmVhdGVDb21wbGV0ZU11bHRpcGFydFVwbG9hZE1ldGhvZCxcbiAgY3JlYXRlQ3JlYXRlTXVsdGlwYXJ0VXBsb2FkTWV0aG9kLFxuICBjcmVhdGVDcmVhdGVNdWx0aXBhcnRVcGxvYWRlck1ldGhvZCxcbiAgY3JlYXRlRm9sZGVyLFxuICBjcmVhdGVQdXRNZXRob2QsXG4gIGNyZWF0ZVVwbG9hZFBhcnRNZXRob2QsXG4gIGdldFRva2VuRnJvbU9wdGlvbnNPckVudlxufSBmcm9tIFwiLi9jaHVuay1GTjZYRkg2Ui5qc1wiO1xuXG4vLyBzcmMvY2xpZW50LnRzXG5pbXBvcnQgKiBhcyBjcnlwdG8gZnJvbSBcImNyeXB0b1wiO1xuaW1wb3J0IHsgZmV0Y2ggfSBmcm9tIFwidW5kaWNpXCI7XG5mdW5jdGlvbiBjcmVhdGVQdXRFeHRyYUNoZWNrcyhtZXRob2ROYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbiBleHRyYUNoZWNrcyhvcHRpb25zKSB7XG4gICAgaWYgKCFvcHRpb25zLnRva2VuLnN0YXJ0c1dpdGgoXCJ2ZXJjZWxfYmxvYl9jbGllbnRfXCIpKSB7XG4gICAgICB0aHJvdyBuZXcgQmxvYkVycm9yKGAke21ldGhvZE5hbWV9IG11c3QgYmUgY2FsbGVkIHdpdGggYSBjbGllbnQgdG9rZW5gKTtcbiAgICB9XG4gICAgaWYgKFxuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciAtLSBSdW50aW1lIGNoZWNrIGZvciBEWC5cbiAgICAgIG9wdGlvbnMuYWRkUmFuZG9tU3VmZml4ICE9PSB2b2lkIDAgfHwgLy8gQHRzLWV4cGVjdC1lcnJvciAtLSBSdW50aW1lIGNoZWNrIGZvciBEWC5cbiAgICAgIG9wdGlvbnMuYWxsb3dPdmVyd3JpdGUgIT09IHZvaWQgMCB8fCAvLyBAdHMtZXhwZWN0LWVycm9yIC0tIFJ1bnRpbWUgY2hlY2sgZm9yIERYLlxuICAgICAgb3B0aW9ucy5jYWNoZUNvbnRyb2xNYXhBZ2UgIT09IHZvaWQgMFxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEJsb2JFcnJvcihcbiAgICAgICAgYCR7bWV0aG9kTmFtZX0gZG9lc24ndCBhbGxvdyBcXGBhZGRSYW5kb21TdWZmaXhcXGAsIFxcYGNhY2hlQ29udHJvbE1heEFnZVxcYCBvciBcXGBhbGxvd092ZXJ3cml0ZVxcYC4gQ29uZmlndXJlIHRoZXNlIG9wdGlvbnMgYXQgdGhlIHNlcnZlciBzaWRlIHdoZW4gZ2VuZXJhdGluZyBjbGllbnQgdG9rZW5zLmBcbiAgICAgICk7XG4gICAgfVxuICB9O1xufVxudmFyIHB1dCA9IGNyZWF0ZVB1dE1ldGhvZCh7XG4gIGFsbG93ZWRPcHRpb25zOiBbXCJjb250ZW50VHlwZVwiXSxcbiAgZXh0cmFDaGVja3M6IGNyZWF0ZVB1dEV4dHJhQ2hlY2tzKFwiY2xpZW50L2BwdXRgXCIpXG59KTtcbnZhciBjcmVhdGVNdWx0aXBhcnRVcGxvYWQgPSBjcmVhdGVDcmVhdGVNdWx0aXBhcnRVcGxvYWRNZXRob2Qoe1xuICBhbGxvd2VkT3B0aW9uczogW1wiY29udGVudFR5cGVcIl0sXG4gIGV4dHJhQ2hlY2tzOiBjcmVhdGVQdXRFeHRyYUNoZWNrcyhcImNsaWVudC9gY3JlYXRlTXVsdGlwYXJ0VXBsb2FkYFwiKVxufSk7XG52YXIgY3JlYXRlTXVsdGlwYXJ0VXBsb2FkZXIgPSBjcmVhdGVDcmVhdGVNdWx0aXBhcnRVcGxvYWRlck1ldGhvZChcbiAge1xuICAgIGFsbG93ZWRPcHRpb25zOiBbXCJjb250ZW50VHlwZVwiXSxcbiAgICBleHRyYUNoZWNrczogY3JlYXRlUHV0RXh0cmFDaGVja3MoXCJjbGllbnQvYGNyZWF0ZU11bHRpcGFydFVwbG9hZGBcIilcbiAgfVxuKTtcbnZhciB1cGxvYWRQYXJ0ID0gY3JlYXRlVXBsb2FkUGFydE1ldGhvZCh7XG4gIGFsbG93ZWRPcHRpb25zOiBbXCJjb250ZW50VHlwZVwiXSxcbiAgZXh0cmFDaGVja3M6IGNyZWF0ZVB1dEV4dHJhQ2hlY2tzKFwiY2xpZW50L2BtdWx0aXBhcnRVcGxvYWRgXCIpXG59KTtcbnZhciBjb21wbGV0ZU11bHRpcGFydFVwbG9hZCA9IGNyZWF0ZUNvbXBsZXRlTXVsdGlwYXJ0VXBsb2FkTWV0aG9kKFxuICB7XG4gICAgYWxsb3dlZE9wdGlvbnM6IFtcImNvbnRlbnRUeXBlXCJdLFxuICAgIGV4dHJhQ2hlY2tzOiBjcmVhdGVQdXRFeHRyYUNoZWNrcyhcImNsaWVudC9gY29tcGxldGVNdWx0aXBhcnRVcGxvYWRgXCIpXG4gIH1cbik7XG52YXIgdXBsb2FkID0gY3JlYXRlUHV0TWV0aG9kKHtcbiAgYWxsb3dlZE9wdGlvbnM6IFtcImNvbnRlbnRUeXBlXCJdLFxuICBleHRyYUNoZWNrcyhvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMuaGFuZGxlVXBsb2FkVXJsID09PSB2b2lkIDApIHtcbiAgICAgIHRocm93IG5ldyBCbG9iRXJyb3IoXG4gICAgICAgIFwiY2xpZW50L2B1cGxvYWRgIHJlcXVpcmVzIHRoZSAnaGFuZGxlVXBsb2FkVXJsJyBwYXJhbWV0ZXJcIlxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKFxuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciAtLSBSdW50aW1lIGNoZWNrIGZvciBEWC5cbiAgICAgIG9wdGlvbnMuYWRkUmFuZG9tU3VmZml4ICE9PSB2b2lkIDAgfHwgLy8gQHRzLWV4cGVjdC1lcnJvciAtLSBSdW50aW1lIGNoZWNrIGZvciBEWC5cbiAgICAgIG9wdGlvbnMuY3JlYXRlUHV0RXh0cmFDaGVja3MgIT09IHZvaWQgMCB8fCAvLyBAdHMtZXhwZWN0LWVycm9yIC0tIFJ1bnRpbWUgY2hlY2sgZm9yIERYLlxuICAgICAgb3B0aW9ucy5jYWNoZUNvbnRyb2xNYXhBZ2UgIT09IHZvaWQgMFxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEJsb2JFcnJvcihcbiAgICAgICAgXCJjbGllbnQvYHVwbG9hZGAgZG9lc24ndCBhbGxvdyBgYWRkUmFuZG9tU3VmZml4YCwgYGNhY2hlQ29udHJvbE1heEFnZWAgb3IgYGFsbG93T3ZlcndyaXRlYC4gQ29uZmlndXJlIHRoZXNlIG9wdGlvbnMgYXQgdGhlIHNlcnZlciBzaWRlIHdoZW4gZ2VuZXJhdGluZyBjbGllbnQgdG9rZW5zLlwiXG4gICAgICApO1xuICAgIH1cbiAgfSxcbiAgYXN5bmMgZ2V0VG9rZW4ocGF0aG5hbWUsIG9wdGlvbnMpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHJldHVybiByZXRyaWV2ZUNsaWVudFRva2VuKHtcbiAgICAgIGhhbmRsZVVwbG9hZFVybDogb3B0aW9ucy5oYW5kbGVVcGxvYWRVcmwsXG4gICAgICBwYXRobmFtZSxcbiAgICAgIGNsaWVudFBheWxvYWQ6IChfYSA9IG9wdGlvbnMuY2xpZW50UGF5bG9hZCkgIT0gbnVsbCA/IF9hIDogbnVsbCxcbiAgICAgIG11bHRpcGFydDogKF9iID0gb3B0aW9ucy5tdWx0aXBhcnQpICE9IG51bGwgPyBfYiA6IGZhbHNlLFxuICAgICAgaGVhZGVyczogb3B0aW9ucy5oZWFkZXJzXG4gICAgfSk7XG4gIH1cbn0pO1xuYXN5bmMgZnVuY3Rpb24gaW1wb3J0S2V5KHRva2VuKSB7XG4gIHJldHVybiBnbG9iYWxUaGlzLmNyeXB0by5zdWJ0bGUuaW1wb3J0S2V5KFxuICAgIFwicmF3XCIsXG4gICAgbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHRva2VuKSxcbiAgICB7IG5hbWU6IFwiSE1BQ1wiLCBoYXNoOiBcIlNIQS0yNTZcIiB9LFxuICAgIGZhbHNlLFxuICAgIFtcInNpZ25cIiwgXCJ2ZXJpZnlcIl1cbiAgKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHNpZ25QYXlsb2FkKHBheWxvYWQsIHRva2VuKSB7XG4gIGlmICghZ2xvYmFsVGhpcy5jcnlwdG8pIHtcbiAgICByZXR1cm4gY3J5cHRvLmNyZWF0ZUhtYWMoXCJzaGEyNTZcIiwgdG9rZW4pLnVwZGF0ZShwYXlsb2FkKS5kaWdlc3QoXCJoZXhcIik7XG4gIH1cbiAgY29uc3Qgc2lnbmF0dXJlID0gYXdhaXQgZ2xvYmFsVGhpcy5jcnlwdG8uc3VidGxlLnNpZ24oXG4gICAgXCJITUFDXCIsXG4gICAgYXdhaXQgaW1wb3J0S2V5KHRva2VuKSxcbiAgICBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUocGF5bG9hZClcbiAgKTtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKG5ldyBVaW50OEFycmF5KHNpZ25hdHVyZSkpLnRvU3RyaW5nKFwiaGV4XCIpO1xufVxuYXN5bmMgZnVuY3Rpb24gdmVyaWZ5Q2FsbGJhY2tTaWduYXR1cmUoe1xuICB0b2tlbixcbiAgc2lnbmF0dXJlLFxuICBib2R5XG59KSB7XG4gIGNvbnN0IHNlY3JldCA9IHRva2VuO1xuICBpZiAoIWdsb2JhbFRoaXMuY3J5cHRvKSB7XG4gICAgY29uc3QgZGlnZXN0ID0gY3J5cHRvLmNyZWF0ZUhtYWMoXCJzaGEyNTZcIiwgc2VjcmV0KS51cGRhdGUoYm9keSkuZGlnZXN0KFwiaGV4XCIpO1xuICAgIGNvbnN0IGRpZ2VzdEJ1ZmZlciA9IEJ1ZmZlci5mcm9tKGRpZ2VzdCk7XG4gICAgY29uc3Qgc2lnbmF0dXJlQnVmZmVyID0gQnVmZmVyLmZyb20oc2lnbmF0dXJlKTtcbiAgICByZXR1cm4gZGlnZXN0QnVmZmVyLmxlbmd0aCA9PT0gc2lnbmF0dXJlQnVmZmVyLmxlbmd0aCAmJiBjcnlwdG8udGltaW5nU2FmZUVxdWFsKGRpZ2VzdEJ1ZmZlciwgc2lnbmF0dXJlQnVmZmVyKTtcbiAgfVxuICBjb25zdCB2ZXJpZmllZCA9IGF3YWl0IGdsb2JhbFRoaXMuY3J5cHRvLnN1YnRsZS52ZXJpZnkoXG4gICAgXCJITUFDXCIsXG4gICAgYXdhaXQgaW1wb3J0S2V5KHRva2VuKSxcbiAgICBoZXhUb0FycmF5Qnl0ZShzaWduYXR1cmUpLFxuICAgIG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShib2R5KVxuICApO1xuICByZXR1cm4gdmVyaWZpZWQ7XG59XG5mdW5jdGlvbiBoZXhUb0FycmF5Qnl0ZShpbnB1dCkge1xuICBpZiAoaW5wdXQubGVuZ3RoICUgMiAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiRXhwZWN0ZWQgc3RyaW5nIHRvIGJlIGFuIGV2ZW4gbnVtYmVyIG9mIGNoYXJhY3RlcnNcIik7XG4gIH1cbiAgY29uc3QgdmlldyA9IG5ldyBVaW50OEFycmF5KGlucHV0Lmxlbmd0aCAvIDIpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0Lmxlbmd0aDsgaSArPSAyKSB7XG4gICAgdmlld1tpIC8gMl0gPSBOdW1iZXIucGFyc2VJbnQoaW5wdXQuc3Vic3RyaW5nKGksIGkgKyAyKSwgMTYpO1xuICB9XG4gIHJldHVybiBCdWZmZXIuZnJvbSh2aWV3KTtcbn1cbmZ1bmN0aW9uIGdldFBheWxvYWRGcm9tQ2xpZW50VG9rZW4oY2xpZW50VG9rZW4pIHtcbiAgY29uc3QgWywgLCAsICwgZW5jb2RlZFRva2VuXSA9IGNsaWVudFRva2VuLnNwbGl0KFwiX1wiKTtcbiAgY29uc3QgZW5jb2RlZFBheWxvYWQgPSBCdWZmZXIuZnJvbShlbmNvZGVkVG9rZW4gIT0gbnVsbCA/IGVuY29kZWRUb2tlbiA6IFwiXCIsIFwiYmFzZTY0XCIpLnRvU3RyaW5nKCkuc3BsaXQoXCIuXCIpWzFdO1xuICBjb25zdCBkZWNvZGVkUGF5bG9hZCA9IEJ1ZmZlci5mcm9tKGVuY29kZWRQYXlsb2FkICE9IG51bGwgPyBlbmNvZGVkUGF5bG9hZCA6IFwiXCIsIFwiYmFzZTY0XCIpLnRvU3RyaW5nKCk7XG4gIHJldHVybiBKU09OLnBhcnNlKGRlY29kZWRQYXlsb2FkKTtcbn1cbnZhciBFdmVudFR5cGVzID0ge1xuICBnZW5lcmF0ZUNsaWVudFRva2VuOiBcImJsb2IuZ2VuZXJhdGUtY2xpZW50LXRva2VuXCIsXG4gIHVwbG9hZENvbXBsZXRlZDogXCJibG9iLnVwbG9hZC1jb21wbGV0ZWRcIlxufTtcbmFzeW5jIGZ1bmN0aW9uIGhhbmRsZVVwbG9hZCh7XG4gIHRva2VuLFxuICByZXF1ZXN0LFxuICBib2R5LFxuICBvbkJlZm9yZUdlbmVyYXRlVG9rZW4sXG4gIG9uVXBsb2FkQ29tcGxldGVkXG59KSB7XG4gIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgY29uc3QgcmVzb2x2ZWRUb2tlbiA9IGdldFRva2VuRnJvbU9wdGlvbnNPckVudih7IHRva2VuIH0pO1xuICBjb25zdCB0eXBlID0gYm9keS50eXBlO1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFwiYmxvYi5nZW5lcmF0ZS1jbGllbnQtdG9rZW5cIjoge1xuICAgICAgY29uc3QgeyBwYXRobmFtZSwgY2xpZW50UGF5bG9hZCwgbXVsdGlwYXJ0IH0gPSBib2R5LnBheWxvYWQ7XG4gICAgICBjb25zdCBwYXlsb2FkID0gYXdhaXQgb25CZWZvcmVHZW5lcmF0ZVRva2VuKFxuICAgICAgICBwYXRobmFtZSxcbiAgICAgICAgY2xpZW50UGF5bG9hZCxcbiAgICAgICAgbXVsdGlwYXJ0XG4gICAgICApO1xuICAgICAgY29uc3QgdG9rZW5QYXlsb2FkID0gKF9hID0gcGF5bG9hZC50b2tlblBheWxvYWQpICE9IG51bGwgPyBfYSA6IGNsaWVudFBheWxvYWQ7XG4gICAgICBjb25zdCB7IGNhbGxiYWNrVXJsOiBwcm92aWRlZENhbGxiYWNrVXJsLCAuLi50b2tlbk9wdGlvbnMgfSA9IHBheWxvYWQ7XG4gICAgICBsZXQgY2FsbGJhY2tVcmwgPSBwcm92aWRlZENhbGxiYWNrVXJsO1xuICAgICAgaWYgKG9uVXBsb2FkQ29tcGxldGVkICYmICFjYWxsYmFja1VybCkge1xuICAgICAgICBjYWxsYmFja1VybCA9IGdldENhbGxiYWNrVXJsKHJlcXVlc3QpO1xuICAgICAgfVxuICAgICAgaWYgKCFvblVwbG9hZENvbXBsZXRlZCAmJiBjYWxsYmFja1VybCkge1xuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgXCJjYWxsYmFja1VybCB3YXMgcHJvdmlkZWQgYnV0IG9uVXBsb2FkQ29tcGxldGVkIGlzIG5vdCBkZWZpbmVkLiBUaGUgY2FsbGJhY2sgd2lsbCBub3QgYmUgaGFuZGxlZC5cIlxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY29uc3Qgb25lSG91ckluU2Vjb25kcyA9IDYwICogNjA7XG4gICAgICBjb25zdCBub3cgPSAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKTtcbiAgICAgIGNvbnN0IHZhbGlkVW50aWwgPSAoX2IgPSBwYXlsb2FkLnZhbGlkVW50aWwpICE9IG51bGwgPyBfYiA6IG5vdy5zZXRTZWNvbmRzKG5vdy5nZXRTZWNvbmRzKCkgKyBvbmVIb3VySW5TZWNvbmRzKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGUsXG4gICAgICAgIGNsaWVudFRva2VuOiBhd2FpdCBnZW5lcmF0ZUNsaWVudFRva2VuRnJvbVJlYWRXcml0ZVRva2VuKHtcbiAgICAgICAgICAuLi50b2tlbk9wdGlvbnMsXG4gICAgICAgICAgdG9rZW46IHJlc29sdmVkVG9rZW4sXG4gICAgICAgICAgcGF0aG5hbWUsXG4gICAgICAgICAgb25VcGxvYWRDb21wbGV0ZWQ6IGNhbGxiYWNrVXJsID8ge1xuICAgICAgICAgICAgY2FsbGJhY2tVcmwsXG4gICAgICAgICAgICB0b2tlblBheWxvYWRcbiAgICAgICAgICB9IDogdm9pZCAwLFxuICAgICAgICAgIHZhbGlkVW50aWxcbiAgICAgICAgfSlcbiAgICAgIH07XG4gICAgfVxuICAgIGNhc2UgXCJibG9iLnVwbG9hZC1jb21wbGV0ZWRcIjoge1xuICAgICAgY29uc3Qgc2lnbmF0dXJlSGVhZGVyID0gXCJ4LXZlcmNlbC1zaWduYXR1cmVcIjtcbiAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IFwiY3JlZGVudGlhbHNcIiBpbiByZXF1ZXN0ID8gKF9jID0gcmVxdWVzdC5oZWFkZXJzLmdldChzaWduYXR1cmVIZWFkZXIpKSAhPSBudWxsID8gX2MgOiBcIlwiIDogKF9kID0gcmVxdWVzdC5oZWFkZXJzW3NpZ25hdHVyZUhlYWRlcl0pICE9IG51bGwgPyBfZCA6IFwiXCI7XG4gICAgICBpZiAoIXNpZ25hdHVyZSkge1xuICAgICAgICB0aHJvdyBuZXcgQmxvYkVycm9yKFwiTWlzc2luZyBjYWxsYmFjayBzaWduYXR1cmVcIik7XG4gICAgICB9XG4gICAgICBjb25zdCBpc1ZlcmlmaWVkID0gYXdhaXQgdmVyaWZ5Q2FsbGJhY2tTaWduYXR1cmUoe1xuICAgICAgICB0b2tlbjogcmVzb2x2ZWRUb2tlbixcbiAgICAgICAgc2lnbmF0dXJlLFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KVxuICAgICAgfSk7XG4gICAgICBpZiAoIWlzVmVyaWZpZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEJsb2JFcnJvcihcIkludmFsaWQgY2FsbGJhY2sgc2lnbmF0dXJlXCIpO1xuICAgICAgfVxuICAgICAgaWYgKG9uVXBsb2FkQ29tcGxldGVkKSB7XG4gICAgICAgIGF3YWl0IG9uVXBsb2FkQ29tcGxldGVkKGJvZHkucGF5bG9hZCk7XG4gICAgICB9XG4gICAgICByZXR1cm4geyB0eXBlLCByZXNwb25zZTogXCJva1wiIH07XG4gICAgfVxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgQmxvYkVycm9yKFwiSW52YWxpZCBldmVudCB0eXBlXCIpO1xuICB9XG59XG5hc3luYyBmdW5jdGlvbiByZXRyaWV2ZUNsaWVudFRva2VuKG9wdGlvbnMpIHtcbiAgY29uc3QgeyBoYW5kbGVVcGxvYWRVcmwsIHBhdGhuYW1lIH0gPSBvcHRpb25zO1xuICBjb25zdCB1cmwgPSBpc0Fic29sdXRlVXJsKGhhbmRsZVVwbG9hZFVybCkgPyBoYW5kbGVVcGxvYWRVcmwgOiB0b0Fic29sdXRlVXJsKGhhbmRsZVVwbG9hZFVybCk7XG4gIGNvbnN0IGV2ZW50ID0ge1xuICAgIHR5cGU6IEV2ZW50VHlwZXMuZ2VuZXJhdGVDbGllbnRUb2tlbixcbiAgICBwYXlsb2FkOiB7XG4gICAgICBwYXRobmFtZSxcbiAgICAgIGNsaWVudFBheWxvYWQ6IG9wdGlvbnMuY2xpZW50UGF5bG9hZCxcbiAgICAgIG11bHRpcGFydDogb3B0aW9ucy5tdWx0aXBhcnRcbiAgICB9XG4gIH07XG4gIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgYm9keTogSlNPTi5zdHJpbmdpZnkoZXZlbnQpLFxuICAgIGhlYWRlcnM6IHtcbiAgICAgIFwiY29udGVudC10eXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgLi4ub3B0aW9ucy5oZWFkZXJzXG4gICAgfSxcbiAgICBzaWduYWw6IG9wdGlvbnMuYWJvcnRTaWduYWxcbiAgfSk7XG4gIGlmICghcmVzLm9rKSB7XG4gICAgdGhyb3cgbmV3IEJsb2JFcnJvcihcIkZhaWxlZCB0byAgcmV0cmlldmUgdGhlIGNsaWVudCB0b2tlblwiKTtcbiAgfVxuICB0cnkge1xuICAgIGNvbnN0IHsgY2xpZW50VG9rZW4gfSA9IGF3YWl0IHJlcy5qc29uKCk7XG4gICAgcmV0dXJuIGNsaWVudFRva2VuO1xuICB9IGNhdGNoIHtcbiAgICB0aHJvdyBuZXcgQmxvYkVycm9yKFwiRmFpbGVkIHRvIHJldHJpZXZlIHRoZSBjbGllbnQgdG9rZW5cIik7XG4gIH1cbn1cbmZ1bmN0aW9uIHRvQWJzb2x1dGVVcmwodXJsKSB7XG4gIHJldHVybiBuZXcgVVJMKHVybCwgbG9jYXRpb24uaHJlZikuaHJlZjtcbn1cbmZ1bmN0aW9uIGlzQWJzb2x1dGVVcmwodXJsKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIEJvb2xlYW4obmV3IFVSTCh1cmwpKTtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5hc3luYyBmdW5jdGlvbiBnZW5lcmF0ZUNsaWVudFRva2VuRnJvbVJlYWRXcml0ZVRva2VuKHtcbiAgdG9rZW4sXG4gIC4uLmFyZ3NXaXRob3V0VG9rZW5cbn0pIHtcbiAgdmFyIF9hO1xuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHRocm93IG5ldyBCbG9iRXJyb3IoXG4gICAgICAnXCJnZW5lcmF0ZUNsaWVudFRva2VuRnJvbVJlYWRXcml0ZVRva2VuXCIgbXVzdCBiZSBjYWxsZWQgZnJvbSBhIHNlcnZlciBlbnZpcm9ubWVudCdcbiAgICApO1xuICB9XG4gIGNvbnN0IHRpbWVzdGFtcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpO1xuICB0aW1lc3RhbXAuc2V0U2Vjb25kcyh0aW1lc3RhbXAuZ2V0U2Vjb25kcygpICsgMzApO1xuICBjb25zdCByZWFkV3JpdGVUb2tlbiA9IGdldFRva2VuRnJvbU9wdGlvbnNPckVudih7IHRva2VuIH0pO1xuICBjb25zdCBbLCAsICwgc3RvcmVJZCA9IG51bGxdID0gcmVhZFdyaXRlVG9rZW4uc3BsaXQoXCJfXCIpO1xuICBpZiAoIXN0b3JlSWQpIHtcbiAgICB0aHJvdyBuZXcgQmxvYkVycm9yKFxuICAgICAgdG9rZW4gPyBcIkludmFsaWQgYHRva2VuYCBwYXJhbWV0ZXJcIiA6IFwiSW52YWxpZCBgQkxPQl9SRUFEX1dSSVRFX1RPS0VOYFwiXG4gICAgKTtcbiAgfVxuICBjb25zdCBwYXlsb2FkID0gQnVmZmVyLmZyb20oXG4gICAgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgLi4uYXJnc1dpdGhvdXRUb2tlbixcbiAgICAgIHZhbGlkVW50aWw6IChfYSA9IGFyZ3NXaXRob3V0VG9rZW4udmFsaWRVbnRpbCkgIT0gbnVsbCA/IF9hIDogdGltZXN0YW1wLmdldFRpbWUoKVxuICAgIH0pXG4gICkudG9TdHJpbmcoXCJiYXNlNjRcIik7XG4gIGNvbnN0IHNlY3VyZWRLZXkgPSBhd2FpdCBzaWduUGF5bG9hZChwYXlsb2FkLCByZWFkV3JpdGVUb2tlbik7XG4gIGlmICghc2VjdXJlZEtleSkge1xuICAgIHRocm93IG5ldyBCbG9iRXJyb3IoXCJVbmFibGUgdG8gc2lnbiBjbGllbnQgdG9rZW5cIik7XG4gIH1cbiAgcmV0dXJuIGB2ZXJjZWxfYmxvYl9jbGllbnRfJHtzdG9yZUlkfV8ke0J1ZmZlci5mcm9tKFxuICAgIGAke3NlY3VyZWRLZXl9LiR7cGF5bG9hZH1gXG4gICkudG9TdHJpbmcoXCJiYXNlNjRcIil9YDtcbn1cbmZ1bmN0aW9uIGdldENhbGxiYWNrVXJsKHJlcXVlc3QpIHtcbiAgY29uc3QgcmVxUGF0aCA9IGdldFBhdGhGcm9tUmVxdWVzdFVybChyZXF1ZXN0LnVybCk7XG4gIGlmICghcmVxUGF0aCkge1xuICAgIGNvbnNvbGUud2FybihcbiAgICAgIFwib25VcGxvYWRDb21wbGV0ZWQgcHJvdmlkZWQgYnV0IG5vIGNhbGxiYWNrVXJsIGNvdWxkIGJlIGRldGVybWluZWQuIFBsZWFzZSBwcm92aWRlIGEgY2FsbGJhY2tVcmwgaW4gb25CZWZvcmVHZW5lcmF0ZVRva2VuIG9yIHNldCB0aGUgVkVSQ0VMX0JMT0JfQ0FMTEJBQ0tfVVJMIGVudmlyb25tZW50IHZhcmlhYmxlLlwiXG4gICAgKTtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIGlmIChwcm9jZXNzLmVudi5WRVJDRUxfQkxPQl9DQUxMQkFDS19VUkwpIHtcbiAgICByZXR1cm4gYCR7cHJvY2Vzcy5lbnYuVkVSQ0VMX0JMT0JfQ0FMTEJBQ0tfVVJMfSR7cmVxUGF0aH1gO1xuICB9XG4gIGlmIChwcm9jZXNzLmVudi5WRVJDRUwgIT09IFwiMVwiKSB7XG4gICAgY29uc29sZS53YXJuKFxuICAgICAgXCJvblVwbG9hZENvbXBsZXRlZCBwcm92aWRlZCBidXQgbm8gY2FsbGJhY2tVcmwgY291bGQgYmUgZGV0ZXJtaW5lZC4gUGxlYXNlIHByb3ZpZGUgYSBjYWxsYmFja1VybCBpbiBvbkJlZm9yZUdlbmVyYXRlVG9rZW4gb3Igc2V0IHRoZSBWRVJDRUxfQkxPQl9DQUxMQkFDS19VUkwgZW52aXJvbm1lbnQgdmFyaWFibGUuXCJcbiAgICApO1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgaWYgKHByb2Nlc3MuZW52LlZFUkNFTF9FTlYgPT09IFwicHJldmlld1wiKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52LlZFUkNFTF9CUkFOQ0hfVVJMKSB7XG4gICAgICByZXR1cm4gYGh0dHBzOi8vJHtwcm9jZXNzLmVudi5WRVJDRUxfQlJBTkNIX1VSTH0ke3JlcVBhdGh9YDtcbiAgICB9XG4gICAgaWYgKHByb2Nlc3MuZW52LlZFUkNFTF9VUkwpIHtcbiAgICAgIHJldHVybiBgaHR0cHM6Ly8ke3Byb2Nlc3MuZW52LlZFUkNFTF9VUkx9JHtyZXFQYXRofWA7XG4gICAgfVxuICB9XG4gIGlmIChwcm9jZXNzLmVudi5WRVJDRUxfRU5WID09PSBcInByb2R1Y3Rpb25cIiAmJiBwcm9jZXNzLmVudi5WRVJDRUxfUFJPSkVDVF9QUk9EVUNUSU9OX1VSTCkge1xuICAgIHJldHVybiBgaHR0cHM6Ly8ke3Byb2Nlc3MuZW52LlZFUkNFTF9QUk9KRUNUX1BST0RVQ1RJT05fVVJMfSR7cmVxUGF0aH1gO1xuICB9XG4gIHJldHVybiB2b2lkIDA7XG59XG5mdW5jdGlvbiBnZXRQYXRoRnJvbVJlcXVlc3RVcmwodXJsKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgcGFyc2VkVXJsID0gbmV3IFVSTCh1cmwsIFwiaHR0cHM6Ly9kdW1teS5jb21cIik7XG4gICAgcmV0dXJuIHBhcnNlZFVybC5wYXRobmFtZSArIHBhcnNlZFVybC5zZWFyY2g7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5leHBvcnQge1xuICBjb21wbGV0ZU11bHRpcGFydFVwbG9hZCxcbiAgY3JlYXRlRm9sZGVyLFxuICBjcmVhdGVNdWx0aXBhcnRVcGxvYWQsXG4gIGNyZWF0ZU11bHRpcGFydFVwbG9hZGVyLFxuICBnZW5lcmF0ZUNsaWVudFRva2VuRnJvbVJlYWRXcml0ZVRva2VuLFxuICBnZXRQYXlsb2FkRnJvbUNsaWVudFRva2VuLFxuICBoYW5kbGVVcGxvYWQsXG4gIHB1dCxcbiAgdXBsb2FkLFxuICB1cGxvYWRQYXJ0XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2xpZW50LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@vercel/blob/dist/client.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@vercel/blob/dist/chunk-FN6XFH6R.js":
/*!**********************************************************!*\
  !*** ./node_modules/@vercel/blob/dist/chunk-FN6XFH6R.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BlobAccessError: () => (/* binding */ BlobAccessError),\n/* harmony export */   BlobClientTokenExpiredError: () => (/* binding */ BlobClientTokenExpiredError),\n/* harmony export */   BlobContentTypeNotAllowedError: () => (/* binding */ BlobContentTypeNotAllowedError),\n/* harmony export */   BlobError: () => (/* binding */ BlobError),\n/* harmony export */   BlobFileTooLargeError: () => (/* binding */ BlobFileTooLargeError),\n/* harmony export */   BlobNotFoundError: () => (/* binding */ BlobNotFoundError),\n/* harmony export */   BlobPathnameMismatchError: () => (/* binding */ BlobPathnameMismatchError),\n/* harmony export */   BlobRequestAbortedError: () => (/* binding */ BlobRequestAbortedError),\n/* harmony export */   BlobServiceNotAvailable: () => (/* binding */ BlobServiceNotAvailable),\n/* harmony export */   BlobServiceRateLimited: () => (/* binding */ BlobServiceRateLimited),\n/* harmony export */   BlobStoreNotFoundError: () => (/* binding */ BlobStoreNotFoundError),\n/* harmony export */   BlobStoreSuspendedError: () => (/* binding */ BlobStoreSuspendedError),\n/* harmony export */   BlobUnknownError: () => (/* binding */ BlobUnknownError),\n/* harmony export */   MAXIMUM_PATHNAME_LENGTH: () => (/* binding */ MAXIMUM_PATHNAME_LENGTH),\n/* harmony export */   createCompleteMultipartUploadMethod: () => (/* binding */ createCompleteMultipartUploadMethod),\n/* harmony export */   createCreateMultipartUploadMethod: () => (/* binding */ createCreateMultipartUploadMethod),\n/* harmony export */   createCreateMultipartUploaderMethod: () => (/* binding */ createCreateMultipartUploaderMethod),\n/* harmony export */   createFolder: () => (/* binding */ createFolder),\n/* harmony export */   createPutMethod: () => (/* binding */ createPutMethod),\n/* harmony export */   createUploadPartMethod: () => (/* binding */ createUploadPartMethod),\n/* harmony export */   disallowedPathnameCharacters: () => (/* binding */ disallowedPathnameCharacters),\n/* harmony export */   getDownloadUrl: () => (/* binding */ getDownloadUrl),\n/* harmony export */   getTokenFromOptionsOrEnv: () => (/* binding */ getTokenFromOptionsOrEnv),\n/* harmony export */   requestApi: () => (/* binding */ requestApi)\n/* harmony export */ });\n/* harmony import */ var is_node_process__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! is-node-process */ \"(rsc)/./node_modules/is-node-process/lib/index.mjs\");\n/* harmony import */ var is_buffer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! is-buffer */ \"(rsc)/./node_modules/is-buffer/index.js\");\n/* harmony import */ var stream__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! stream */ \"stream\");\n/* harmony import */ var async_retry__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! async-retry */ \"(rsc)/./node_modules/async-retry/lib/index.js\");\n/* harmony import */ var undici__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! undici */ \"(rsc)/./node_modules/undici/index.js\");\n/* harmony import */ var throttleit__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! throttleit */ \"(rsc)/./node_modules/throttleit/index.js\");\n// src/helpers.ts\n\n\n// src/multipart/helpers.ts\n\n\nvar supportsNewBlobFromArrayBuffer = new Promise((resolve) => {\n  try {\n    const helloAsArrayBuffer = new Uint8Array([104, 101, 108, 108, 111]);\n    const blob = new Blob([helloAsArrayBuffer]);\n    blob.text().then((text) => {\n      resolve(text === \"hello\");\n    }).catch(() => {\n      resolve(false);\n    });\n  } catch {\n    resolve(false);\n  }\n});\nasync function toReadableStream(value) {\n  if (value instanceof ReadableStream) {\n    return value;\n  }\n  if (value instanceof Blob) {\n    return value.stream();\n  }\n  if (isNodeJsReadableStream(value)) {\n    return stream__WEBPACK_IMPORTED_MODULE_2__.Readable.toWeb(value);\n  }\n  let streamValue;\n  if (value instanceof ArrayBuffer) {\n    streamValue = new Uint8Array(value);\n  } else if (isNodeJsBuffer(value)) {\n    streamValue = value;\n  } else {\n    streamValue = stringToUint8Array(value);\n  }\n  if (await supportsNewBlobFromArrayBuffer) {\n    return new Blob([streamValue]).stream();\n  }\n  return new ReadableStream({\n    start(controller) {\n      controller.enqueue(streamValue);\n      controller.close();\n    }\n  });\n}\nfunction isNodeJsReadableStream(value) {\n  return typeof value === \"object\" && typeof value.pipe === \"function\" && value.readable && typeof value._read === \"function\" && // @ts-expect-error _readableState does exists on Readable\n  typeof value._readableState === \"object\";\n}\nfunction stringToUint8Array(s) {\n  const enc = new TextEncoder();\n  return enc.encode(s);\n}\nfunction isNodeJsBuffer(value) {\n  return is_buffer__WEBPACK_IMPORTED_MODULE_1__(value);\n}\n\n// src/bytes.ts\nvar parseRegExp = /^((-|\\+)?(\\d+(?:\\.\\d+)?)) *(kb|mb|gb|tb|pb)$/i;\nvar map = {\n  b: 1,\n  kb: 1 << 10,\n  mb: 1 << 20,\n  gb: 1 << 30,\n  tb: 1024 ** 4,\n  pb: 1024 ** 5\n};\nfunction bytes(val) {\n  if (typeof val === \"number\" && !Number.isNaN(val)) {\n    return val;\n  }\n  if (typeof val !== \"string\") {\n    return null;\n  }\n  const results = parseRegExp.exec(val);\n  let floatValue;\n  let unit = \"b\";\n  if (!results) {\n    floatValue = parseInt(val, 10);\n  } else {\n    const [, res, , , unitMatch] = results;\n    if (!res) {\n      return null;\n    }\n    floatValue = parseFloat(res);\n    if (unitMatch) {\n      unit = unitMatch.toLowerCase();\n    }\n  }\n  if (Number.isNaN(floatValue)) {\n    return null;\n  }\n  return Math.floor(map[unit] * floatValue);\n}\n\n// src/helpers.ts\nvar defaultVercelBlobApiUrl = \"https://vercel.com/api/blob\";\nfunction getTokenFromOptionsOrEnv(options) {\n  if (options == null ? void 0 : options.token) {\n    return options.token;\n  }\n  if (process.env.BLOB_READ_WRITE_TOKEN) {\n    return process.env.BLOB_READ_WRITE_TOKEN;\n  }\n  throw new BlobError(\n    \"No token found. Either configure the `BLOB_READ_WRITE_TOKEN` environment variable, or pass a `token` option to your calls.\"\n  );\n}\nvar BlobError = class extends Error {\n  constructor(message) {\n    super(`Vercel Blob: ${message}`);\n  }\n};\nfunction getDownloadUrl(blobUrl) {\n  const url = new URL(blobUrl);\n  url.searchParams.set(\"download\", \"1\");\n  return url.toString();\n}\nfunction isPlainObject(value) {\n  if (typeof value !== \"object\" || value === null) {\n    return false;\n  }\n  const prototype = Object.getPrototypeOf(value);\n  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);\n}\nvar disallowedPathnameCharacters = [\"//\"];\nvar supportsRequestStreams = (() => {\n  if ((0,is_node_process__WEBPACK_IMPORTED_MODULE_0__.isNodeProcess)()) {\n    return true;\n  }\n  const apiUrl = getApiUrl();\n  if (apiUrl.startsWith(\"http://localhost\")) {\n    return false;\n  }\n  let duplexAccessed = false;\n  const hasContentType = new Request(getApiUrl(), {\n    body: new ReadableStream(),\n    method: \"POST\",\n    // @ts-expect-error -- TypeScript doesn't yet have duplex but it's in the spec: https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1729\n    get duplex() {\n      duplexAccessed = true;\n      return \"half\";\n    }\n  }).headers.has(\"Content-Type\");\n  return duplexAccessed && !hasContentType;\n})();\nfunction getApiUrl(pathname = \"\") {\n  let baseUrl = null;\n  try {\n    baseUrl = process.env.VERCEL_BLOB_API_URL || process.env.NEXT_PUBLIC_VERCEL_BLOB_API_URL;\n  } catch {\n  }\n  return `${baseUrl || defaultVercelBlobApiUrl}${pathname}`;\n}\nvar TEXT_ENCODER = typeof TextEncoder === \"function\" ? new TextEncoder() : null;\nfunction computeBodyLength(body) {\n  if (!body) {\n    return 0;\n  }\n  if (typeof body === \"string\") {\n    if (TEXT_ENCODER) {\n      return TEXT_ENCODER.encode(body).byteLength;\n    }\n    return new Blob([body]).size;\n  }\n  if (\"byteLength\" in body && typeof body.byteLength === \"number\") {\n    return body.byteLength;\n  }\n  if (\"size\" in body && typeof body.size === \"number\") {\n    return body.size;\n  }\n  return 0;\n}\nvar createChunkTransformStream = (chunkSize, onProgress) => {\n  let buffer = new Uint8Array(0);\n  return new TransformStream({\n    transform(chunk, controller) {\n      queueMicrotask(() => {\n        const newBuffer = new Uint8Array(buffer.length + chunk.byteLength);\n        newBuffer.set(buffer);\n        newBuffer.set(new Uint8Array(chunk), buffer.length);\n        buffer = newBuffer;\n        while (buffer.length >= chunkSize) {\n          const newChunk = buffer.slice(0, chunkSize);\n          controller.enqueue(newChunk);\n          onProgress == null ? void 0 : onProgress(newChunk.byteLength);\n          buffer = buffer.slice(chunkSize);\n        }\n      });\n    },\n    flush(controller) {\n      queueMicrotask(() => {\n        if (buffer.length > 0) {\n          controller.enqueue(buffer);\n          onProgress == null ? void 0 : onProgress(buffer.byteLength);\n        }\n      });\n    }\n  });\n};\nfunction isReadableStream(value) {\n  return globalThis.ReadableStream && // TODO: Can be removed once Node.js 16 is no more required internally\n  value instanceof ReadableStream;\n}\nfunction isStream(value) {\n  if (isReadableStream(value)) {\n    return true;\n  }\n  if (isNodeJsReadableStream(value)) {\n    return true;\n  }\n  return false;\n}\n\n// src/api.ts\n\n\n// src/debug.ts\nvar debugIsActive = false;\nvar _a, _b;\ntry {\n  if (((_a = process.env.DEBUG) == null ? void 0 : _a.includes(\"blob\")) || ((_b = process.env.NEXT_PUBLIC_DEBUG) == null ? void 0 : _b.includes(\"blob\"))) {\n    debugIsActive = true;\n  }\n} catch {\n}\nfunction debug(message, ...args) {\n  if (debugIsActive) {\n    console.debug(`vercel-blob: ${message}`, ...args);\n  }\n}\n\n// src/dom-exception.ts\nvar _a2;\nvar DOMException2 = (_a2 = globalThis.DOMException) != null ? _a2 : (() => {\n  try {\n    atob(\"~\");\n  } catch (err) {\n    return Object.getPrototypeOf(err).constructor;\n  }\n})();\n\n// src/is-network-error.ts\nvar objectToString = Object.prototype.toString;\nvar isError = (value) => objectToString.call(value) === \"[object Error]\";\nvar errorMessages = /* @__PURE__ */ new Set([\n  \"network error\",\n  // Chrome\n  \"Failed to fetch\",\n  // Chrome\n  \"NetworkError when attempting to fetch resource.\",\n  // Firefox\n  \"The Internet connection appears to be offline.\",\n  // Safari 16\n  \"Load failed\",\n  // Safari 17+\n  \"Network request failed\",\n  // `cross-fetch`\n  \"fetch failed\",\n  // Undici (Node.js)\n  \"terminated\"\n  // Undici (Node.js)\n]);\nfunction isNetworkError(error) {\n  const isValid = error && isError(error) && error.name === \"TypeError\" && typeof error.message === \"string\";\n  if (!isValid) {\n    return false;\n  }\n  if (error.message === \"Load failed\") {\n    return error.stack === void 0;\n  }\n  return errorMessages.has(error.message);\n}\n\n// src/fetch.ts\n\nvar hasFetch = typeof undici__WEBPACK_IMPORTED_MODULE_4__.fetch === \"function\";\nvar hasFetchWithUploadProgress = hasFetch && supportsRequestStreams;\nvar CHUNK_SIZE = 64 * 1024;\nvar blobFetch = async ({\n  input,\n  init,\n  onUploadProgress\n}) => {\n  debug(\"using fetch\");\n  let body;\n  if (init.body) {\n    if (onUploadProgress) {\n      const stream = await toReadableStream(init.body);\n      let loaded = 0;\n      const chunkTransformStream = createChunkTransformStream(\n        CHUNK_SIZE,\n        (newLoaded) => {\n          loaded += newLoaded;\n          onUploadProgress(loaded);\n        }\n      );\n      body = stream.pipeThrough(chunkTransformStream);\n    } else {\n      body = init.body;\n    }\n  }\n  const duplex = supportsRequestStreams && body && isStream(body) ? \"half\" : void 0;\n  return (0,undici__WEBPACK_IMPORTED_MODULE_4__.fetch)(\n    input,\n    // @ts-expect-error -- Blob and Nodejs Blob are triggering type errors, fine with it\n    {\n      ...init,\n      ...init.body ? { body } : {},\n      duplex\n    }\n  );\n};\n\n// src/xhr.ts\nvar hasXhr = typeof XMLHttpRequest !== \"undefined\";\nvar blobXhr = async ({\n  input,\n  init,\n  onUploadProgress\n}) => {\n  debug(\"using xhr\");\n  let body = null;\n  if (init.body) {\n    if (isReadableStream(init.body)) {\n      body = await new Response(init.body).blob();\n    } else {\n      body = init.body;\n    }\n  }\n  return new Promise((resolve, reject) => {\n    const xhr = new XMLHttpRequest();\n    xhr.open(init.method || \"GET\", input.toString(), true);\n    if (onUploadProgress) {\n      xhr.upload.addEventListener(\"progress\", (event) => {\n        if (event.lengthComputable) {\n          onUploadProgress(event.loaded);\n        }\n      });\n    }\n    xhr.onload = () => {\n      var _a3;\n      if ((_a3 = init.signal) == null ? void 0 : _a3.aborted) {\n        reject(new DOMException(\"The user aborted the request.\", \"AbortError\"));\n        return;\n      }\n      const headers = new Headers();\n      const rawHeaders = xhr.getAllResponseHeaders().trim().split(/[\\r\\n]+/);\n      rawHeaders.forEach((line) => {\n        const parts = line.split(\": \");\n        const key = parts.shift();\n        const value = parts.join(\": \");\n        if (key) headers.set(key.toLowerCase(), value);\n      });\n      const response = new Response(xhr.response, {\n        status: xhr.status,\n        statusText: xhr.statusText,\n        headers\n      });\n      resolve(response);\n    };\n    xhr.onerror = () => {\n      reject(new TypeError(\"Network request failed\"));\n    };\n    xhr.ontimeout = () => {\n      reject(new TypeError(\"Network request timed out\"));\n    };\n    xhr.onabort = () => {\n      reject(new DOMException(\"The user aborted a request.\", \"AbortError\"));\n    };\n    if (init.headers) {\n      const headers = new Headers(init.headers);\n      headers.forEach((value, key) => {\n        xhr.setRequestHeader(key, value);\n      });\n    }\n    if (init.signal) {\n      init.signal.addEventListener(\"abort\", () => {\n        xhr.abort();\n      });\n      if (init.signal.aborted) {\n        xhr.abort();\n        return;\n      }\n    }\n    xhr.send(body);\n  });\n};\n\n// src/request.ts\nvar blobRequest = async ({\n  input,\n  init,\n  onUploadProgress\n}) => {\n  if (onUploadProgress) {\n    if (hasFetchWithUploadProgress) {\n      return blobFetch({ input, init, onUploadProgress });\n    }\n    if (hasXhr) {\n      return blobXhr({ input, init, onUploadProgress });\n    }\n  }\n  if (hasFetch) {\n    return blobFetch({ input, init });\n  }\n  if (hasXhr) {\n    return blobXhr({ input, init });\n  }\n  throw new Error(\"No request implementation available\");\n};\n\n// src/api.ts\nvar MAXIMUM_PATHNAME_LENGTH = 950;\nvar BlobAccessError = class extends BlobError {\n  constructor() {\n    super(\"Access denied, please provide a valid token for this resource.\");\n  }\n};\nvar BlobContentTypeNotAllowedError = class extends BlobError {\n  constructor(message) {\n    super(`Content type mismatch, ${message}.`);\n  }\n};\nvar BlobPathnameMismatchError = class extends BlobError {\n  constructor(message) {\n    super(\n      `Pathname mismatch, ${message}. Check the pathname used in upload() or put() matches the one from the client token.`\n    );\n  }\n};\nvar BlobClientTokenExpiredError = class extends BlobError {\n  constructor() {\n    super(\"Client token has expired.\");\n  }\n};\nvar BlobFileTooLargeError = class extends BlobError {\n  constructor(message) {\n    super(`File is too large, ${message}.`);\n  }\n};\nvar BlobStoreNotFoundError = class extends BlobError {\n  constructor() {\n    super(\"This store does not exist.\");\n  }\n};\nvar BlobStoreSuspendedError = class extends BlobError {\n  constructor() {\n    super(\"This store has been suspended.\");\n  }\n};\nvar BlobUnknownError = class extends BlobError {\n  constructor() {\n    super(\"Unknown error, please visit https://vercel.com/help.\");\n  }\n};\nvar BlobNotFoundError = class extends BlobError {\n  constructor() {\n    super(\"The requested blob does not exist\");\n  }\n};\nvar BlobServiceNotAvailable = class extends BlobError {\n  constructor() {\n    super(\"The blob service is currently not available. Please try again.\");\n  }\n};\nvar BlobServiceRateLimited = class extends BlobError {\n  constructor(seconds) {\n    super(\n      `Too many requests please lower the number of concurrent requests ${seconds ? ` - try again in ${seconds} seconds` : \"\"}.`\n    );\n    this.retryAfter = seconds != null ? seconds : 0;\n  }\n};\nvar BlobRequestAbortedError = class extends BlobError {\n  constructor() {\n    super(\"The request was aborted.\");\n  }\n};\nvar BLOB_API_VERSION = 11;\nfunction getApiVersion() {\n  let versionOverride = null;\n  try {\n    versionOverride = process.env.VERCEL_BLOB_API_VERSION_OVERRIDE || process.env.NEXT_PUBLIC_VERCEL_BLOB_API_VERSION_OVERRIDE;\n  } catch {\n  }\n  return `${versionOverride != null ? versionOverride : BLOB_API_VERSION}`;\n}\nfunction getRetries() {\n  try {\n    const retries = process.env.VERCEL_BLOB_RETRIES || \"10\";\n    return parseInt(retries, 10);\n  } catch {\n    return 10;\n  }\n}\nfunction createBlobServiceRateLimited(response) {\n  const retryAfter = response.headers.get(\"retry-after\");\n  return new BlobServiceRateLimited(\n    retryAfter ? parseInt(retryAfter, 10) : void 0\n  );\n}\nasync function getBlobError(response) {\n  var _a3, _b2, _c;\n  let code;\n  let message;\n  try {\n    const data = await response.json();\n    code = (_b2 = (_a3 = data.error) == null ? void 0 : _a3.code) != null ? _b2 : \"unknown_error\";\n    message = (_c = data.error) == null ? void 0 : _c.message;\n  } catch {\n    code = \"unknown_error\";\n  }\n  if ((message == null ? void 0 : message.includes(\"contentType\")) && message.includes(\"is not allowed\")) {\n    code = \"content_type_not_allowed\";\n  }\n  if ((message == null ? void 0 : message.includes('\"pathname\"')) && message.includes(\"does not match the token payload\")) {\n    code = \"client_token_pathname_mismatch\";\n  }\n  if (message === \"Token expired\") {\n    code = \"client_token_expired\";\n  }\n  if (message == null ? void 0 : message.includes(\"the file length cannot be greater than\")) {\n    code = \"file_too_large\";\n  }\n  let error;\n  switch (code) {\n    case \"store_suspended\":\n      error = new BlobStoreSuspendedError();\n      break;\n    case \"forbidden\":\n      error = new BlobAccessError();\n      break;\n    case \"content_type_not_allowed\":\n      error = new BlobContentTypeNotAllowedError(message);\n      break;\n    case \"client_token_pathname_mismatch\":\n      error = new BlobPathnameMismatchError(message);\n      break;\n    case \"client_token_expired\":\n      error = new BlobClientTokenExpiredError();\n      break;\n    case \"file_too_large\":\n      error = new BlobFileTooLargeError(message);\n      break;\n    case \"not_found\":\n      error = new BlobNotFoundError();\n      break;\n    case \"store_not_found\":\n      error = new BlobStoreNotFoundError();\n      break;\n    case \"bad_request\":\n      error = new BlobError(message != null ? message : \"Bad request\");\n      break;\n    case \"service_unavailable\":\n      error = new BlobServiceNotAvailable();\n      break;\n    case \"rate_limited\":\n      error = createBlobServiceRateLimited(response);\n      break;\n    case \"unknown_error\":\n    case \"not_allowed\":\n    default:\n      error = new BlobUnknownError();\n      break;\n  }\n  return { code, error };\n}\nasync function requestApi(pathname, init, commandOptions) {\n  const apiVersion = getApiVersion();\n  const token = getTokenFromOptionsOrEnv(commandOptions);\n  const extraHeaders = getProxyThroughAlternativeApiHeaderFromEnv();\n  const [, , , storeId = \"\"] = token.split(\"_\");\n  const requestId = `${storeId}:${Date.now()}:${Math.random().toString(16).slice(2)}`;\n  let retryCount = 0;\n  let bodyLength = 0;\n  let totalLoaded = 0;\n  const sendBodyLength = (commandOptions == null ? void 0 : commandOptions.onUploadProgress) || shouldUseXContentLength();\n  if (init.body && // 1. For upload progress we always need to know the total size of the body\n  // 2. In development we need the header for put() to work correctly when passing a stream\n  sendBodyLength) {\n    bodyLength = computeBodyLength(init.body);\n  }\n  if (commandOptions == null ? void 0 : commandOptions.onUploadProgress) {\n    commandOptions.onUploadProgress({\n      loaded: 0,\n      total: bodyLength,\n      percentage: 0\n    });\n  }\n  const apiResponse = await async_retry__WEBPACK_IMPORTED_MODULE_3__(\n    async (bail) => {\n      let res;\n      try {\n        res = await blobRequest({\n          input: getApiUrl(pathname),\n          init: {\n            ...init,\n            headers: {\n              \"x-api-blob-request-id\": requestId,\n              \"x-api-blob-request-attempt\": String(retryCount),\n              \"x-api-version\": apiVersion,\n              ...sendBodyLength ? { \"x-content-length\": String(bodyLength) } : {},\n              authorization: `Bearer ${token}`,\n              ...extraHeaders,\n              ...init.headers\n            }\n          },\n          onUploadProgress: (commandOptions == null ? void 0 : commandOptions.onUploadProgress) ? (loaded) => {\n            var _a3;\n            const total = bodyLength !== 0 ? bodyLength : loaded;\n            totalLoaded = loaded;\n            const percentage = bodyLength > 0 ? Number((loaded / total * 100).toFixed(2)) : 0;\n            if (percentage === 100 && bodyLength > 0) {\n              return;\n            }\n            (_a3 = commandOptions.onUploadProgress) == null ? void 0 : _a3.call(commandOptions, {\n              loaded,\n              // When passing a stream to put(), we have no way to know the total size of the body.\n              // Instead of defining total as total?: number we decided to set the total to the currently\n              // loaded number. This is not inaccurate and way more practical for DX.\n              // Passing down a stream to put() is very rare\n              total,\n              percentage\n            });\n          } : void 0\n        });\n      } catch (error2) {\n        if (error2 instanceof DOMException2 && error2.name === \"AbortError\") {\n          bail(new BlobRequestAbortedError());\n          return;\n        }\n        if (isNetworkError(error2)) {\n          throw error2;\n        }\n        if (error2 instanceof TypeError) {\n          bail(error2);\n          return;\n        }\n        throw error2;\n      }\n      if (res.ok) {\n        return res;\n      }\n      const { code, error } = await getBlobError(res);\n      if (code === \"unknown_error\" || code === \"service_unavailable\" || code === \"internal_server_error\") {\n        throw error;\n      }\n      bail(error);\n    },\n    {\n      retries: getRetries(),\n      onRetry: (error) => {\n        if (error instanceof Error) {\n          debug(`retrying API request to ${pathname}`, error.message);\n        }\n        retryCount = retryCount + 1;\n      }\n    }\n  );\n  if (!apiResponse) {\n    throw new BlobUnknownError();\n  }\n  if (commandOptions == null ? void 0 : commandOptions.onUploadProgress) {\n    commandOptions.onUploadProgress({\n      loaded: totalLoaded,\n      total: totalLoaded,\n      percentage: 100\n    });\n  }\n  return await apiResponse.json();\n}\nfunction getProxyThroughAlternativeApiHeaderFromEnv() {\n  const extraHeaders = {};\n  try {\n    if (\"VERCEL_BLOB_PROXY_THROUGH_ALTERNATIVE_API\" in process.env && process.env.VERCEL_BLOB_PROXY_THROUGH_ALTERNATIVE_API !== void 0) {\n      extraHeaders[\"x-proxy-through-alternative-api\"] = process.env.VERCEL_BLOB_PROXY_THROUGH_ALTERNATIVE_API;\n    } else if (\"NEXT_PUBLIC_VERCEL_BLOB_PROXY_THROUGH_ALTERNATIVE_API\" in process.env && process.env.NEXT_PUBLIC_VERCEL_BLOB_PROXY_THROUGH_ALTERNATIVE_API !== void 0) {\n      extraHeaders[\"x-proxy-through-alternative-api\"] = process.env.NEXT_PUBLIC_VERCEL_BLOB_PROXY_THROUGH_ALTERNATIVE_API;\n    }\n  } catch {\n  }\n  return extraHeaders;\n}\nfunction shouldUseXContentLength() {\n  try {\n    return process.env.VERCEL_BLOB_USE_X_CONTENT_LENGTH === \"1\";\n  } catch {\n    return false;\n  }\n}\n\n// src/put-helpers.ts\nvar putOptionHeaderMap = {\n  cacheControlMaxAge: \"x-cache-control-max-age\",\n  addRandomSuffix: \"x-add-random-suffix\",\n  allowOverwrite: \"x-allow-overwrite\",\n  contentType: \"x-content-type\"\n};\nfunction createPutHeaders(allowedOptions, options) {\n  const headers = {};\n  if (allowedOptions.includes(\"contentType\") && options.contentType) {\n    headers[putOptionHeaderMap.contentType] = options.contentType;\n  }\n  if (allowedOptions.includes(\"addRandomSuffix\") && options.addRandomSuffix !== void 0) {\n    headers[putOptionHeaderMap.addRandomSuffix] = options.addRandomSuffix ? \"1\" : \"0\";\n  }\n  if (allowedOptions.includes(\"allowOverwrite\") && options.allowOverwrite !== void 0) {\n    headers[putOptionHeaderMap.allowOverwrite] = options.allowOverwrite ? \"1\" : \"0\";\n  }\n  if (allowedOptions.includes(\"cacheControlMaxAge\") && options.cacheControlMaxAge !== void 0) {\n    headers[putOptionHeaderMap.cacheControlMaxAge] = options.cacheControlMaxAge.toString();\n  }\n  return headers;\n}\nasync function createPutOptions({\n  pathname,\n  options,\n  extraChecks,\n  getToken\n}) {\n  if (!pathname) {\n    throw new BlobError(\"pathname is required\");\n  }\n  if (pathname.length > MAXIMUM_PATHNAME_LENGTH) {\n    throw new BlobError(\n      `pathname is too long, maximum length is ${MAXIMUM_PATHNAME_LENGTH}`\n    );\n  }\n  for (const invalidCharacter of disallowedPathnameCharacters) {\n    if (pathname.includes(invalidCharacter)) {\n      throw new BlobError(\n        `pathname cannot contain \"${invalidCharacter}\", please encode it if needed`\n      );\n    }\n  }\n  if (!options) {\n    throw new BlobError(\"missing options, see usage\");\n  }\n  if (options.access !== \"public\") {\n    throw new BlobError('access must be \"public\"');\n  }\n  if (extraChecks) {\n    extraChecks(options);\n  }\n  if (getToken) {\n    options.token = await getToken(pathname, options);\n  }\n  return options;\n}\n\n// src/multipart/complete.ts\nfunction createCompleteMultipartUploadMethod({ allowedOptions, getToken, extraChecks }) {\n  return async (pathname, parts, optionsInput) => {\n    const options = await createPutOptions({\n      pathname,\n      options: optionsInput,\n      extraChecks,\n      getToken\n    });\n    const headers = createPutHeaders(allowedOptions, options);\n    return completeMultipartUpload({\n      uploadId: options.uploadId,\n      key: options.key,\n      pathname,\n      headers,\n      options,\n      parts\n    });\n  };\n}\nasync function completeMultipartUpload({\n  uploadId,\n  key,\n  pathname,\n  parts,\n  headers,\n  options\n}) {\n  const params = new URLSearchParams({ pathname });\n  try {\n    const response = await requestApi(\n      `/mpu?${params.toString()}`,\n      {\n        method: \"POST\",\n        headers: {\n          ...headers,\n          \"content-type\": \"application/json\",\n          \"x-mpu-action\": \"complete\",\n          \"x-mpu-upload-id\": uploadId,\n          // key can be any utf8 character so we need to encode it as HTTP headers can only be us-ascii\n          // https://www.rfc-editor.org/rfc/rfc7230#swection-3.2.4\n          \"x-mpu-key\": encodeURIComponent(key)\n        },\n        body: JSON.stringify(parts),\n        signal: options.abortSignal\n      },\n      options\n    );\n    debug(\"mpu: complete\", response);\n    return response;\n  } catch (error) {\n    if (error instanceof TypeError && (error.message === \"Failed to fetch\" || error.message === \"fetch failed\")) {\n      throw new BlobServiceNotAvailable();\n    } else {\n      throw error;\n    }\n  }\n}\n\n// src/multipart/create.ts\nfunction createCreateMultipartUploadMethod({ allowedOptions, getToken, extraChecks }) {\n  return async (pathname, optionsInput) => {\n    const options = await createPutOptions({\n      pathname,\n      options: optionsInput,\n      extraChecks,\n      getToken\n    });\n    const headers = createPutHeaders(allowedOptions, options);\n    const createMultipartUploadResponse = await createMultipartUpload(\n      pathname,\n      headers,\n      options\n    );\n    return {\n      key: createMultipartUploadResponse.key,\n      uploadId: createMultipartUploadResponse.uploadId\n    };\n  };\n}\nasync function createMultipartUpload(pathname, headers, options) {\n  debug(\"mpu: create\", \"pathname:\", pathname);\n  const params = new URLSearchParams({ pathname });\n  try {\n    const response = await requestApi(\n      `/mpu?${params.toString()}`,\n      {\n        method: \"POST\",\n        headers: {\n          ...headers,\n          \"x-mpu-action\": \"create\"\n        },\n        signal: options.abortSignal\n      },\n      options\n    );\n    debug(\"mpu: create\", response);\n    return response;\n  } catch (error) {\n    if (error instanceof TypeError && (error.message === \"Failed to fetch\" || error.message === \"fetch failed\")) {\n      throw new BlobServiceNotAvailable();\n    }\n    throw error;\n  }\n}\n\n// src/multipart/upload.ts\n\nfunction createUploadPartMethod({ allowedOptions, getToken, extraChecks }) {\n  return async (pathname, body, optionsInput) => {\n    const options = await createPutOptions({\n      pathname,\n      options: optionsInput,\n      extraChecks,\n      getToken\n    });\n    const headers = createPutHeaders(allowedOptions, options);\n    if (isPlainObject(body)) {\n      throw new BlobError(\n        \"Body must be a string, buffer or stream. You sent a plain JavaScript object, double check what you're trying to upload.\"\n      );\n    }\n    const result = await uploadPart({\n      uploadId: options.uploadId,\n      key: options.key,\n      pathname,\n      part: { blob: body, partNumber: options.partNumber },\n      headers,\n      options\n    });\n    return {\n      etag: result.etag,\n      partNumber: options.partNumber\n    };\n  };\n}\nasync function uploadPart({\n  uploadId,\n  key,\n  pathname,\n  headers,\n  options,\n  internalAbortController = new AbortController(),\n  part\n}) {\n  var _a3, _b2, _c;\n  const params = new URLSearchParams({ pathname });\n  const responsePromise = requestApi(\n    `/mpu?${params.toString()}`,\n    {\n      signal: internalAbortController.signal,\n      method: \"POST\",\n      headers: {\n        ...headers,\n        \"x-mpu-action\": \"upload\",\n        \"x-mpu-key\": encodeURIComponent(key),\n        \"x-mpu-upload-id\": uploadId,\n        \"x-mpu-part-number\": part.partNumber.toString()\n      },\n      // weird things between undici types and native fetch types\n      body: part.blob\n    },\n    options\n  );\n  function handleAbort() {\n    internalAbortController.abort();\n  }\n  if ((_a3 = options.abortSignal) == null ? void 0 : _a3.aborted) {\n    handleAbort();\n  } else {\n    (_b2 = options.abortSignal) == null ? void 0 : _b2.addEventListener(\"abort\", handleAbort);\n  }\n  const response = await responsePromise;\n  (_c = options.abortSignal) == null ? void 0 : _c.removeEventListener(\"abort\", handleAbort);\n  return response;\n}\nvar maxConcurrentUploads = typeof window !== \"undefined\" ? 6 : 8;\nvar partSizeInBytes = 8 * 1024 * 1024;\nvar maxBytesInMemory = maxConcurrentUploads * partSizeInBytes * 2;\nfunction uploadAllParts({\n  uploadId,\n  key,\n  pathname,\n  stream,\n  headers,\n  options,\n  totalToLoad\n}) {\n  debug(\"mpu: upload init\", \"key:\", key);\n  const internalAbortController = new AbortController();\n  return new Promise((resolve, reject) => {\n    const partsToUpload = [];\n    const completedParts = [];\n    const reader = stream.getReader();\n    let activeUploads = 0;\n    let reading = false;\n    let currentPartNumber = 1;\n    let rejected = false;\n    let currentBytesInMemory = 0;\n    let doneReading = false;\n    let bytesSent = 0;\n    let arrayBuffers = [];\n    let currentPartBytesRead = 0;\n    let onUploadProgress;\n    const totalLoadedPerPartNumber = {};\n    if (options.onUploadProgress) {\n      onUploadProgress = throttleit__WEBPACK_IMPORTED_MODULE_5__(() => {\n        var _a3;\n        const loaded = Object.values(totalLoadedPerPartNumber).reduce(\n          (acc, cur) => {\n            return acc + cur;\n          },\n          0\n        );\n        const total = totalToLoad || loaded;\n        const percentage = totalToLoad > 0 ? Number(((loaded / totalToLoad || loaded) * 100).toFixed(2)) : 0;\n        (_a3 = options.onUploadProgress) == null ? void 0 : _a3.call(options, { loaded, total, percentage });\n      }, 150);\n    }\n    read().catch(cancel);\n    async function read() {\n      debug(\n        \"mpu: upload read start\",\n        \"activeUploads:\",\n        activeUploads,\n        \"currentBytesInMemory:\",\n        `${bytes(currentBytesInMemory)}/${bytes(maxBytesInMemory)}`,\n        \"bytesSent:\",\n        bytes(bytesSent)\n      );\n      reading = true;\n      while (currentBytesInMemory < maxBytesInMemory && !rejected) {\n        try {\n          const { value, done } = await reader.read();\n          if (done) {\n            doneReading = true;\n            debug(\"mpu: upload read consumed the whole stream\");\n            if (arrayBuffers.length > 0) {\n              partsToUpload.push({\n                partNumber: currentPartNumber++,\n                blob: new Blob(arrayBuffers, {\n                  type: \"application/octet-stream\"\n                })\n              });\n              sendParts();\n            }\n            reading = false;\n            return;\n          }\n          currentBytesInMemory += value.byteLength;\n          let valueOffset = 0;\n          while (valueOffset < value.byteLength) {\n            const remainingPartSize = partSizeInBytes - currentPartBytesRead;\n            const endOffset = Math.min(\n              valueOffset + remainingPartSize,\n              value.byteLength\n            );\n            const chunk = value.slice(valueOffset, endOffset);\n            arrayBuffers.push(chunk);\n            currentPartBytesRead += chunk.byteLength;\n            valueOffset = endOffset;\n            if (currentPartBytesRead === partSizeInBytes) {\n              partsToUpload.push({\n                partNumber: currentPartNumber++,\n                blob: new Blob(arrayBuffers, {\n                  type: \"application/octet-stream\"\n                })\n              });\n              arrayBuffers = [];\n              currentPartBytesRead = 0;\n              sendParts();\n            }\n          }\n        } catch (error) {\n          cancel(error);\n        }\n      }\n      debug(\n        \"mpu: upload read end\",\n        \"activeUploads:\",\n        activeUploads,\n        \"currentBytesInMemory:\",\n        `${bytes(currentBytesInMemory)}/${bytes(maxBytesInMemory)}`,\n        \"bytesSent:\",\n        bytes(bytesSent)\n      );\n      reading = false;\n    }\n    async function sendPart(part) {\n      activeUploads++;\n      debug(\n        \"mpu: upload send part start\",\n        \"partNumber:\",\n        part.partNumber,\n        \"size:\",\n        part.blob.size,\n        \"activeUploads:\",\n        activeUploads,\n        \"currentBytesInMemory:\",\n        `${bytes(currentBytesInMemory)}/${bytes(maxBytesInMemory)}`,\n        \"bytesSent:\",\n        bytes(bytesSent)\n      );\n      try {\n        const uploadProgressForPart = options.onUploadProgress ? (event) => {\n          totalLoadedPerPartNumber[part.partNumber] = event.loaded;\n          if (onUploadProgress) {\n            onUploadProgress();\n          }\n        } : void 0;\n        const completedPart = await uploadPart({\n          uploadId,\n          key,\n          pathname,\n          headers,\n          options: {\n            ...options,\n            onUploadProgress: uploadProgressForPart\n          },\n          internalAbortController,\n          part\n        });\n        debug(\n          \"mpu: upload send part end\",\n          \"partNumber:\",\n          part.partNumber,\n          \"activeUploads\",\n          activeUploads,\n          \"currentBytesInMemory:\",\n          `${bytes(currentBytesInMemory)}/${bytes(maxBytesInMemory)}`,\n          \"bytesSent:\",\n          bytes(bytesSent)\n        );\n        if (rejected) {\n          return;\n        }\n        completedParts.push({\n          partNumber: part.partNumber,\n          etag: completedPart.etag\n        });\n        currentBytesInMemory -= part.blob.size;\n        activeUploads--;\n        bytesSent += part.blob.size;\n        if (partsToUpload.length > 0) {\n          sendParts();\n        }\n        if (doneReading) {\n          if (activeUploads === 0) {\n            reader.releaseLock();\n            resolve(completedParts);\n          }\n          return;\n        }\n        if (!reading) {\n          read().catch(cancel);\n        }\n      } catch (error) {\n        cancel(error);\n      }\n    }\n    function sendParts() {\n      if (rejected) {\n        return;\n      }\n      debug(\n        \"send parts\",\n        \"activeUploads\",\n        activeUploads,\n        \"partsToUpload\",\n        partsToUpload.length\n      );\n      while (activeUploads < maxConcurrentUploads && partsToUpload.length > 0) {\n        const partToSend = partsToUpload.shift();\n        if (partToSend) {\n          void sendPart(partToSend);\n        }\n      }\n    }\n    function cancel(error) {\n      if (rejected) {\n        return;\n      }\n      rejected = true;\n      internalAbortController.abort();\n      reader.releaseLock();\n      if (error instanceof TypeError && (error.message === \"Failed to fetch\" || error.message === \"fetch failed\")) {\n        reject(new BlobServiceNotAvailable());\n      } else {\n        reject(error);\n      }\n    }\n  });\n}\n\n// src/multipart/create-uploader.ts\nfunction createCreateMultipartUploaderMethod({ allowedOptions, getToken, extraChecks }) {\n  return async (pathname, optionsInput) => {\n    const options = await createPutOptions({\n      pathname,\n      options: optionsInput,\n      extraChecks,\n      getToken\n    });\n    const headers = createPutHeaders(allowedOptions, options);\n    const createMultipartUploadResponse = await createMultipartUpload(\n      pathname,\n      headers,\n      options\n    );\n    return {\n      key: createMultipartUploadResponse.key,\n      uploadId: createMultipartUploadResponse.uploadId,\n      async uploadPart(partNumber, body) {\n        if (isPlainObject(body)) {\n          throw new BlobError(\n            \"Body must be a string, buffer or stream. You sent a plain JavaScript object, double check what you're trying to upload.\"\n          );\n        }\n        const result = await uploadPart({\n          uploadId: createMultipartUploadResponse.uploadId,\n          key: createMultipartUploadResponse.key,\n          pathname,\n          part: { partNumber, blob: body },\n          headers,\n          options\n        });\n        return {\n          etag: result.etag,\n          partNumber\n        };\n      },\n      async complete(parts) {\n        return completeMultipartUpload({\n          uploadId: createMultipartUploadResponse.uploadId,\n          key: createMultipartUploadResponse.key,\n          pathname,\n          parts,\n          headers,\n          options\n        });\n      }\n    };\n  };\n}\n\n// src/put.ts\n\n\n// src/multipart/uncontrolled.ts\nasync function uncontrolledMultipartUpload(pathname, body, headers, options) {\n  debug(\"mpu: init\", \"pathname:\", pathname, \"headers:\", headers);\n  const optionsWithoutOnUploadProgress = {\n    ...options,\n    onUploadProgress: void 0\n  };\n  const createMultipartUploadResponse = await createMultipartUpload(\n    pathname,\n    headers,\n    optionsWithoutOnUploadProgress\n  );\n  const totalToLoad = computeBodyLength(body);\n  const stream = await toReadableStream(body);\n  const parts = await uploadAllParts({\n    uploadId: createMultipartUploadResponse.uploadId,\n    key: createMultipartUploadResponse.key,\n    pathname,\n    stream,\n    headers,\n    options,\n    totalToLoad\n  });\n  const blob = await completeMultipartUpload({\n    uploadId: createMultipartUploadResponse.uploadId,\n    key: createMultipartUploadResponse.key,\n    pathname,\n    parts,\n    headers,\n    options: optionsWithoutOnUploadProgress\n  });\n  return blob;\n}\n\n// src/put.ts\nfunction createPutMethod({\n  allowedOptions,\n  getToken,\n  extraChecks\n}) {\n  return async function put(pathname, body, optionsInput) {\n    if (!body) {\n      throw new BlobError(\"body is required\");\n    }\n    if (isPlainObject(body)) {\n      throw new BlobError(\n        \"Body must be a string, buffer or stream. You sent a plain JavaScript object, double check what you're trying to upload.\"\n      );\n    }\n    const options = await createPutOptions({\n      pathname,\n      options: optionsInput,\n      extraChecks,\n      getToken\n    });\n    const headers = createPutHeaders(allowedOptions, options);\n    if (options.multipart === true) {\n      return uncontrolledMultipartUpload(pathname, body, headers, options);\n    }\n    const onUploadProgress = options.onUploadProgress ? throttleit__WEBPACK_IMPORTED_MODULE_5__(options.onUploadProgress, 100) : void 0;\n    const params = new URLSearchParams({ pathname });\n    const response = await requestApi(\n      `/?${params.toString()}`,\n      {\n        method: \"PUT\",\n        body,\n        headers,\n        signal: options.abortSignal\n      },\n      {\n        ...options,\n        onUploadProgress\n      }\n    );\n    return {\n      url: response.url,\n      downloadUrl: response.downloadUrl,\n      pathname: response.pathname,\n      contentType: response.contentType,\n      contentDisposition: response.contentDisposition\n    };\n  };\n}\n\n// src/create-folder.ts\nasync function createFolder(pathname, options = {}) {\n  const folderPathname = pathname.endsWith(\"/\") ? pathname : `${pathname}/`;\n  const headers = {};\n  headers[putOptionHeaderMap.addRandomSuffix] = \"0\";\n  const params = new URLSearchParams({ pathname: folderPathname });\n  const response = await requestApi(\n    `/?${params.toString()}`,\n    {\n      method: \"PUT\",\n      headers,\n      signal: options.abortSignal\n    },\n    options\n  );\n  return {\n    url: response.url,\n    pathname: response.pathname\n  };\n}\n\n\n/*!\n * bytes\n * Copyright(c) 2012-2014 TJ Holowaychuk\n * Copyright(c) 2015 Jed Watson\n * MIT Licensed\n */\n//# sourceMappingURL=chunk-FN6XFH6R.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHZlcmNlbC9ibG9iL2Rpc3QvY2h1bmstRk42WEZINlIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDZ0Q7O0FBRWhEO0FBQ2lDO0FBQ0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDRDQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxzQ0FBUTtBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixRQUFRO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSw4REFBYTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCx1Q0FBUztBQUNqRSx5Q0FBeUMsVUFBVTtBQUNuRDtBQUNBLFdBQVcsa0JBQWtCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtEQUFrRDtBQUNsRCxnRUFBZ0UsU0FBUztBQUN6RTtBQUNBO0FBQ0EsdUNBQXVDLDBCQUEwQjtBQUNqRTtBQUNBLFNBQVMsa0JBQWtCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQTJCRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWFzamlkb3MvLi9ub2RlX21vZHVsZXMvQHZlcmNlbC9ibG9iL2Rpc3QvY2h1bmstRk42WEZINlIuanM/MWFlYSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvaGVscGVycy50c1xuaW1wb3J0IHsgaXNOb2RlUHJvY2VzcyB9IGZyb20gXCJpcy1ub2RlLXByb2Nlc3NcIjtcblxuLy8gc3JjL211bHRpcGFydC9oZWxwZXJzLnRzXG5pbXBvcnQgaXNCdWZmZXIgZnJvbSBcImlzLWJ1ZmZlclwiO1xuaW1wb3J0IHsgUmVhZGFibGUgfSBmcm9tIFwic3RyZWFtXCI7XG52YXIgc3VwcG9ydHNOZXdCbG9iRnJvbUFycmF5QnVmZmVyID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCBoZWxsb0FzQXJyYXlCdWZmZXIgPSBuZXcgVWludDhBcnJheShbMTA0LCAxMDEsIDEwOCwgMTA4LCAxMTFdKTtcbiAgICBjb25zdCBibG9iID0gbmV3IEJsb2IoW2hlbGxvQXNBcnJheUJ1ZmZlcl0pO1xuICAgIGJsb2IudGV4dCgpLnRoZW4oKHRleHQpID0+IHtcbiAgICAgIHJlc29sdmUodGV4dCA9PT0gXCJoZWxsb1wiKTtcbiAgICB9KS5jYXRjaCgoKSA9PiB7XG4gICAgICByZXNvbHZlKGZhbHNlKTtcbiAgICB9KTtcbiAgfSBjYXRjaCB7XG4gICAgcmVzb2x2ZShmYWxzZSk7XG4gIH1cbn0pO1xuYXN5bmMgZnVuY3Rpb24gdG9SZWFkYWJsZVN0cmVhbSh2YWx1ZSkge1xuICBpZiAodmFsdWUgaW5zdGFuY2VvZiBSZWFkYWJsZVN0cmVhbSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAodmFsdWUgaW5zdGFuY2VvZiBCbG9iKSB7XG4gICAgcmV0dXJuIHZhbHVlLnN0cmVhbSgpO1xuICB9XG4gIGlmIChpc05vZGVKc1JlYWRhYmxlU3RyZWFtKHZhbHVlKSkge1xuICAgIHJldHVybiBSZWFkYWJsZS50b1dlYih2YWx1ZSk7XG4gIH1cbiAgbGV0IHN0cmVhbVZhbHVlO1xuICBpZiAodmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHN0cmVhbVZhbHVlID0gbmV3IFVpbnQ4QXJyYXkodmFsdWUpO1xuICB9IGVsc2UgaWYgKGlzTm9kZUpzQnVmZmVyKHZhbHVlKSkge1xuICAgIHN0cmVhbVZhbHVlID0gdmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgc3RyZWFtVmFsdWUgPSBzdHJpbmdUb1VpbnQ4QXJyYXkodmFsdWUpO1xuICB9XG4gIGlmIChhd2FpdCBzdXBwb3J0c05ld0Jsb2JGcm9tQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gbmV3IEJsb2IoW3N0cmVhbVZhbHVlXSkuc3RyZWFtKCk7XG4gIH1cbiAgcmV0dXJuIG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgc3RhcnQoY29udHJvbGxlcikge1xuICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHN0cmVhbVZhbHVlKTtcbiAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gaXNOb2RlSnNSZWFkYWJsZVN0cmVhbSh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiB2YWx1ZS5waXBlID09PSBcImZ1bmN0aW9uXCIgJiYgdmFsdWUucmVhZGFibGUgJiYgdHlwZW9mIHZhbHVlLl9yZWFkID09PSBcImZ1bmN0aW9uXCIgJiYgLy8gQHRzLWV4cGVjdC1lcnJvciBfcmVhZGFibGVTdGF0ZSBkb2VzIGV4aXN0cyBvbiBSZWFkYWJsZVxuICB0eXBlb2YgdmFsdWUuX3JlYWRhYmxlU3RhdGUgPT09IFwib2JqZWN0XCI7XG59XG5mdW5jdGlvbiBzdHJpbmdUb1VpbnQ4QXJyYXkocykge1xuICBjb25zdCBlbmMgPSBuZXcgVGV4dEVuY29kZXIoKTtcbiAgcmV0dXJuIGVuYy5lbmNvZGUocyk7XG59XG5mdW5jdGlvbiBpc05vZGVKc0J1ZmZlcih2YWx1ZSkge1xuICByZXR1cm4gaXNCdWZmZXIodmFsdWUpO1xufVxuXG4vLyBzcmMvYnl0ZXMudHNcbnZhciBwYXJzZVJlZ0V4cCA9IC9eKCgtfFxcKyk/KFxcZCsoPzpcXC5cXGQrKT8pKSAqKGtifG1ifGdifHRifHBiKSQvaTtcbnZhciBtYXAgPSB7XG4gIGI6IDEsXG4gIGtiOiAxIDw8IDEwLFxuICBtYjogMSA8PCAyMCxcbiAgZ2I6IDEgPDwgMzAsXG4gIHRiOiAxMDI0ICoqIDQsXG4gIHBiOiAxMDI0ICoqIDVcbn07XG5mdW5jdGlvbiBieXRlcyh2YWwpIHtcbiAgaWYgKHR5cGVvZiB2YWwgPT09IFwibnVtYmVyXCIgJiYgIU51bWJlci5pc05hTih2YWwpKSB7XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuICBpZiAodHlwZW9mIHZhbCAhPT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IHJlc3VsdHMgPSBwYXJzZVJlZ0V4cC5leGVjKHZhbCk7XG4gIGxldCBmbG9hdFZhbHVlO1xuICBsZXQgdW5pdCA9IFwiYlwiO1xuICBpZiAoIXJlc3VsdHMpIHtcbiAgICBmbG9hdFZhbHVlID0gcGFyc2VJbnQodmFsLCAxMCk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgWywgcmVzLCAsICwgdW5pdE1hdGNoXSA9IHJlc3VsdHM7XG4gICAgaWYgKCFyZXMpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBmbG9hdFZhbHVlID0gcGFyc2VGbG9hdChyZXMpO1xuICAgIGlmICh1bml0TWF0Y2gpIHtcbiAgICAgIHVuaXQgPSB1bml0TWF0Y2gudG9Mb3dlckNhc2UoKTtcbiAgICB9XG4gIH1cbiAgaWYgKE51bWJlci5pc05hTihmbG9hdFZhbHVlKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBNYXRoLmZsb29yKG1hcFt1bml0XSAqIGZsb2F0VmFsdWUpO1xufVxuXG4vLyBzcmMvaGVscGVycy50c1xudmFyIGRlZmF1bHRWZXJjZWxCbG9iQXBpVXJsID0gXCJodHRwczovL3ZlcmNlbC5jb20vYXBpL2Jsb2JcIjtcbmZ1bmN0aW9uIGdldFRva2VuRnJvbU9wdGlvbnNPckVudihvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLnRva2VuKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMudG9rZW47XG4gIH1cbiAgaWYgKHByb2Nlc3MuZW52LkJMT0JfUkVBRF9XUklURV9UT0tFTikge1xuICAgIHJldHVybiBwcm9jZXNzLmVudi5CTE9CX1JFQURfV1JJVEVfVE9LRU47XG4gIH1cbiAgdGhyb3cgbmV3IEJsb2JFcnJvcihcbiAgICBcIk5vIHRva2VuIGZvdW5kLiBFaXRoZXIgY29uZmlndXJlIHRoZSBgQkxPQl9SRUFEX1dSSVRFX1RPS0VOYCBlbnZpcm9ubWVudCB2YXJpYWJsZSwgb3IgcGFzcyBhIGB0b2tlbmAgb3B0aW9uIHRvIHlvdXIgY2FsbHMuXCJcbiAgKTtcbn1cbnZhciBCbG9iRXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgIHN1cGVyKGBWZXJjZWwgQmxvYjogJHttZXNzYWdlfWApO1xuICB9XG59O1xuZnVuY3Rpb24gZ2V0RG93bmxvYWRVcmwoYmxvYlVybCkge1xuICBjb25zdCB1cmwgPSBuZXcgVVJMKGJsb2JVcmwpO1xuICB1cmwuc2VhcmNoUGFyYW1zLnNldChcImRvd25sb2FkXCIsIFwiMVwiKTtcbiAgcmV0dXJuIHVybC50b1N0cmluZygpO1xufVxuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiIHx8IHZhbHVlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IHByb3RvdHlwZSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWx1ZSk7XG4gIHJldHVybiAocHJvdG90eXBlID09PSBudWxsIHx8IHByb3RvdHlwZSA9PT0gT2JqZWN0LnByb3RvdHlwZSB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YocHJvdG90eXBlKSA9PT0gbnVsbCkgJiYgIShTeW1ib2wudG9TdHJpbmdUYWcgaW4gdmFsdWUpICYmICEoU3ltYm9sLml0ZXJhdG9yIGluIHZhbHVlKTtcbn1cbnZhciBkaXNhbGxvd2VkUGF0aG5hbWVDaGFyYWN0ZXJzID0gW1wiLy9cIl07XG52YXIgc3VwcG9ydHNSZXF1ZXN0U3RyZWFtcyA9ICgoKSA9PiB7XG4gIGlmIChpc05vZGVQcm9jZXNzKCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjb25zdCBhcGlVcmwgPSBnZXRBcGlVcmwoKTtcbiAgaWYgKGFwaVVybC5zdGFydHNXaXRoKFwiaHR0cDovL2xvY2FsaG9zdFwiKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBsZXQgZHVwbGV4QWNjZXNzZWQgPSBmYWxzZTtcbiAgY29uc3QgaGFzQ29udGVudFR5cGUgPSBuZXcgUmVxdWVzdChnZXRBcGlVcmwoKSwge1xuICAgIGJvZHk6IG5ldyBSZWFkYWJsZVN0cmVhbSgpLFxuICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciAtLSBUeXBlU2NyaXB0IGRvZXNuJ3QgeWV0IGhhdmUgZHVwbGV4IGJ1dCBpdCdzIGluIHRoZSBzcGVjOiBodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L1R5cGVTY3JpcHQtRE9NLWxpYi1nZW5lcmF0b3IvcHVsbC8xNzI5XG4gICAgZ2V0IGR1cGxleCgpIHtcbiAgICAgIGR1cGxleEFjY2Vzc2VkID0gdHJ1ZTtcbiAgICAgIHJldHVybiBcImhhbGZcIjtcbiAgICB9XG4gIH0pLmhlYWRlcnMuaGFzKFwiQ29udGVudC1UeXBlXCIpO1xuICByZXR1cm4gZHVwbGV4QWNjZXNzZWQgJiYgIWhhc0NvbnRlbnRUeXBlO1xufSkoKTtcbmZ1bmN0aW9uIGdldEFwaVVybChwYXRobmFtZSA9IFwiXCIpIHtcbiAgbGV0IGJhc2VVcmwgPSBudWxsO1xuICB0cnkge1xuICAgIGJhc2VVcmwgPSBwcm9jZXNzLmVudi5WRVJDRUxfQkxPQl9BUElfVVJMIHx8IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1ZFUkNFTF9CTE9CX0FQSV9VUkw7XG4gIH0gY2F0Y2gge1xuICB9XG4gIHJldHVybiBgJHtiYXNlVXJsIHx8IGRlZmF1bHRWZXJjZWxCbG9iQXBpVXJsfSR7cGF0aG5hbWV9YDtcbn1cbnZhciBURVhUX0VOQ09ERVIgPSB0eXBlb2YgVGV4dEVuY29kZXIgPT09IFwiZnVuY3Rpb25cIiA/IG5ldyBUZXh0RW5jb2RlcigpIDogbnVsbDtcbmZ1bmN0aW9uIGNvbXB1dGVCb2R5TGVuZ3RoKGJvZHkpIHtcbiAgaWYgKCFib2R5KSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgaWYgKHR5cGVvZiBib2R5ID09PSBcInN0cmluZ1wiKSB7XG4gICAgaWYgKFRFWFRfRU5DT0RFUikge1xuICAgICAgcmV0dXJuIFRFWFRfRU5DT0RFUi5lbmNvZGUoYm9keSkuYnl0ZUxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBCbG9iKFtib2R5XSkuc2l6ZTtcbiAgfVxuICBpZiAoXCJieXRlTGVuZ3RoXCIgaW4gYm9keSAmJiB0eXBlb2YgYm9keS5ieXRlTGVuZ3RoID09PSBcIm51bWJlclwiKSB7XG4gICAgcmV0dXJuIGJvZHkuYnl0ZUxlbmd0aDtcbiAgfVxuICBpZiAoXCJzaXplXCIgaW4gYm9keSAmJiB0eXBlb2YgYm9keS5zaXplID09PSBcIm51bWJlclwiKSB7XG4gICAgcmV0dXJuIGJvZHkuc2l6ZTtcbiAgfVxuICByZXR1cm4gMDtcbn1cbnZhciBjcmVhdGVDaHVua1RyYW5zZm9ybVN0cmVhbSA9IChjaHVua1NpemUsIG9uUHJvZ3Jlc3MpID0+IHtcbiAgbGV0IGJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KDApO1xuICByZXR1cm4gbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgdHJhbnNmb3JtKGNodW5rLCBjb250cm9sbGVyKSB7XG4gICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG4gICAgICAgIGNvbnN0IG5ld0J1ZmZlciA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlci5sZW5ndGggKyBjaHVuay5ieXRlTGVuZ3RoKTtcbiAgICAgICAgbmV3QnVmZmVyLnNldChidWZmZXIpO1xuICAgICAgICBuZXdCdWZmZXIuc2V0KG5ldyBVaW50OEFycmF5KGNodW5rKSwgYnVmZmVyLmxlbmd0aCk7XG4gICAgICAgIGJ1ZmZlciA9IG5ld0J1ZmZlcjtcbiAgICAgICAgd2hpbGUgKGJ1ZmZlci5sZW5ndGggPj0gY2h1bmtTaXplKSB7XG4gICAgICAgICAgY29uc3QgbmV3Q2h1bmsgPSBidWZmZXIuc2xpY2UoMCwgY2h1bmtTaXplKTtcbiAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUobmV3Q2h1bmspO1xuICAgICAgICAgIG9uUHJvZ3Jlc3MgPT0gbnVsbCA/IHZvaWQgMCA6IG9uUHJvZ3Jlc3MobmV3Q2h1bmsuYnl0ZUxlbmd0aCk7XG4gICAgICAgICAgYnVmZmVyID0gYnVmZmVyLnNsaWNlKGNodW5rU2l6ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sXG4gICAgZmx1c2goY29udHJvbGxlcikge1xuICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgICBpZiAoYnVmZmVyLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoYnVmZmVyKTtcbiAgICAgICAgICBvblByb2dyZXNzID09IG51bGwgPyB2b2lkIDAgOiBvblByb2dyZXNzKGJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbn07XG5mdW5jdGlvbiBpc1JlYWRhYmxlU3RyZWFtKHZhbHVlKSB7XG4gIHJldHVybiBnbG9iYWxUaGlzLlJlYWRhYmxlU3RyZWFtICYmIC8vIFRPRE86IENhbiBiZSByZW1vdmVkIG9uY2UgTm9kZS5qcyAxNiBpcyBubyBtb3JlIHJlcXVpcmVkIGludGVybmFsbHlcbiAgdmFsdWUgaW5zdGFuY2VvZiBSZWFkYWJsZVN0cmVhbTtcbn1cbmZ1bmN0aW9uIGlzU3RyZWFtKHZhbHVlKSB7XG4gIGlmIChpc1JlYWRhYmxlU3RyZWFtKHZhbHVlKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChpc05vZGVKc1JlYWRhYmxlU3RyZWFtKHZhbHVlKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLy8gc3JjL2FwaS50c1xuaW1wb3J0IHJldHJ5IGZyb20gXCJhc3luYy1yZXRyeVwiO1xuXG4vLyBzcmMvZGVidWcudHNcbnZhciBkZWJ1Z0lzQWN0aXZlID0gZmFsc2U7XG52YXIgX2EsIF9iO1xudHJ5IHtcbiAgaWYgKCgoX2EgPSBwcm9jZXNzLmVudi5ERUJVRykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmluY2x1ZGVzKFwiYmxvYlwiKSkgfHwgKChfYiA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0RFQlVHKSA9PSBudWxsID8gdm9pZCAwIDogX2IuaW5jbHVkZXMoXCJibG9iXCIpKSkge1xuICAgIGRlYnVnSXNBY3RpdmUgPSB0cnVlO1xuICB9XG59IGNhdGNoIHtcbn1cbmZ1bmN0aW9uIGRlYnVnKG1lc3NhZ2UsIC4uLmFyZ3MpIHtcbiAgaWYgKGRlYnVnSXNBY3RpdmUpIHtcbiAgICBjb25zb2xlLmRlYnVnKGB2ZXJjZWwtYmxvYjogJHttZXNzYWdlfWAsIC4uLmFyZ3MpO1xuICB9XG59XG5cbi8vIHNyYy9kb20tZXhjZXB0aW9uLnRzXG52YXIgX2EyO1xudmFyIERPTUV4Y2VwdGlvbjIgPSAoX2EyID0gZ2xvYmFsVGhpcy5ET01FeGNlcHRpb24pICE9IG51bGwgPyBfYTIgOiAoKCkgPT4ge1xuICB0cnkge1xuICAgIGF0b2IoXCJ+XCIpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gT2JqZWN0LmdldFByb3RvdHlwZU9mKGVycikuY29uc3RydWN0b3I7XG4gIH1cbn0pKCk7XG5cbi8vIHNyYy9pcy1uZXR3b3JrLWVycm9yLnRzXG52YXIgb2JqZWN0VG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIGlzRXJyb3IgPSAodmFsdWUpID0+IG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpID09PSBcIltvYmplY3QgRXJyb3JdXCI7XG52YXIgZXJyb3JNZXNzYWdlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcbiAgXCJuZXR3b3JrIGVycm9yXCIsXG4gIC8vIENocm9tZVxuICBcIkZhaWxlZCB0byBmZXRjaFwiLFxuICAvLyBDaHJvbWVcbiAgXCJOZXR3b3JrRXJyb3Igd2hlbiBhdHRlbXB0aW5nIHRvIGZldGNoIHJlc291cmNlLlwiLFxuICAvLyBGaXJlZm94XG4gIFwiVGhlIEludGVybmV0IGNvbm5lY3Rpb24gYXBwZWFycyB0byBiZSBvZmZsaW5lLlwiLFxuICAvLyBTYWZhcmkgMTZcbiAgXCJMb2FkIGZhaWxlZFwiLFxuICAvLyBTYWZhcmkgMTcrXG4gIFwiTmV0d29yayByZXF1ZXN0IGZhaWxlZFwiLFxuICAvLyBgY3Jvc3MtZmV0Y2hgXG4gIFwiZmV0Y2ggZmFpbGVkXCIsXG4gIC8vIFVuZGljaSAoTm9kZS5qcylcbiAgXCJ0ZXJtaW5hdGVkXCJcbiAgLy8gVW5kaWNpIChOb2RlLmpzKVxuXSk7XG5mdW5jdGlvbiBpc05ldHdvcmtFcnJvcihlcnJvcikge1xuICBjb25zdCBpc1ZhbGlkID0gZXJyb3IgJiYgaXNFcnJvcihlcnJvcikgJiYgZXJyb3IubmFtZSA9PT0gXCJUeXBlRXJyb3JcIiAmJiB0eXBlb2YgZXJyb3IubWVzc2FnZSA9PT0gXCJzdHJpbmdcIjtcbiAgaWYgKCFpc1ZhbGlkKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChlcnJvci5tZXNzYWdlID09PSBcIkxvYWQgZmFpbGVkXCIpIHtcbiAgICByZXR1cm4gZXJyb3Iuc3RhY2sgPT09IHZvaWQgMDtcbiAgfVxuICByZXR1cm4gZXJyb3JNZXNzYWdlcy5oYXMoZXJyb3IubWVzc2FnZSk7XG59XG5cbi8vIHNyYy9mZXRjaC50c1xuaW1wb3J0IHsgZmV0Y2ggfSBmcm9tIFwidW5kaWNpXCI7XG52YXIgaGFzRmV0Y2ggPSB0eXBlb2YgZmV0Y2ggPT09IFwiZnVuY3Rpb25cIjtcbnZhciBoYXNGZXRjaFdpdGhVcGxvYWRQcm9ncmVzcyA9IGhhc0ZldGNoICYmIHN1cHBvcnRzUmVxdWVzdFN0cmVhbXM7XG52YXIgQ0hVTktfU0laRSA9IDY0ICogMTAyNDtcbnZhciBibG9iRmV0Y2ggPSBhc3luYyAoe1xuICBpbnB1dCxcbiAgaW5pdCxcbiAgb25VcGxvYWRQcm9ncmVzc1xufSkgPT4ge1xuICBkZWJ1ZyhcInVzaW5nIGZldGNoXCIpO1xuICBsZXQgYm9keTtcbiAgaWYgKGluaXQuYm9keSkge1xuICAgIGlmIChvblVwbG9hZFByb2dyZXNzKSB7XG4gICAgICBjb25zdCBzdHJlYW0gPSBhd2FpdCB0b1JlYWRhYmxlU3RyZWFtKGluaXQuYm9keSk7XG4gICAgICBsZXQgbG9hZGVkID0gMDtcbiAgICAgIGNvbnN0IGNodW5rVHJhbnNmb3JtU3RyZWFtID0gY3JlYXRlQ2h1bmtUcmFuc2Zvcm1TdHJlYW0oXG4gICAgICAgIENIVU5LX1NJWkUsXG4gICAgICAgIChuZXdMb2FkZWQpID0+IHtcbiAgICAgICAgICBsb2FkZWQgKz0gbmV3TG9hZGVkO1xuICAgICAgICAgIG9uVXBsb2FkUHJvZ3Jlc3MobG9hZGVkKTtcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICAgIGJvZHkgPSBzdHJlYW0ucGlwZVRocm91Z2goY2h1bmtUcmFuc2Zvcm1TdHJlYW0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBib2R5ID0gaW5pdC5ib2R5O1xuICAgIH1cbiAgfVxuICBjb25zdCBkdXBsZXggPSBzdXBwb3J0c1JlcXVlc3RTdHJlYW1zICYmIGJvZHkgJiYgaXNTdHJlYW0oYm9keSkgPyBcImhhbGZcIiA6IHZvaWQgMDtcbiAgcmV0dXJuIGZldGNoKFxuICAgIGlucHV0LFxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgLS0gQmxvYiBhbmQgTm9kZWpzIEJsb2IgYXJlIHRyaWdnZXJpbmcgdHlwZSBlcnJvcnMsIGZpbmUgd2l0aCBpdFxuICAgIHtcbiAgICAgIC4uLmluaXQsXG4gICAgICAuLi5pbml0LmJvZHkgPyB7IGJvZHkgfSA6IHt9LFxuICAgICAgZHVwbGV4XG4gICAgfVxuICApO1xufTtcblxuLy8gc3JjL3hoci50c1xudmFyIGhhc1hociA9IHR5cGVvZiBYTUxIdHRwUmVxdWVzdCAhPT0gXCJ1bmRlZmluZWRcIjtcbnZhciBibG9iWGhyID0gYXN5bmMgKHtcbiAgaW5wdXQsXG4gIGluaXQsXG4gIG9uVXBsb2FkUHJvZ3Jlc3Ncbn0pID0+IHtcbiAgZGVidWcoXCJ1c2luZyB4aHJcIik7XG4gIGxldCBib2R5ID0gbnVsbDtcbiAgaWYgKGluaXQuYm9keSkge1xuICAgIGlmIChpc1JlYWRhYmxlU3RyZWFtKGluaXQuYm9keSkpIHtcbiAgICAgIGJvZHkgPSBhd2FpdCBuZXcgUmVzcG9uc2UoaW5pdC5ib2R5KS5ibG9iKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJvZHkgPSBpbml0LmJvZHk7XG4gICAgfVxuICB9XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgY29uc3QgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgeGhyLm9wZW4oaW5pdC5tZXRob2QgfHwgXCJHRVRcIiwgaW5wdXQudG9TdHJpbmcoKSwgdHJ1ZSk7XG4gICAgaWYgKG9uVXBsb2FkUHJvZ3Jlc3MpIHtcbiAgICAgIHhoci51cGxvYWQuYWRkRXZlbnRMaXN0ZW5lcihcInByb2dyZXNzXCIsIChldmVudCkgPT4ge1xuICAgICAgICBpZiAoZXZlbnQubGVuZ3RoQ29tcHV0YWJsZSkge1xuICAgICAgICAgIG9uVXBsb2FkUHJvZ3Jlc3MoZXZlbnQubG9hZGVkKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHhoci5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICB2YXIgX2EzO1xuICAgICAgaWYgKChfYTMgPSBpbml0LnNpZ25hbCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMy5hYm9ydGVkKSB7XG4gICAgICAgIHJlamVjdChuZXcgRE9NRXhjZXB0aW9uKFwiVGhlIHVzZXIgYWJvcnRlZCB0aGUgcmVxdWVzdC5cIiwgXCJBYm9ydEVycm9yXCIpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgaGVhZGVycyA9IG5ldyBIZWFkZXJzKCk7XG4gICAgICBjb25zdCByYXdIZWFkZXJzID0geGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpLnRyaW0oKS5zcGxpdCgvW1xcclxcbl0rLyk7XG4gICAgICByYXdIZWFkZXJzLmZvckVhY2goKGxpbmUpID0+IHtcbiAgICAgICAgY29uc3QgcGFydHMgPSBsaW5lLnNwbGl0KFwiOiBcIik7XG4gICAgICAgIGNvbnN0IGtleSA9IHBhcnRzLnNoaWZ0KCk7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gcGFydHMuam9pbihcIjogXCIpO1xuICAgICAgICBpZiAoa2V5KSBoZWFkZXJzLnNldChrZXkudG9Mb3dlckNhc2UoKSwgdmFsdWUpO1xuICAgICAgfSk7XG4gICAgICBjb25zdCByZXNwb25zZSA9IG5ldyBSZXNwb25zZSh4aHIucmVzcG9uc2UsIHtcbiAgICAgICAgc3RhdHVzOiB4aHIuc3RhdHVzLFxuICAgICAgICBzdGF0dXNUZXh0OiB4aHIuc3RhdHVzVGV4dCxcbiAgICAgICAgaGVhZGVyc1xuICAgICAgfSk7XG4gICAgICByZXNvbHZlKHJlc3BvbnNlKTtcbiAgICB9O1xuICAgIHhoci5vbmVycm9yID0gKCkgPT4ge1xuICAgICAgcmVqZWN0KG5ldyBUeXBlRXJyb3IoXCJOZXR3b3JrIHJlcXVlc3QgZmFpbGVkXCIpKTtcbiAgICB9O1xuICAgIHhoci5vbnRpbWVvdXQgPSAoKSA9PiB7XG4gICAgICByZWplY3QobmV3IFR5cGVFcnJvcihcIk5ldHdvcmsgcmVxdWVzdCB0aW1lZCBvdXRcIikpO1xuICAgIH07XG4gICAgeGhyLm9uYWJvcnQgPSAoKSA9PiB7XG4gICAgICByZWplY3QobmV3IERPTUV4Y2VwdGlvbihcIlRoZSB1c2VyIGFib3J0ZWQgYSByZXF1ZXN0LlwiLCBcIkFib3J0RXJyb3JcIikpO1xuICAgIH07XG4gICAgaWYgKGluaXQuaGVhZGVycykge1xuICAgICAgY29uc3QgaGVhZGVycyA9IG5ldyBIZWFkZXJzKGluaXQuaGVhZGVycyk7XG4gICAgICBoZWFkZXJzLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoa2V5LCB2YWx1ZSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGluaXQuc2lnbmFsKSB7XG4gICAgICBpbml0LnNpZ25hbC5hZGRFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgKCkgPT4ge1xuICAgICAgICB4aHIuYWJvcnQoKTtcbiAgICAgIH0pO1xuICAgICAgaWYgKGluaXQuc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgeGhyLmFib3J0KCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgeGhyLnNlbmQoYm9keSk7XG4gIH0pO1xufTtcblxuLy8gc3JjL3JlcXVlc3QudHNcbnZhciBibG9iUmVxdWVzdCA9IGFzeW5jICh7XG4gIGlucHV0LFxuICBpbml0LFxuICBvblVwbG9hZFByb2dyZXNzXG59KSA9PiB7XG4gIGlmIChvblVwbG9hZFByb2dyZXNzKSB7XG4gICAgaWYgKGhhc0ZldGNoV2l0aFVwbG9hZFByb2dyZXNzKSB7XG4gICAgICByZXR1cm4gYmxvYkZldGNoKHsgaW5wdXQsIGluaXQsIG9uVXBsb2FkUHJvZ3Jlc3MgfSk7XG4gICAgfVxuICAgIGlmIChoYXNYaHIpIHtcbiAgICAgIHJldHVybiBibG9iWGhyKHsgaW5wdXQsIGluaXQsIG9uVXBsb2FkUHJvZ3Jlc3MgfSk7XG4gICAgfVxuICB9XG4gIGlmIChoYXNGZXRjaCkge1xuICAgIHJldHVybiBibG9iRmV0Y2goeyBpbnB1dCwgaW5pdCB9KTtcbiAgfVxuICBpZiAoaGFzWGhyKSB7XG4gICAgcmV0dXJuIGJsb2JYaHIoeyBpbnB1dCwgaW5pdCB9KTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXCJObyByZXF1ZXN0IGltcGxlbWVudGF0aW9uIGF2YWlsYWJsZVwiKTtcbn07XG5cbi8vIHNyYy9hcGkudHNcbnZhciBNQVhJTVVNX1BBVEhOQU1FX0xFTkdUSCA9IDk1MDtcbnZhciBCbG9iQWNjZXNzRXJyb3IgPSBjbGFzcyBleHRlbmRzIEJsb2JFcnJvciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKFwiQWNjZXNzIGRlbmllZCwgcGxlYXNlIHByb3ZpZGUgYSB2YWxpZCB0b2tlbiBmb3IgdGhpcyByZXNvdXJjZS5cIik7XG4gIH1cbn07XG52YXIgQmxvYkNvbnRlbnRUeXBlTm90QWxsb3dlZEVycm9yID0gY2xhc3MgZXh0ZW5kcyBCbG9iRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgc3VwZXIoYENvbnRlbnQgdHlwZSBtaXNtYXRjaCwgJHttZXNzYWdlfS5gKTtcbiAgfVxufTtcbnZhciBCbG9iUGF0aG5hbWVNaXNtYXRjaEVycm9yID0gY2xhc3MgZXh0ZW5kcyBCbG9iRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgc3VwZXIoXG4gICAgICBgUGF0aG5hbWUgbWlzbWF0Y2gsICR7bWVzc2FnZX0uIENoZWNrIHRoZSBwYXRobmFtZSB1c2VkIGluIHVwbG9hZCgpIG9yIHB1dCgpIG1hdGNoZXMgdGhlIG9uZSBmcm9tIHRoZSBjbGllbnQgdG9rZW4uYFxuICAgICk7XG4gIH1cbn07XG52YXIgQmxvYkNsaWVudFRva2VuRXhwaXJlZEVycm9yID0gY2xhc3MgZXh0ZW5kcyBCbG9iRXJyb3Ige1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihcIkNsaWVudCB0b2tlbiBoYXMgZXhwaXJlZC5cIik7XG4gIH1cbn07XG52YXIgQmxvYkZpbGVUb29MYXJnZUVycm9yID0gY2xhc3MgZXh0ZW5kcyBCbG9iRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgc3VwZXIoYEZpbGUgaXMgdG9vIGxhcmdlLCAke21lc3NhZ2V9LmApO1xuICB9XG59O1xudmFyIEJsb2JTdG9yZU5vdEZvdW5kRXJyb3IgPSBjbGFzcyBleHRlbmRzIEJsb2JFcnJvciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKFwiVGhpcyBzdG9yZSBkb2VzIG5vdCBleGlzdC5cIik7XG4gIH1cbn07XG52YXIgQmxvYlN0b3JlU3VzcGVuZGVkRXJyb3IgPSBjbGFzcyBleHRlbmRzIEJsb2JFcnJvciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKFwiVGhpcyBzdG9yZSBoYXMgYmVlbiBzdXNwZW5kZWQuXCIpO1xuICB9XG59O1xudmFyIEJsb2JVbmtub3duRXJyb3IgPSBjbGFzcyBleHRlbmRzIEJsb2JFcnJvciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKFwiVW5rbm93biBlcnJvciwgcGxlYXNlIHZpc2l0IGh0dHBzOi8vdmVyY2VsLmNvbS9oZWxwLlwiKTtcbiAgfVxufTtcbnZhciBCbG9iTm90Rm91bmRFcnJvciA9IGNsYXNzIGV4dGVuZHMgQmxvYkVycm9yIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoXCJUaGUgcmVxdWVzdGVkIGJsb2IgZG9lcyBub3QgZXhpc3RcIik7XG4gIH1cbn07XG52YXIgQmxvYlNlcnZpY2VOb3RBdmFpbGFibGUgPSBjbGFzcyBleHRlbmRzIEJsb2JFcnJvciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKFwiVGhlIGJsb2Igc2VydmljZSBpcyBjdXJyZW50bHkgbm90IGF2YWlsYWJsZS4gUGxlYXNlIHRyeSBhZ2Fpbi5cIik7XG4gIH1cbn07XG52YXIgQmxvYlNlcnZpY2VSYXRlTGltaXRlZCA9IGNsYXNzIGV4dGVuZHMgQmxvYkVycm9yIHtcbiAgY29uc3RydWN0b3Ioc2Vjb25kcykge1xuICAgIHN1cGVyKFxuICAgICAgYFRvbyBtYW55IHJlcXVlc3RzIHBsZWFzZSBsb3dlciB0aGUgbnVtYmVyIG9mIGNvbmN1cnJlbnQgcmVxdWVzdHMgJHtzZWNvbmRzID8gYCAtIHRyeSBhZ2FpbiBpbiAke3NlY29uZHN9IHNlY29uZHNgIDogXCJcIn0uYFxuICAgICk7XG4gICAgdGhpcy5yZXRyeUFmdGVyID0gc2Vjb25kcyAhPSBudWxsID8gc2Vjb25kcyA6IDA7XG4gIH1cbn07XG52YXIgQmxvYlJlcXVlc3RBYm9ydGVkRXJyb3IgPSBjbGFzcyBleHRlbmRzIEJsb2JFcnJvciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKFwiVGhlIHJlcXVlc3Qgd2FzIGFib3J0ZWQuXCIpO1xuICB9XG59O1xudmFyIEJMT0JfQVBJX1ZFUlNJT04gPSAxMTtcbmZ1bmN0aW9uIGdldEFwaVZlcnNpb24oKSB7XG4gIGxldCB2ZXJzaW9uT3ZlcnJpZGUgPSBudWxsO1xuICB0cnkge1xuICAgIHZlcnNpb25PdmVycmlkZSA9IHByb2Nlc3MuZW52LlZFUkNFTF9CTE9CX0FQSV9WRVJTSU9OX09WRVJSSURFIHx8IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1ZFUkNFTF9CTE9CX0FQSV9WRVJTSU9OX09WRVJSSURFO1xuICB9IGNhdGNoIHtcbiAgfVxuICByZXR1cm4gYCR7dmVyc2lvbk92ZXJyaWRlICE9IG51bGwgPyB2ZXJzaW9uT3ZlcnJpZGUgOiBCTE9CX0FQSV9WRVJTSU9OfWA7XG59XG5mdW5jdGlvbiBnZXRSZXRyaWVzKCkge1xuICB0cnkge1xuICAgIGNvbnN0IHJldHJpZXMgPSBwcm9jZXNzLmVudi5WRVJDRUxfQkxPQl9SRVRSSUVTIHx8IFwiMTBcIjtcbiAgICByZXR1cm4gcGFyc2VJbnQocmV0cmllcywgMTApO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gMTA7XG4gIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZUJsb2JTZXJ2aWNlUmF0ZUxpbWl0ZWQocmVzcG9uc2UpIHtcbiAgY29uc3QgcmV0cnlBZnRlciA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwicmV0cnktYWZ0ZXJcIik7XG4gIHJldHVybiBuZXcgQmxvYlNlcnZpY2VSYXRlTGltaXRlZChcbiAgICByZXRyeUFmdGVyID8gcGFyc2VJbnQocmV0cnlBZnRlciwgMTApIDogdm9pZCAwXG4gICk7XG59XG5hc3luYyBmdW5jdGlvbiBnZXRCbG9iRXJyb3IocmVzcG9uc2UpIHtcbiAgdmFyIF9hMywgX2IyLCBfYztcbiAgbGV0IGNvZGU7XG4gIGxldCBtZXNzYWdlO1xuICB0cnkge1xuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgY29kZSA9IChfYjIgPSAoX2EzID0gZGF0YS5lcnJvcikgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMy5jb2RlKSAhPSBudWxsID8gX2IyIDogXCJ1bmtub3duX2Vycm9yXCI7XG4gICAgbWVzc2FnZSA9IChfYyA9IGRhdGEuZXJyb3IpID09IG51bGwgPyB2b2lkIDAgOiBfYy5tZXNzYWdlO1xuICB9IGNhdGNoIHtcbiAgICBjb2RlID0gXCJ1bmtub3duX2Vycm9yXCI7XG4gIH1cbiAgaWYgKChtZXNzYWdlID09IG51bGwgPyB2b2lkIDAgOiBtZXNzYWdlLmluY2x1ZGVzKFwiY29udGVudFR5cGVcIikpICYmIG1lc3NhZ2UuaW5jbHVkZXMoXCJpcyBub3QgYWxsb3dlZFwiKSkge1xuICAgIGNvZGUgPSBcImNvbnRlbnRfdHlwZV9ub3RfYWxsb3dlZFwiO1xuICB9XG4gIGlmICgobWVzc2FnZSA9PSBudWxsID8gdm9pZCAwIDogbWVzc2FnZS5pbmNsdWRlcygnXCJwYXRobmFtZVwiJykpICYmIG1lc3NhZ2UuaW5jbHVkZXMoXCJkb2VzIG5vdCBtYXRjaCB0aGUgdG9rZW4gcGF5bG9hZFwiKSkge1xuICAgIGNvZGUgPSBcImNsaWVudF90b2tlbl9wYXRobmFtZV9taXNtYXRjaFwiO1xuICB9XG4gIGlmIChtZXNzYWdlID09PSBcIlRva2VuIGV4cGlyZWRcIikge1xuICAgIGNvZGUgPSBcImNsaWVudF90b2tlbl9leHBpcmVkXCI7XG4gIH1cbiAgaWYgKG1lc3NhZ2UgPT0gbnVsbCA/IHZvaWQgMCA6IG1lc3NhZ2UuaW5jbHVkZXMoXCJ0aGUgZmlsZSBsZW5ndGggY2Fubm90IGJlIGdyZWF0ZXIgdGhhblwiKSkge1xuICAgIGNvZGUgPSBcImZpbGVfdG9vX2xhcmdlXCI7XG4gIH1cbiAgbGV0IGVycm9yO1xuICBzd2l0Y2ggKGNvZGUpIHtcbiAgICBjYXNlIFwic3RvcmVfc3VzcGVuZGVkXCI6XG4gICAgICBlcnJvciA9IG5ldyBCbG9iU3RvcmVTdXNwZW5kZWRFcnJvcigpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImZvcmJpZGRlblwiOlxuICAgICAgZXJyb3IgPSBuZXcgQmxvYkFjY2Vzc0Vycm9yKCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiY29udGVudF90eXBlX25vdF9hbGxvd2VkXCI6XG4gICAgICBlcnJvciA9IG5ldyBCbG9iQ29udGVudFR5cGVOb3RBbGxvd2VkRXJyb3IobWVzc2FnZSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiY2xpZW50X3Rva2VuX3BhdGhuYW1lX21pc21hdGNoXCI6XG4gICAgICBlcnJvciA9IG5ldyBCbG9iUGF0aG5hbWVNaXNtYXRjaEVycm9yKG1lc3NhZ2UpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImNsaWVudF90b2tlbl9leHBpcmVkXCI6XG4gICAgICBlcnJvciA9IG5ldyBCbG9iQ2xpZW50VG9rZW5FeHBpcmVkRXJyb3IoKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJmaWxlX3Rvb19sYXJnZVwiOlxuICAgICAgZXJyb3IgPSBuZXcgQmxvYkZpbGVUb29MYXJnZUVycm9yKG1lc3NhZ2UpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIm5vdF9mb3VuZFwiOlxuICAgICAgZXJyb3IgPSBuZXcgQmxvYk5vdEZvdW5kRXJyb3IoKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJzdG9yZV9ub3RfZm91bmRcIjpcbiAgICAgIGVycm9yID0gbmV3IEJsb2JTdG9yZU5vdEZvdW5kRXJyb3IoKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJiYWRfcmVxdWVzdFwiOlxuICAgICAgZXJyb3IgPSBuZXcgQmxvYkVycm9yKG1lc3NhZ2UgIT0gbnVsbCA/IG1lc3NhZ2UgOiBcIkJhZCByZXF1ZXN0XCIpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcInNlcnZpY2VfdW5hdmFpbGFibGVcIjpcbiAgICAgIGVycm9yID0gbmV3IEJsb2JTZXJ2aWNlTm90QXZhaWxhYmxlKCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwicmF0ZV9saW1pdGVkXCI6XG4gICAgICBlcnJvciA9IGNyZWF0ZUJsb2JTZXJ2aWNlUmF0ZUxpbWl0ZWQocmVzcG9uc2UpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcInVua25vd25fZXJyb3JcIjpcbiAgICBjYXNlIFwibm90X2FsbG93ZWRcIjpcbiAgICBkZWZhdWx0OlxuICAgICAgZXJyb3IgPSBuZXcgQmxvYlVua25vd25FcnJvcigpO1xuICAgICAgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIHsgY29kZSwgZXJyb3IgfTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHJlcXVlc3RBcGkocGF0aG5hbWUsIGluaXQsIGNvbW1hbmRPcHRpb25zKSB7XG4gIGNvbnN0IGFwaVZlcnNpb24gPSBnZXRBcGlWZXJzaW9uKCk7XG4gIGNvbnN0IHRva2VuID0gZ2V0VG9rZW5Gcm9tT3B0aW9uc09yRW52KGNvbW1hbmRPcHRpb25zKTtcbiAgY29uc3QgZXh0cmFIZWFkZXJzID0gZ2V0UHJveHlUaHJvdWdoQWx0ZXJuYXRpdmVBcGlIZWFkZXJGcm9tRW52KCk7XG4gIGNvbnN0IFssICwgLCBzdG9yZUlkID0gXCJcIl0gPSB0b2tlbi5zcGxpdChcIl9cIik7XG4gIGNvbnN0IHJlcXVlc3RJZCA9IGAke3N0b3JlSWR9OiR7RGF0ZS5ub3coKX06JHtNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDE2KS5zbGljZSgyKX1gO1xuICBsZXQgcmV0cnlDb3VudCA9IDA7XG4gIGxldCBib2R5TGVuZ3RoID0gMDtcbiAgbGV0IHRvdGFsTG9hZGVkID0gMDtcbiAgY29uc3Qgc2VuZEJvZHlMZW5ndGggPSAoY29tbWFuZE9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IGNvbW1hbmRPcHRpb25zLm9uVXBsb2FkUHJvZ3Jlc3MpIHx8IHNob3VsZFVzZVhDb250ZW50TGVuZ3RoKCk7XG4gIGlmIChpbml0LmJvZHkgJiYgLy8gMS4gRm9yIHVwbG9hZCBwcm9ncmVzcyB3ZSBhbHdheXMgbmVlZCB0byBrbm93IHRoZSB0b3RhbCBzaXplIG9mIHRoZSBib2R5XG4gIC8vIDIuIEluIGRldmVsb3BtZW50IHdlIG5lZWQgdGhlIGhlYWRlciBmb3IgcHV0KCkgdG8gd29yayBjb3JyZWN0bHkgd2hlbiBwYXNzaW5nIGEgc3RyZWFtXG4gIHNlbmRCb2R5TGVuZ3RoKSB7XG4gICAgYm9keUxlbmd0aCA9IGNvbXB1dGVCb2R5TGVuZ3RoKGluaXQuYm9keSk7XG4gIH1cbiAgaWYgKGNvbW1hbmRPcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBjb21tYW5kT3B0aW9ucy5vblVwbG9hZFByb2dyZXNzKSB7XG4gICAgY29tbWFuZE9wdGlvbnMub25VcGxvYWRQcm9ncmVzcyh7XG4gICAgICBsb2FkZWQ6IDAsXG4gICAgICB0b3RhbDogYm9keUxlbmd0aCxcbiAgICAgIHBlcmNlbnRhZ2U6IDBcbiAgICB9KTtcbiAgfVxuICBjb25zdCBhcGlSZXNwb25zZSA9IGF3YWl0IHJldHJ5KFxuICAgIGFzeW5jIChiYWlsKSA9PiB7XG4gICAgICBsZXQgcmVzO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmVzID0gYXdhaXQgYmxvYlJlcXVlc3Qoe1xuICAgICAgICAgIGlucHV0OiBnZXRBcGlVcmwocGF0aG5hbWUpLFxuICAgICAgICAgIGluaXQ6IHtcbiAgICAgICAgICAgIC4uLmluaXQsXG4gICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgIFwieC1hcGktYmxvYi1yZXF1ZXN0LWlkXCI6IHJlcXVlc3RJZCxcbiAgICAgICAgICAgICAgXCJ4LWFwaS1ibG9iLXJlcXVlc3QtYXR0ZW1wdFwiOiBTdHJpbmcocmV0cnlDb3VudCksXG4gICAgICAgICAgICAgIFwieC1hcGktdmVyc2lvblwiOiBhcGlWZXJzaW9uLFxuICAgICAgICAgICAgICAuLi5zZW5kQm9keUxlbmd0aCA/IHsgXCJ4LWNvbnRlbnQtbGVuZ3RoXCI6IFN0cmluZyhib2R5TGVuZ3RoKSB9IDoge30sXG4gICAgICAgICAgICAgIGF1dGhvcml6YXRpb246IGBCZWFyZXIgJHt0b2tlbn1gLFxuICAgICAgICAgICAgICAuLi5leHRyYUhlYWRlcnMsXG4gICAgICAgICAgICAgIC4uLmluaXQuaGVhZGVyc1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgb25VcGxvYWRQcm9ncmVzczogKGNvbW1hbmRPcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBjb21tYW5kT3B0aW9ucy5vblVwbG9hZFByb2dyZXNzKSA/IChsb2FkZWQpID0+IHtcbiAgICAgICAgICAgIHZhciBfYTM7XG4gICAgICAgICAgICBjb25zdCB0b3RhbCA9IGJvZHlMZW5ndGggIT09IDAgPyBib2R5TGVuZ3RoIDogbG9hZGVkO1xuICAgICAgICAgICAgdG90YWxMb2FkZWQgPSBsb2FkZWQ7XG4gICAgICAgICAgICBjb25zdCBwZXJjZW50YWdlID0gYm9keUxlbmd0aCA+IDAgPyBOdW1iZXIoKGxvYWRlZCAvIHRvdGFsICogMTAwKS50b0ZpeGVkKDIpKSA6IDA7XG4gICAgICAgICAgICBpZiAocGVyY2VudGFnZSA9PT0gMTAwICYmIGJvZHlMZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIChfYTMgPSBjb21tYW5kT3B0aW9ucy5vblVwbG9hZFByb2dyZXNzKSA9PSBudWxsID8gdm9pZCAwIDogX2EzLmNhbGwoY29tbWFuZE9wdGlvbnMsIHtcbiAgICAgICAgICAgICAgbG9hZGVkLFxuICAgICAgICAgICAgICAvLyBXaGVuIHBhc3NpbmcgYSBzdHJlYW0gdG8gcHV0KCksIHdlIGhhdmUgbm8gd2F5IHRvIGtub3cgdGhlIHRvdGFsIHNpemUgb2YgdGhlIGJvZHkuXG4gICAgICAgICAgICAgIC8vIEluc3RlYWQgb2YgZGVmaW5pbmcgdG90YWwgYXMgdG90YWw/OiBudW1iZXIgd2UgZGVjaWRlZCB0byBzZXQgdGhlIHRvdGFsIHRvIHRoZSBjdXJyZW50bHlcbiAgICAgICAgICAgICAgLy8gbG9hZGVkIG51bWJlci4gVGhpcyBpcyBub3QgaW5hY2N1cmF0ZSBhbmQgd2F5IG1vcmUgcHJhY3RpY2FsIGZvciBEWC5cbiAgICAgICAgICAgICAgLy8gUGFzc2luZyBkb3duIGEgc3RyZWFtIHRvIHB1dCgpIGlzIHZlcnkgcmFyZVxuICAgICAgICAgICAgICB0b3RhbCxcbiAgICAgICAgICAgICAgcGVyY2VudGFnZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSA6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yMikge1xuICAgICAgICBpZiAoZXJyb3IyIGluc3RhbmNlb2YgRE9NRXhjZXB0aW9uMiAmJiBlcnJvcjIubmFtZSA9PT0gXCJBYm9ydEVycm9yXCIpIHtcbiAgICAgICAgICBiYWlsKG5ldyBCbG9iUmVxdWVzdEFib3J0ZWRFcnJvcigpKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTmV0d29ya0Vycm9yKGVycm9yMikpIHtcbiAgICAgICAgICB0aHJvdyBlcnJvcjI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVycm9yMiBpbnN0YW5jZW9mIFR5cGVFcnJvcikge1xuICAgICAgICAgIGJhaWwoZXJyb3IyKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZXJyb3IyO1xuICAgICAgfVxuICAgICAgaWYgKHJlcy5vaykge1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgfVxuICAgICAgY29uc3QgeyBjb2RlLCBlcnJvciB9ID0gYXdhaXQgZ2V0QmxvYkVycm9yKHJlcyk7XG4gICAgICBpZiAoY29kZSA9PT0gXCJ1bmtub3duX2Vycm9yXCIgfHwgY29kZSA9PT0gXCJzZXJ2aWNlX3VuYXZhaWxhYmxlXCIgfHwgY29kZSA9PT0gXCJpbnRlcm5hbF9zZXJ2ZXJfZXJyb3JcIikge1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICAgIGJhaWwoZXJyb3IpO1xuICAgIH0sXG4gICAge1xuICAgICAgcmV0cmllczogZ2V0UmV0cmllcygpLFxuICAgICAgb25SZXRyeTogKGVycm9yKSA9PiB7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgZGVidWcoYHJldHJ5aW5nIEFQSSByZXF1ZXN0IHRvICR7cGF0aG5hbWV9YCwgZXJyb3IubWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0cnlDb3VudCA9IHJldHJ5Q291bnQgKyAxO1xuICAgICAgfVxuICAgIH1cbiAgKTtcbiAgaWYgKCFhcGlSZXNwb25zZSkge1xuICAgIHRocm93IG5ldyBCbG9iVW5rbm93bkVycm9yKCk7XG4gIH1cbiAgaWYgKGNvbW1hbmRPcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBjb21tYW5kT3B0aW9ucy5vblVwbG9hZFByb2dyZXNzKSB7XG4gICAgY29tbWFuZE9wdGlvbnMub25VcGxvYWRQcm9ncmVzcyh7XG4gICAgICBsb2FkZWQ6IHRvdGFsTG9hZGVkLFxuICAgICAgdG90YWw6IHRvdGFsTG9hZGVkLFxuICAgICAgcGVyY2VudGFnZTogMTAwXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGF3YWl0IGFwaVJlc3BvbnNlLmpzb24oKTtcbn1cbmZ1bmN0aW9uIGdldFByb3h5VGhyb3VnaEFsdGVybmF0aXZlQXBpSGVhZGVyRnJvbUVudigpIHtcbiAgY29uc3QgZXh0cmFIZWFkZXJzID0ge307XG4gIHRyeSB7XG4gICAgaWYgKFwiVkVSQ0VMX0JMT0JfUFJPWFlfVEhST1VHSF9BTFRFUk5BVElWRV9BUElcIiBpbiBwcm9jZXNzLmVudiAmJiBwcm9jZXNzLmVudi5WRVJDRUxfQkxPQl9QUk9YWV9USFJPVUdIX0FMVEVSTkFUSVZFX0FQSSAhPT0gdm9pZCAwKSB7XG4gICAgICBleHRyYUhlYWRlcnNbXCJ4LXByb3h5LXRocm91Z2gtYWx0ZXJuYXRpdmUtYXBpXCJdID0gcHJvY2Vzcy5lbnYuVkVSQ0VMX0JMT0JfUFJPWFlfVEhST1VHSF9BTFRFUk5BVElWRV9BUEk7XG4gICAgfSBlbHNlIGlmIChcIk5FWFRfUFVCTElDX1ZFUkNFTF9CTE9CX1BST1hZX1RIUk9VR0hfQUxURVJOQVRJVkVfQVBJXCIgaW4gcHJvY2Vzcy5lbnYgJiYgcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfVkVSQ0VMX0JMT0JfUFJPWFlfVEhST1VHSF9BTFRFUk5BVElWRV9BUEkgIT09IHZvaWQgMCkge1xuICAgICAgZXh0cmFIZWFkZXJzW1wieC1wcm94eS10aHJvdWdoLWFsdGVybmF0aXZlLWFwaVwiXSA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1ZFUkNFTF9CTE9CX1BST1hZX1RIUk9VR0hfQUxURVJOQVRJVkVfQVBJO1xuICAgIH1cbiAgfSBjYXRjaCB7XG4gIH1cbiAgcmV0dXJuIGV4dHJhSGVhZGVycztcbn1cbmZ1bmN0aW9uIHNob3VsZFVzZVhDb250ZW50TGVuZ3RoKCkge1xuICB0cnkge1xuICAgIHJldHVybiBwcm9jZXNzLmVudi5WRVJDRUxfQkxPQl9VU0VfWF9DT05URU5UX0xFTkdUSCA9PT0gXCIxXCI7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vLyBzcmMvcHV0LWhlbHBlcnMudHNcbnZhciBwdXRPcHRpb25IZWFkZXJNYXAgPSB7XG4gIGNhY2hlQ29udHJvbE1heEFnZTogXCJ4LWNhY2hlLWNvbnRyb2wtbWF4LWFnZVwiLFxuICBhZGRSYW5kb21TdWZmaXg6IFwieC1hZGQtcmFuZG9tLXN1ZmZpeFwiLFxuICBhbGxvd092ZXJ3cml0ZTogXCJ4LWFsbG93LW92ZXJ3cml0ZVwiLFxuICBjb250ZW50VHlwZTogXCJ4LWNvbnRlbnQtdHlwZVwiXG59O1xuZnVuY3Rpb24gY3JlYXRlUHV0SGVhZGVycyhhbGxvd2VkT3B0aW9ucywgb3B0aW9ucykge1xuICBjb25zdCBoZWFkZXJzID0ge307XG4gIGlmIChhbGxvd2VkT3B0aW9ucy5pbmNsdWRlcyhcImNvbnRlbnRUeXBlXCIpICYmIG9wdGlvbnMuY29udGVudFR5cGUpIHtcbiAgICBoZWFkZXJzW3B1dE9wdGlvbkhlYWRlck1hcC5jb250ZW50VHlwZV0gPSBvcHRpb25zLmNvbnRlbnRUeXBlO1xuICB9XG4gIGlmIChhbGxvd2VkT3B0aW9ucy5pbmNsdWRlcyhcImFkZFJhbmRvbVN1ZmZpeFwiKSAmJiBvcHRpb25zLmFkZFJhbmRvbVN1ZmZpeCAhPT0gdm9pZCAwKSB7XG4gICAgaGVhZGVyc1twdXRPcHRpb25IZWFkZXJNYXAuYWRkUmFuZG9tU3VmZml4XSA9IG9wdGlvbnMuYWRkUmFuZG9tU3VmZml4ID8gXCIxXCIgOiBcIjBcIjtcbiAgfVxuICBpZiAoYWxsb3dlZE9wdGlvbnMuaW5jbHVkZXMoXCJhbGxvd092ZXJ3cml0ZVwiKSAmJiBvcHRpb25zLmFsbG93T3ZlcndyaXRlICE9PSB2b2lkIDApIHtcbiAgICBoZWFkZXJzW3B1dE9wdGlvbkhlYWRlck1hcC5hbGxvd092ZXJ3cml0ZV0gPSBvcHRpb25zLmFsbG93T3ZlcndyaXRlID8gXCIxXCIgOiBcIjBcIjtcbiAgfVxuICBpZiAoYWxsb3dlZE9wdGlvbnMuaW5jbHVkZXMoXCJjYWNoZUNvbnRyb2xNYXhBZ2VcIikgJiYgb3B0aW9ucy5jYWNoZUNvbnRyb2xNYXhBZ2UgIT09IHZvaWQgMCkge1xuICAgIGhlYWRlcnNbcHV0T3B0aW9uSGVhZGVyTWFwLmNhY2hlQ29udHJvbE1heEFnZV0gPSBvcHRpb25zLmNhY2hlQ29udHJvbE1heEFnZS50b1N0cmluZygpO1xuICB9XG4gIHJldHVybiBoZWFkZXJzO1xufVxuYXN5bmMgZnVuY3Rpb24gY3JlYXRlUHV0T3B0aW9ucyh7XG4gIHBhdGhuYW1lLFxuICBvcHRpb25zLFxuICBleHRyYUNoZWNrcyxcbiAgZ2V0VG9rZW5cbn0pIHtcbiAgaWYgKCFwYXRobmFtZSkge1xuICAgIHRocm93IG5ldyBCbG9iRXJyb3IoXCJwYXRobmFtZSBpcyByZXF1aXJlZFwiKTtcbiAgfVxuICBpZiAocGF0aG5hbWUubGVuZ3RoID4gTUFYSU1VTV9QQVRITkFNRV9MRU5HVEgpIHtcbiAgICB0aHJvdyBuZXcgQmxvYkVycm9yKFxuICAgICAgYHBhdGhuYW1lIGlzIHRvbyBsb25nLCBtYXhpbXVtIGxlbmd0aCBpcyAke01BWElNVU1fUEFUSE5BTUVfTEVOR1RIfWBcbiAgICApO1xuICB9XG4gIGZvciAoY29uc3QgaW52YWxpZENoYXJhY3RlciBvZiBkaXNhbGxvd2VkUGF0aG5hbWVDaGFyYWN0ZXJzKSB7XG4gICAgaWYgKHBhdGhuYW1lLmluY2x1ZGVzKGludmFsaWRDaGFyYWN0ZXIpKSB7XG4gICAgICB0aHJvdyBuZXcgQmxvYkVycm9yKFxuICAgICAgICBgcGF0aG5hbWUgY2Fubm90IGNvbnRhaW4gXCIke2ludmFsaWRDaGFyYWN0ZXJ9XCIsIHBsZWFzZSBlbmNvZGUgaXQgaWYgbmVlZGVkYFxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgaWYgKCFvcHRpb25zKSB7XG4gICAgdGhyb3cgbmV3IEJsb2JFcnJvcihcIm1pc3Npbmcgb3B0aW9ucywgc2VlIHVzYWdlXCIpO1xuICB9XG4gIGlmIChvcHRpb25zLmFjY2VzcyAhPT0gXCJwdWJsaWNcIikge1xuICAgIHRocm93IG5ldyBCbG9iRXJyb3IoJ2FjY2VzcyBtdXN0IGJlIFwicHVibGljXCInKTtcbiAgfVxuICBpZiAoZXh0cmFDaGVja3MpIHtcbiAgICBleHRyYUNoZWNrcyhvcHRpb25zKTtcbiAgfVxuICBpZiAoZ2V0VG9rZW4pIHtcbiAgICBvcHRpb25zLnRva2VuID0gYXdhaXQgZ2V0VG9rZW4ocGF0aG5hbWUsIG9wdGlvbnMpO1xuICB9XG4gIHJldHVybiBvcHRpb25zO1xufVxuXG4vLyBzcmMvbXVsdGlwYXJ0L2NvbXBsZXRlLnRzXG5mdW5jdGlvbiBjcmVhdGVDb21wbGV0ZU11bHRpcGFydFVwbG9hZE1ldGhvZCh7IGFsbG93ZWRPcHRpb25zLCBnZXRUb2tlbiwgZXh0cmFDaGVja3MgfSkge1xuICByZXR1cm4gYXN5bmMgKHBhdGhuYW1lLCBwYXJ0cywgb3B0aW9uc0lucHV0KSA9PiB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IGF3YWl0IGNyZWF0ZVB1dE9wdGlvbnMoe1xuICAgICAgcGF0aG5hbWUsXG4gICAgICBvcHRpb25zOiBvcHRpb25zSW5wdXQsXG4gICAgICBleHRyYUNoZWNrcyxcbiAgICAgIGdldFRva2VuXG4gICAgfSk7XG4gICAgY29uc3QgaGVhZGVycyA9IGNyZWF0ZVB1dEhlYWRlcnMoYWxsb3dlZE9wdGlvbnMsIG9wdGlvbnMpO1xuICAgIHJldHVybiBjb21wbGV0ZU11bHRpcGFydFVwbG9hZCh7XG4gICAgICB1cGxvYWRJZDogb3B0aW9ucy51cGxvYWRJZCxcbiAgICAgIGtleTogb3B0aW9ucy5rZXksXG4gICAgICBwYXRobmFtZSxcbiAgICAgIGhlYWRlcnMsXG4gICAgICBvcHRpb25zLFxuICAgICAgcGFydHNcbiAgICB9KTtcbiAgfTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGNvbXBsZXRlTXVsdGlwYXJ0VXBsb2FkKHtcbiAgdXBsb2FkSWQsXG4gIGtleSxcbiAgcGF0aG5hbWUsXG4gIHBhcnRzLFxuICBoZWFkZXJzLFxuICBvcHRpb25zXG59KSB7XG4gIGNvbnN0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoeyBwYXRobmFtZSB9KTtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHJlcXVlc3RBcGkoXG4gICAgICBgL21wdT8ke3BhcmFtcy50b1N0cmluZygpfWAsXG4gICAgICB7XG4gICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAuLi5oZWFkZXJzLFxuICAgICAgICAgIFwiY29udGVudC10eXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgIFwieC1tcHUtYWN0aW9uXCI6IFwiY29tcGxldGVcIixcbiAgICAgICAgICBcIngtbXB1LXVwbG9hZC1pZFwiOiB1cGxvYWRJZCxcbiAgICAgICAgICAvLyBrZXkgY2FuIGJlIGFueSB1dGY4IGNoYXJhY3RlciBzbyB3ZSBuZWVkIHRvIGVuY29kZSBpdCBhcyBIVFRQIGhlYWRlcnMgY2FuIG9ubHkgYmUgdXMtYXNjaWlcbiAgICAgICAgICAvLyBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjNzIzMCNzd2VjdGlvbi0zLjIuNFxuICAgICAgICAgIFwieC1tcHUta2V5XCI6IGVuY29kZVVSSUNvbXBvbmVudChrZXkpXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHBhcnRzKSxcbiAgICAgICAgc2lnbmFsOiBvcHRpb25zLmFib3J0U2lnbmFsXG4gICAgICB9LFxuICAgICAgb3B0aW9uc1xuICAgICk7XG4gICAgZGVidWcoXCJtcHU6IGNvbXBsZXRlXCIsIHJlc3BvbnNlKTtcbiAgICByZXR1cm4gcmVzcG9uc2U7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaWYgKGVycm9yIGluc3RhbmNlb2YgVHlwZUVycm9yICYmIChlcnJvci5tZXNzYWdlID09PSBcIkZhaWxlZCB0byBmZXRjaFwiIHx8IGVycm9yLm1lc3NhZ2UgPT09IFwiZmV0Y2ggZmFpbGVkXCIpKSB7XG4gICAgICB0aHJvdyBuZXcgQmxvYlNlcnZpY2VOb3RBdmFpbGFibGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG59XG5cbi8vIHNyYy9tdWx0aXBhcnQvY3JlYXRlLnRzXG5mdW5jdGlvbiBjcmVhdGVDcmVhdGVNdWx0aXBhcnRVcGxvYWRNZXRob2QoeyBhbGxvd2VkT3B0aW9ucywgZ2V0VG9rZW4sIGV4dHJhQ2hlY2tzIH0pIHtcbiAgcmV0dXJuIGFzeW5jIChwYXRobmFtZSwgb3B0aW9uc0lucHV0KSA9PiB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IGF3YWl0IGNyZWF0ZVB1dE9wdGlvbnMoe1xuICAgICAgcGF0aG5hbWUsXG4gICAgICBvcHRpb25zOiBvcHRpb25zSW5wdXQsXG4gICAgICBleHRyYUNoZWNrcyxcbiAgICAgIGdldFRva2VuXG4gICAgfSk7XG4gICAgY29uc3QgaGVhZGVycyA9IGNyZWF0ZVB1dEhlYWRlcnMoYWxsb3dlZE9wdGlvbnMsIG9wdGlvbnMpO1xuICAgIGNvbnN0IGNyZWF0ZU11bHRpcGFydFVwbG9hZFJlc3BvbnNlID0gYXdhaXQgY3JlYXRlTXVsdGlwYXJ0VXBsb2FkKFxuICAgICAgcGF0aG5hbWUsXG4gICAgICBoZWFkZXJzLFxuICAgICAgb3B0aW9uc1xuICAgICk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGtleTogY3JlYXRlTXVsdGlwYXJ0VXBsb2FkUmVzcG9uc2Uua2V5LFxuICAgICAgdXBsb2FkSWQ6IGNyZWF0ZU11bHRpcGFydFVwbG9hZFJlc3BvbnNlLnVwbG9hZElkXG4gICAgfTtcbiAgfTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGNyZWF0ZU11bHRpcGFydFVwbG9hZChwYXRobmFtZSwgaGVhZGVycywgb3B0aW9ucykge1xuICBkZWJ1ZyhcIm1wdTogY3JlYXRlXCIsIFwicGF0aG5hbWU6XCIsIHBhdGhuYW1lKTtcbiAgY29uc3QgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh7IHBhdGhuYW1lIH0pO1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcmVxdWVzdEFwaShcbiAgICAgIGAvbXB1PyR7cGFyYW1zLnRvU3RyaW5nKCl9YCxcbiAgICAgIHtcbiAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIC4uLmhlYWRlcnMsXG4gICAgICAgICAgXCJ4LW1wdS1hY3Rpb25cIjogXCJjcmVhdGVcIlxuICAgICAgICB9LFxuICAgICAgICBzaWduYWw6IG9wdGlvbnMuYWJvcnRTaWduYWxcbiAgICAgIH0sXG4gICAgICBvcHRpb25zXG4gICAgKTtcbiAgICBkZWJ1ZyhcIm1wdTogY3JlYXRlXCIsIHJlc3BvbnNlKTtcbiAgICByZXR1cm4gcmVzcG9uc2U7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaWYgKGVycm9yIGluc3RhbmNlb2YgVHlwZUVycm9yICYmIChlcnJvci5tZXNzYWdlID09PSBcIkZhaWxlZCB0byBmZXRjaFwiIHx8IGVycm9yLm1lc3NhZ2UgPT09IFwiZmV0Y2ggZmFpbGVkXCIpKSB7XG4gICAgICB0aHJvdyBuZXcgQmxvYlNlcnZpY2VOb3RBdmFpbGFibGUoKTtcbiAgICB9XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cblxuLy8gc3JjL211bHRpcGFydC91cGxvYWQudHNcbmltcG9ydCB0aHJvdHRsZSBmcm9tIFwidGhyb3R0bGVpdFwiO1xuZnVuY3Rpb24gY3JlYXRlVXBsb2FkUGFydE1ldGhvZCh7IGFsbG93ZWRPcHRpb25zLCBnZXRUb2tlbiwgZXh0cmFDaGVja3MgfSkge1xuICByZXR1cm4gYXN5bmMgKHBhdGhuYW1lLCBib2R5LCBvcHRpb25zSW5wdXQpID0+IHtcbiAgICBjb25zdCBvcHRpb25zID0gYXdhaXQgY3JlYXRlUHV0T3B0aW9ucyh7XG4gICAgICBwYXRobmFtZSxcbiAgICAgIG9wdGlvbnM6IG9wdGlvbnNJbnB1dCxcbiAgICAgIGV4dHJhQ2hlY2tzLFxuICAgICAgZ2V0VG9rZW5cbiAgICB9KTtcbiAgICBjb25zdCBoZWFkZXJzID0gY3JlYXRlUHV0SGVhZGVycyhhbGxvd2VkT3B0aW9ucywgb3B0aW9ucyk7XG4gICAgaWYgKGlzUGxhaW5PYmplY3QoYm9keSkpIHtcbiAgICAgIHRocm93IG5ldyBCbG9iRXJyb3IoXG4gICAgICAgIFwiQm9keSBtdXN0IGJlIGEgc3RyaW5nLCBidWZmZXIgb3Igc3RyZWFtLiBZb3Ugc2VudCBhIHBsYWluIEphdmFTY3JpcHQgb2JqZWN0LCBkb3VibGUgY2hlY2sgd2hhdCB5b3UncmUgdHJ5aW5nIHRvIHVwbG9hZC5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdXBsb2FkUGFydCh7XG4gICAgICB1cGxvYWRJZDogb3B0aW9ucy51cGxvYWRJZCxcbiAgICAgIGtleTogb3B0aW9ucy5rZXksXG4gICAgICBwYXRobmFtZSxcbiAgICAgIHBhcnQ6IHsgYmxvYjogYm9keSwgcGFydE51bWJlcjogb3B0aW9ucy5wYXJ0TnVtYmVyIH0sXG4gICAgICBoZWFkZXJzLFxuICAgICAgb3B0aW9uc1xuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICBldGFnOiByZXN1bHQuZXRhZyxcbiAgICAgIHBhcnROdW1iZXI6IG9wdGlvbnMucGFydE51bWJlclxuICAgIH07XG4gIH07XG59XG5hc3luYyBmdW5jdGlvbiB1cGxvYWRQYXJ0KHtcbiAgdXBsb2FkSWQsXG4gIGtleSxcbiAgcGF0aG5hbWUsXG4gIGhlYWRlcnMsXG4gIG9wdGlvbnMsXG4gIGludGVybmFsQWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpLFxuICBwYXJ0XG59KSB7XG4gIHZhciBfYTMsIF9iMiwgX2M7XG4gIGNvbnN0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoeyBwYXRobmFtZSB9KTtcbiAgY29uc3QgcmVzcG9uc2VQcm9taXNlID0gcmVxdWVzdEFwaShcbiAgICBgL21wdT8ke3BhcmFtcy50b1N0cmluZygpfWAsXG4gICAge1xuICAgICAgc2lnbmFsOiBpbnRlcm5hbEFib3J0Q29udHJvbGxlci5zaWduYWwsXG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICAuLi5oZWFkZXJzLFxuICAgICAgICBcIngtbXB1LWFjdGlvblwiOiBcInVwbG9hZFwiLFxuICAgICAgICBcIngtbXB1LWtleVwiOiBlbmNvZGVVUklDb21wb25lbnQoa2V5KSxcbiAgICAgICAgXCJ4LW1wdS11cGxvYWQtaWRcIjogdXBsb2FkSWQsXG4gICAgICAgIFwieC1tcHUtcGFydC1udW1iZXJcIjogcGFydC5wYXJ0TnVtYmVyLnRvU3RyaW5nKClcbiAgICAgIH0sXG4gICAgICAvLyB3ZWlyZCB0aGluZ3MgYmV0d2VlbiB1bmRpY2kgdHlwZXMgYW5kIG5hdGl2ZSBmZXRjaCB0eXBlc1xuICAgICAgYm9keTogcGFydC5ibG9iXG4gICAgfSxcbiAgICBvcHRpb25zXG4gICk7XG4gIGZ1bmN0aW9uIGhhbmRsZUFib3J0KCkge1xuICAgIGludGVybmFsQWJvcnRDb250cm9sbGVyLmFib3J0KCk7XG4gIH1cbiAgaWYgKChfYTMgPSBvcHRpb25zLmFib3J0U2lnbmFsKSA9PSBudWxsID8gdm9pZCAwIDogX2EzLmFib3J0ZWQpIHtcbiAgICBoYW5kbGVBYm9ydCgpO1xuICB9IGVsc2Uge1xuICAgIChfYjIgPSBvcHRpb25zLmFib3J0U2lnbmFsKSA9PSBudWxsID8gdm9pZCAwIDogX2IyLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBoYW5kbGVBYm9ydCk7XG4gIH1cbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCByZXNwb25zZVByb21pc2U7XG4gIChfYyA9IG9wdGlvbnMuYWJvcnRTaWduYWwpID09IG51bGwgPyB2b2lkIDAgOiBfYy5yZW1vdmVFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgaGFuZGxlQWJvcnQpO1xuICByZXR1cm4gcmVzcG9uc2U7XG59XG52YXIgbWF4Q29uY3VycmVudFVwbG9hZHMgPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gNiA6IDg7XG52YXIgcGFydFNpemVJbkJ5dGVzID0gOCAqIDEwMjQgKiAxMDI0O1xudmFyIG1heEJ5dGVzSW5NZW1vcnkgPSBtYXhDb25jdXJyZW50VXBsb2FkcyAqIHBhcnRTaXplSW5CeXRlcyAqIDI7XG5mdW5jdGlvbiB1cGxvYWRBbGxQYXJ0cyh7XG4gIHVwbG9hZElkLFxuICBrZXksXG4gIHBhdGhuYW1lLFxuICBzdHJlYW0sXG4gIGhlYWRlcnMsXG4gIG9wdGlvbnMsXG4gIHRvdGFsVG9Mb2FkXG59KSB7XG4gIGRlYnVnKFwibXB1OiB1cGxvYWQgaW5pdFwiLCBcImtleTpcIiwga2V5KTtcbiAgY29uc3QgaW50ZXJuYWxBYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgY29uc3QgcGFydHNUb1VwbG9hZCA9IFtdO1xuICAgIGNvbnN0IGNvbXBsZXRlZFBhcnRzID0gW107XG4gICAgY29uc3QgcmVhZGVyID0gc3RyZWFtLmdldFJlYWRlcigpO1xuICAgIGxldCBhY3RpdmVVcGxvYWRzID0gMDtcbiAgICBsZXQgcmVhZGluZyA9IGZhbHNlO1xuICAgIGxldCBjdXJyZW50UGFydE51bWJlciA9IDE7XG4gICAgbGV0IHJlamVjdGVkID0gZmFsc2U7XG4gICAgbGV0IGN1cnJlbnRCeXRlc0luTWVtb3J5ID0gMDtcbiAgICBsZXQgZG9uZVJlYWRpbmcgPSBmYWxzZTtcbiAgICBsZXQgYnl0ZXNTZW50ID0gMDtcbiAgICBsZXQgYXJyYXlCdWZmZXJzID0gW107XG4gICAgbGV0IGN1cnJlbnRQYXJ0Qnl0ZXNSZWFkID0gMDtcbiAgICBsZXQgb25VcGxvYWRQcm9ncmVzcztcbiAgICBjb25zdCB0b3RhbExvYWRlZFBlclBhcnROdW1iZXIgPSB7fTtcbiAgICBpZiAob3B0aW9ucy5vblVwbG9hZFByb2dyZXNzKSB7XG4gICAgICBvblVwbG9hZFByb2dyZXNzID0gdGhyb3R0bGUoKCkgPT4ge1xuICAgICAgICB2YXIgX2EzO1xuICAgICAgICBjb25zdCBsb2FkZWQgPSBPYmplY3QudmFsdWVzKHRvdGFsTG9hZGVkUGVyUGFydE51bWJlcikucmVkdWNlKFxuICAgICAgICAgIChhY2MsIGN1cikgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGFjYyArIGN1cjtcbiAgICAgICAgICB9LFxuICAgICAgICAgIDBcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgdG90YWwgPSB0b3RhbFRvTG9hZCB8fCBsb2FkZWQ7XG4gICAgICAgIGNvbnN0IHBlcmNlbnRhZ2UgPSB0b3RhbFRvTG9hZCA+IDAgPyBOdW1iZXIoKChsb2FkZWQgLyB0b3RhbFRvTG9hZCB8fCBsb2FkZWQpICogMTAwKS50b0ZpeGVkKDIpKSA6IDA7XG4gICAgICAgIChfYTMgPSBvcHRpb25zLm9uVXBsb2FkUHJvZ3Jlc3MpID09IG51bGwgPyB2b2lkIDAgOiBfYTMuY2FsbChvcHRpb25zLCB7IGxvYWRlZCwgdG90YWwsIHBlcmNlbnRhZ2UgfSk7XG4gICAgICB9LCAxNTApO1xuICAgIH1cbiAgICByZWFkKCkuY2F0Y2goY2FuY2VsKTtcbiAgICBhc3luYyBmdW5jdGlvbiByZWFkKCkge1xuICAgICAgZGVidWcoXG4gICAgICAgIFwibXB1OiB1cGxvYWQgcmVhZCBzdGFydFwiLFxuICAgICAgICBcImFjdGl2ZVVwbG9hZHM6XCIsXG4gICAgICAgIGFjdGl2ZVVwbG9hZHMsXG4gICAgICAgIFwiY3VycmVudEJ5dGVzSW5NZW1vcnk6XCIsXG4gICAgICAgIGAke2J5dGVzKGN1cnJlbnRCeXRlc0luTWVtb3J5KX0vJHtieXRlcyhtYXhCeXRlc0luTWVtb3J5KX1gLFxuICAgICAgICBcImJ5dGVzU2VudDpcIixcbiAgICAgICAgYnl0ZXMoYnl0ZXNTZW50KVxuICAgICAgKTtcbiAgICAgIHJlYWRpbmcgPSB0cnVlO1xuICAgICAgd2hpbGUgKGN1cnJlbnRCeXRlc0luTWVtb3J5IDwgbWF4Qnl0ZXNJbk1lbW9yeSAmJiAhcmVqZWN0ZWQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCB7IHZhbHVlLCBkb25lIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICBkb25lUmVhZGluZyA9IHRydWU7XG4gICAgICAgICAgICBkZWJ1ZyhcIm1wdTogdXBsb2FkIHJlYWQgY29uc3VtZWQgdGhlIHdob2xlIHN0cmVhbVwiKTtcbiAgICAgICAgICAgIGlmIChhcnJheUJ1ZmZlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICBwYXJ0c1RvVXBsb2FkLnB1c2goe1xuICAgICAgICAgICAgICAgIHBhcnROdW1iZXI6IGN1cnJlbnRQYXJ0TnVtYmVyKyssXG4gICAgICAgICAgICAgICAgYmxvYjogbmV3IEJsb2IoYXJyYXlCdWZmZXJzLCB7XG4gICAgICAgICAgICAgICAgICB0eXBlOiBcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwiXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHNlbmRQYXJ0cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVhZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjdXJyZW50Qnl0ZXNJbk1lbW9yeSArPSB2YWx1ZS5ieXRlTGVuZ3RoO1xuICAgICAgICAgIGxldCB2YWx1ZU9mZnNldCA9IDA7XG4gICAgICAgICAgd2hpbGUgKHZhbHVlT2Zmc2V0IDwgdmFsdWUuYnl0ZUxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3QgcmVtYWluaW5nUGFydFNpemUgPSBwYXJ0U2l6ZUluQnl0ZXMgLSBjdXJyZW50UGFydEJ5dGVzUmVhZDtcbiAgICAgICAgICAgIGNvbnN0IGVuZE9mZnNldCA9IE1hdGgubWluKFxuICAgICAgICAgICAgICB2YWx1ZU9mZnNldCArIHJlbWFpbmluZ1BhcnRTaXplLFxuICAgICAgICAgICAgICB2YWx1ZS5ieXRlTGVuZ3RoXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgY29uc3QgY2h1bmsgPSB2YWx1ZS5zbGljZSh2YWx1ZU9mZnNldCwgZW5kT2Zmc2V0KTtcbiAgICAgICAgICAgIGFycmF5QnVmZmVycy5wdXNoKGNodW5rKTtcbiAgICAgICAgICAgIGN1cnJlbnRQYXJ0Qnl0ZXNSZWFkICs9IGNodW5rLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgICB2YWx1ZU9mZnNldCA9IGVuZE9mZnNldDtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UGFydEJ5dGVzUmVhZCA9PT0gcGFydFNpemVJbkJ5dGVzKSB7XG4gICAgICAgICAgICAgIHBhcnRzVG9VcGxvYWQucHVzaCh7XG4gICAgICAgICAgICAgICAgcGFydE51bWJlcjogY3VycmVudFBhcnROdW1iZXIrKyxcbiAgICAgICAgICAgICAgICBibG9iOiBuZXcgQmxvYihhcnJheUJ1ZmZlcnMsIHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6IFwiYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtXCJcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgYXJyYXlCdWZmZXJzID0gW107XG4gICAgICAgICAgICAgIGN1cnJlbnRQYXJ0Qnl0ZXNSZWFkID0gMDtcbiAgICAgICAgICAgICAgc2VuZFBhcnRzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGNhbmNlbChlcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGRlYnVnKFxuICAgICAgICBcIm1wdTogdXBsb2FkIHJlYWQgZW5kXCIsXG4gICAgICAgIFwiYWN0aXZlVXBsb2FkczpcIixcbiAgICAgICAgYWN0aXZlVXBsb2FkcyxcbiAgICAgICAgXCJjdXJyZW50Qnl0ZXNJbk1lbW9yeTpcIixcbiAgICAgICAgYCR7Ynl0ZXMoY3VycmVudEJ5dGVzSW5NZW1vcnkpfS8ke2J5dGVzKG1heEJ5dGVzSW5NZW1vcnkpfWAsXG4gICAgICAgIFwiYnl0ZXNTZW50OlwiLFxuICAgICAgICBieXRlcyhieXRlc1NlbnQpXG4gICAgICApO1xuICAgICAgcmVhZGluZyA9IGZhbHNlO1xuICAgIH1cbiAgICBhc3luYyBmdW5jdGlvbiBzZW5kUGFydChwYXJ0KSB7XG4gICAgICBhY3RpdmVVcGxvYWRzKys7XG4gICAgICBkZWJ1ZyhcbiAgICAgICAgXCJtcHU6IHVwbG9hZCBzZW5kIHBhcnQgc3RhcnRcIixcbiAgICAgICAgXCJwYXJ0TnVtYmVyOlwiLFxuICAgICAgICBwYXJ0LnBhcnROdW1iZXIsXG4gICAgICAgIFwic2l6ZTpcIixcbiAgICAgICAgcGFydC5ibG9iLnNpemUsXG4gICAgICAgIFwiYWN0aXZlVXBsb2FkczpcIixcbiAgICAgICAgYWN0aXZlVXBsb2FkcyxcbiAgICAgICAgXCJjdXJyZW50Qnl0ZXNJbk1lbW9yeTpcIixcbiAgICAgICAgYCR7Ynl0ZXMoY3VycmVudEJ5dGVzSW5NZW1vcnkpfS8ke2J5dGVzKG1heEJ5dGVzSW5NZW1vcnkpfWAsXG4gICAgICAgIFwiYnl0ZXNTZW50OlwiLFxuICAgICAgICBieXRlcyhieXRlc1NlbnQpXG4gICAgICApO1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgdXBsb2FkUHJvZ3Jlc3NGb3JQYXJ0ID0gb3B0aW9ucy5vblVwbG9hZFByb2dyZXNzID8gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgdG90YWxMb2FkZWRQZXJQYXJ0TnVtYmVyW3BhcnQucGFydE51bWJlcl0gPSBldmVudC5sb2FkZWQ7XG4gICAgICAgICAgaWYgKG9uVXBsb2FkUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgIG9uVXBsb2FkUHJvZ3Jlc3MoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gOiB2b2lkIDA7XG4gICAgICAgIGNvbnN0IGNvbXBsZXRlZFBhcnQgPSBhd2FpdCB1cGxvYWRQYXJ0KHtcbiAgICAgICAgICB1cGxvYWRJZCxcbiAgICAgICAgICBrZXksXG4gICAgICAgICAgcGF0aG5hbWUsXG4gICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgb25VcGxvYWRQcm9ncmVzczogdXBsb2FkUHJvZ3Jlc3NGb3JQYXJ0XG4gICAgICAgICAgfSxcbiAgICAgICAgICBpbnRlcm5hbEFib3J0Q29udHJvbGxlcixcbiAgICAgICAgICBwYXJ0XG4gICAgICAgIH0pO1xuICAgICAgICBkZWJ1ZyhcbiAgICAgICAgICBcIm1wdTogdXBsb2FkIHNlbmQgcGFydCBlbmRcIixcbiAgICAgICAgICBcInBhcnROdW1iZXI6XCIsXG4gICAgICAgICAgcGFydC5wYXJ0TnVtYmVyLFxuICAgICAgICAgIFwiYWN0aXZlVXBsb2Fkc1wiLFxuICAgICAgICAgIGFjdGl2ZVVwbG9hZHMsXG4gICAgICAgICAgXCJjdXJyZW50Qnl0ZXNJbk1lbW9yeTpcIixcbiAgICAgICAgICBgJHtieXRlcyhjdXJyZW50Qnl0ZXNJbk1lbW9yeSl9LyR7Ynl0ZXMobWF4Qnl0ZXNJbk1lbW9yeSl9YCxcbiAgICAgICAgICBcImJ5dGVzU2VudDpcIixcbiAgICAgICAgICBieXRlcyhieXRlc1NlbnQpXG4gICAgICAgICk7XG4gICAgICAgIGlmIChyZWplY3RlZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb21wbGV0ZWRQYXJ0cy5wdXNoKHtcbiAgICAgICAgICBwYXJ0TnVtYmVyOiBwYXJ0LnBhcnROdW1iZXIsXG4gICAgICAgICAgZXRhZzogY29tcGxldGVkUGFydC5ldGFnXG4gICAgICAgIH0pO1xuICAgICAgICBjdXJyZW50Qnl0ZXNJbk1lbW9yeSAtPSBwYXJ0LmJsb2Iuc2l6ZTtcbiAgICAgICAgYWN0aXZlVXBsb2Fkcy0tO1xuICAgICAgICBieXRlc1NlbnQgKz0gcGFydC5ibG9iLnNpemU7XG4gICAgICAgIGlmIChwYXJ0c1RvVXBsb2FkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBzZW5kUGFydHMoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZG9uZVJlYWRpbmcpIHtcbiAgICAgICAgICBpZiAoYWN0aXZlVXBsb2FkcyA9PT0gMCkge1xuICAgICAgICAgICAgcmVhZGVyLnJlbGVhc2VMb2NrKCk7XG4gICAgICAgICAgICByZXNvbHZlKGNvbXBsZXRlZFBhcnRzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcmVhZGluZykge1xuICAgICAgICAgIHJlYWQoKS5jYXRjaChjYW5jZWwpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjYW5jZWwoZXJyb3IpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBzZW5kUGFydHMoKSB7XG4gICAgICBpZiAocmVqZWN0ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZGVidWcoXG4gICAgICAgIFwic2VuZCBwYXJ0c1wiLFxuICAgICAgICBcImFjdGl2ZVVwbG9hZHNcIixcbiAgICAgICAgYWN0aXZlVXBsb2FkcyxcbiAgICAgICAgXCJwYXJ0c1RvVXBsb2FkXCIsXG4gICAgICAgIHBhcnRzVG9VcGxvYWQubGVuZ3RoXG4gICAgICApO1xuICAgICAgd2hpbGUgKGFjdGl2ZVVwbG9hZHMgPCBtYXhDb25jdXJyZW50VXBsb2FkcyAmJiBwYXJ0c1RvVXBsb2FkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3QgcGFydFRvU2VuZCA9IHBhcnRzVG9VcGxvYWQuc2hpZnQoKTtcbiAgICAgICAgaWYgKHBhcnRUb1NlbmQpIHtcbiAgICAgICAgICB2b2lkIHNlbmRQYXJ0KHBhcnRUb1NlbmQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNhbmNlbChlcnJvcikge1xuICAgICAgaWYgKHJlamVjdGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHJlamVjdGVkID0gdHJ1ZTtcbiAgICAgIGludGVybmFsQWJvcnRDb250cm9sbGVyLmFib3J0KCk7XG4gICAgICByZWFkZXIucmVsZWFzZUxvY2soKTtcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIFR5cGVFcnJvciAmJiAoZXJyb3IubWVzc2FnZSA9PT0gXCJGYWlsZWQgdG8gZmV0Y2hcIiB8fCBlcnJvci5tZXNzYWdlID09PSBcImZldGNoIGZhaWxlZFwiKSkge1xuICAgICAgICByZWplY3QobmV3IEJsb2JTZXJ2aWNlTm90QXZhaWxhYmxlKCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuXG4vLyBzcmMvbXVsdGlwYXJ0L2NyZWF0ZS11cGxvYWRlci50c1xuZnVuY3Rpb24gY3JlYXRlQ3JlYXRlTXVsdGlwYXJ0VXBsb2FkZXJNZXRob2QoeyBhbGxvd2VkT3B0aW9ucywgZ2V0VG9rZW4sIGV4dHJhQ2hlY2tzIH0pIHtcbiAgcmV0dXJuIGFzeW5jIChwYXRobmFtZSwgb3B0aW9uc0lucHV0KSA9PiB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IGF3YWl0IGNyZWF0ZVB1dE9wdGlvbnMoe1xuICAgICAgcGF0aG5hbWUsXG4gICAgICBvcHRpb25zOiBvcHRpb25zSW5wdXQsXG4gICAgICBleHRyYUNoZWNrcyxcbiAgICAgIGdldFRva2VuXG4gICAgfSk7XG4gICAgY29uc3QgaGVhZGVycyA9IGNyZWF0ZVB1dEhlYWRlcnMoYWxsb3dlZE9wdGlvbnMsIG9wdGlvbnMpO1xuICAgIGNvbnN0IGNyZWF0ZU11bHRpcGFydFVwbG9hZFJlc3BvbnNlID0gYXdhaXQgY3JlYXRlTXVsdGlwYXJ0VXBsb2FkKFxuICAgICAgcGF0aG5hbWUsXG4gICAgICBoZWFkZXJzLFxuICAgICAgb3B0aW9uc1xuICAgICk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGtleTogY3JlYXRlTXVsdGlwYXJ0VXBsb2FkUmVzcG9uc2Uua2V5LFxuICAgICAgdXBsb2FkSWQ6IGNyZWF0ZU11bHRpcGFydFVwbG9hZFJlc3BvbnNlLnVwbG9hZElkLFxuICAgICAgYXN5bmMgdXBsb2FkUGFydChwYXJ0TnVtYmVyLCBib2R5KSB7XG4gICAgICAgIGlmIChpc1BsYWluT2JqZWN0KGJvZHkpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEJsb2JFcnJvcihcbiAgICAgICAgICAgIFwiQm9keSBtdXN0IGJlIGEgc3RyaW5nLCBidWZmZXIgb3Igc3RyZWFtLiBZb3Ugc2VudCBhIHBsYWluIEphdmFTY3JpcHQgb2JqZWN0LCBkb3VibGUgY2hlY2sgd2hhdCB5b3UncmUgdHJ5aW5nIHRvIHVwbG9hZC5cIlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdXBsb2FkUGFydCh7XG4gICAgICAgICAgdXBsb2FkSWQ6IGNyZWF0ZU11bHRpcGFydFVwbG9hZFJlc3BvbnNlLnVwbG9hZElkLFxuICAgICAgICAgIGtleTogY3JlYXRlTXVsdGlwYXJ0VXBsb2FkUmVzcG9uc2Uua2V5LFxuICAgICAgICAgIHBhdGhuYW1lLFxuICAgICAgICAgIHBhcnQ6IHsgcGFydE51bWJlciwgYmxvYjogYm9keSB9LFxuICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgb3B0aW9uc1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBldGFnOiByZXN1bHQuZXRhZyxcbiAgICAgICAgICBwYXJ0TnVtYmVyXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgYXN5bmMgY29tcGxldGUocGFydHMpIHtcbiAgICAgICAgcmV0dXJuIGNvbXBsZXRlTXVsdGlwYXJ0VXBsb2FkKHtcbiAgICAgICAgICB1cGxvYWRJZDogY3JlYXRlTXVsdGlwYXJ0VXBsb2FkUmVzcG9uc2UudXBsb2FkSWQsXG4gICAgICAgICAga2V5OiBjcmVhdGVNdWx0aXBhcnRVcGxvYWRSZXNwb25zZS5rZXksXG4gICAgICAgICAgcGF0aG5hbWUsXG4gICAgICAgICAgcGFydHMsXG4gICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICBvcHRpb25zXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gIH07XG59XG5cbi8vIHNyYy9wdXQudHNcbmltcG9ydCB0aHJvdHRsZTIgZnJvbSBcInRocm90dGxlaXRcIjtcblxuLy8gc3JjL211bHRpcGFydC91bmNvbnRyb2xsZWQudHNcbmFzeW5jIGZ1bmN0aW9uIHVuY29udHJvbGxlZE11bHRpcGFydFVwbG9hZChwYXRobmFtZSwgYm9keSwgaGVhZGVycywgb3B0aW9ucykge1xuICBkZWJ1ZyhcIm1wdTogaW5pdFwiLCBcInBhdGhuYW1lOlwiLCBwYXRobmFtZSwgXCJoZWFkZXJzOlwiLCBoZWFkZXJzKTtcbiAgY29uc3Qgb3B0aW9uc1dpdGhvdXRPblVwbG9hZFByb2dyZXNzID0ge1xuICAgIC4uLm9wdGlvbnMsXG4gICAgb25VcGxvYWRQcm9ncmVzczogdm9pZCAwXG4gIH07XG4gIGNvbnN0IGNyZWF0ZU11bHRpcGFydFVwbG9hZFJlc3BvbnNlID0gYXdhaXQgY3JlYXRlTXVsdGlwYXJ0VXBsb2FkKFxuICAgIHBhdGhuYW1lLFxuICAgIGhlYWRlcnMsXG4gICAgb3B0aW9uc1dpdGhvdXRPblVwbG9hZFByb2dyZXNzXG4gICk7XG4gIGNvbnN0IHRvdGFsVG9Mb2FkID0gY29tcHV0ZUJvZHlMZW5ndGgoYm9keSk7XG4gIGNvbnN0IHN0cmVhbSA9IGF3YWl0IHRvUmVhZGFibGVTdHJlYW0oYm9keSk7XG4gIGNvbnN0IHBhcnRzID0gYXdhaXQgdXBsb2FkQWxsUGFydHMoe1xuICAgIHVwbG9hZElkOiBjcmVhdGVNdWx0aXBhcnRVcGxvYWRSZXNwb25zZS51cGxvYWRJZCxcbiAgICBrZXk6IGNyZWF0ZU11bHRpcGFydFVwbG9hZFJlc3BvbnNlLmtleSxcbiAgICBwYXRobmFtZSxcbiAgICBzdHJlYW0sXG4gICAgaGVhZGVycyxcbiAgICBvcHRpb25zLFxuICAgIHRvdGFsVG9Mb2FkXG4gIH0pO1xuICBjb25zdCBibG9iID0gYXdhaXQgY29tcGxldGVNdWx0aXBhcnRVcGxvYWQoe1xuICAgIHVwbG9hZElkOiBjcmVhdGVNdWx0aXBhcnRVcGxvYWRSZXNwb25zZS51cGxvYWRJZCxcbiAgICBrZXk6IGNyZWF0ZU11bHRpcGFydFVwbG9hZFJlc3BvbnNlLmtleSxcbiAgICBwYXRobmFtZSxcbiAgICBwYXJ0cyxcbiAgICBoZWFkZXJzLFxuICAgIG9wdGlvbnM6IG9wdGlvbnNXaXRob3V0T25VcGxvYWRQcm9ncmVzc1xuICB9KTtcbiAgcmV0dXJuIGJsb2I7XG59XG5cbi8vIHNyYy9wdXQudHNcbmZ1bmN0aW9uIGNyZWF0ZVB1dE1ldGhvZCh7XG4gIGFsbG93ZWRPcHRpb25zLFxuICBnZXRUb2tlbixcbiAgZXh0cmFDaGVja3Ncbn0pIHtcbiAgcmV0dXJuIGFzeW5jIGZ1bmN0aW9uIHB1dChwYXRobmFtZSwgYm9keSwgb3B0aW9uc0lucHV0KSB7XG4gICAgaWYgKCFib2R5KSB7XG4gICAgICB0aHJvdyBuZXcgQmxvYkVycm9yKFwiYm9keSBpcyByZXF1aXJlZFwiKTtcbiAgICB9XG4gICAgaWYgKGlzUGxhaW5PYmplY3QoYm9keSkpIHtcbiAgICAgIHRocm93IG5ldyBCbG9iRXJyb3IoXG4gICAgICAgIFwiQm9keSBtdXN0IGJlIGEgc3RyaW5nLCBidWZmZXIgb3Igc3RyZWFtLiBZb3Ugc2VudCBhIHBsYWluIEphdmFTY3JpcHQgb2JqZWN0LCBkb3VibGUgY2hlY2sgd2hhdCB5b3UncmUgdHJ5aW5nIHRvIHVwbG9hZC5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3Qgb3B0aW9ucyA9IGF3YWl0IGNyZWF0ZVB1dE9wdGlvbnMoe1xuICAgICAgcGF0aG5hbWUsXG4gICAgICBvcHRpb25zOiBvcHRpb25zSW5wdXQsXG4gICAgICBleHRyYUNoZWNrcyxcbiAgICAgIGdldFRva2VuXG4gICAgfSk7XG4gICAgY29uc3QgaGVhZGVycyA9IGNyZWF0ZVB1dEhlYWRlcnMoYWxsb3dlZE9wdGlvbnMsIG9wdGlvbnMpO1xuICAgIGlmIChvcHRpb25zLm11bHRpcGFydCA9PT0gdHJ1ZSkge1xuICAgICAgcmV0dXJuIHVuY29udHJvbGxlZE11bHRpcGFydFVwbG9hZChwYXRobmFtZSwgYm9keSwgaGVhZGVycywgb3B0aW9ucyk7XG4gICAgfVxuICAgIGNvbnN0IG9uVXBsb2FkUHJvZ3Jlc3MgPSBvcHRpb25zLm9uVXBsb2FkUHJvZ3Jlc3MgPyB0aHJvdHRsZTIob3B0aW9ucy5vblVwbG9hZFByb2dyZXNzLCAxMDApIDogdm9pZCAwO1xuICAgIGNvbnN0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoeyBwYXRobmFtZSB9KTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHJlcXVlc3RBcGkoXG4gICAgICBgLz8ke3BhcmFtcy50b1N0cmluZygpfWAsXG4gICAgICB7XG4gICAgICAgIG1ldGhvZDogXCJQVVRcIixcbiAgICAgICAgYm9keSxcbiAgICAgICAgaGVhZGVycyxcbiAgICAgICAgc2lnbmFsOiBvcHRpb25zLmFib3J0U2lnbmFsXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICBvblVwbG9hZFByb2dyZXNzXG4gICAgICB9XG4gICAgKTtcbiAgICByZXR1cm4ge1xuICAgICAgdXJsOiByZXNwb25zZS51cmwsXG4gICAgICBkb3dubG9hZFVybDogcmVzcG9uc2UuZG93bmxvYWRVcmwsXG4gICAgICBwYXRobmFtZTogcmVzcG9uc2UucGF0aG5hbWUsXG4gICAgICBjb250ZW50VHlwZTogcmVzcG9uc2UuY29udGVudFR5cGUsXG4gICAgICBjb250ZW50RGlzcG9zaXRpb246IHJlc3BvbnNlLmNvbnRlbnREaXNwb3NpdGlvblxuICAgIH07XG4gIH07XG59XG5cbi8vIHNyYy9jcmVhdGUtZm9sZGVyLnRzXG5hc3luYyBmdW5jdGlvbiBjcmVhdGVGb2xkZXIocGF0aG5hbWUsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCBmb2xkZXJQYXRobmFtZSA9IHBhdGhuYW1lLmVuZHNXaXRoKFwiL1wiKSA/IHBhdGhuYW1lIDogYCR7cGF0aG5hbWV9L2A7XG4gIGNvbnN0IGhlYWRlcnMgPSB7fTtcbiAgaGVhZGVyc1twdXRPcHRpb25IZWFkZXJNYXAuYWRkUmFuZG9tU3VmZml4XSA9IFwiMFwiO1xuICBjb25zdCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHsgcGF0aG5hbWU6IGZvbGRlclBhdGhuYW1lIH0pO1xuICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHJlcXVlc3RBcGkoXG4gICAgYC8/JHtwYXJhbXMudG9TdHJpbmcoKX1gLFxuICAgIHtcbiAgICAgIG1ldGhvZDogXCJQVVRcIixcbiAgICAgIGhlYWRlcnMsXG4gICAgICBzaWduYWw6IG9wdGlvbnMuYWJvcnRTaWduYWxcbiAgICB9LFxuICAgIG9wdGlvbnNcbiAgKTtcbiAgcmV0dXJuIHtcbiAgICB1cmw6IHJlc3BvbnNlLnVybCxcbiAgICBwYXRobmFtZTogcmVzcG9uc2UucGF0aG5hbWVcbiAgfTtcbn1cblxuZXhwb3J0IHtcbiAgZ2V0VG9rZW5Gcm9tT3B0aW9uc09yRW52LFxuICBCbG9iRXJyb3IsXG4gIGdldERvd25sb2FkVXJsLFxuICBkaXNhbGxvd2VkUGF0aG5hbWVDaGFyYWN0ZXJzLFxuICBNQVhJTVVNX1BBVEhOQU1FX0xFTkdUSCxcbiAgQmxvYkFjY2Vzc0Vycm9yLFxuICBCbG9iQ29udGVudFR5cGVOb3RBbGxvd2VkRXJyb3IsXG4gIEJsb2JQYXRobmFtZU1pc21hdGNoRXJyb3IsXG4gIEJsb2JDbGllbnRUb2tlbkV4cGlyZWRFcnJvcixcbiAgQmxvYkZpbGVUb29MYXJnZUVycm9yLFxuICBCbG9iU3RvcmVOb3RGb3VuZEVycm9yLFxuICBCbG9iU3RvcmVTdXNwZW5kZWRFcnJvcixcbiAgQmxvYlVua25vd25FcnJvcixcbiAgQmxvYk5vdEZvdW5kRXJyb3IsXG4gIEJsb2JTZXJ2aWNlTm90QXZhaWxhYmxlLFxuICBCbG9iU2VydmljZVJhdGVMaW1pdGVkLFxuICBCbG9iUmVxdWVzdEFib3J0ZWRFcnJvcixcbiAgcmVxdWVzdEFwaSxcbiAgY3JlYXRlQ29tcGxldGVNdWx0aXBhcnRVcGxvYWRNZXRob2QsXG4gIGNyZWF0ZUNyZWF0ZU11bHRpcGFydFVwbG9hZE1ldGhvZCxcbiAgY3JlYXRlVXBsb2FkUGFydE1ldGhvZCxcbiAgY3JlYXRlQ3JlYXRlTXVsdGlwYXJ0VXBsb2FkZXJNZXRob2QsXG4gIGNyZWF0ZVB1dE1ldGhvZCxcbiAgY3JlYXRlRm9sZGVyXG59O1xuLyohXG4gKiBieXRlc1xuICogQ29weXJpZ2h0KGMpIDIwMTItMjAxNCBUSiBIb2xvd2F5Y2h1a1xuICogQ29weXJpZ2h0KGMpIDIwMTUgSmVkIFdhdHNvblxuICogTUlUIExpY2Vuc2VkXG4gKi9cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNodW5rLUZONlhGSDZSLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@vercel/blob/dist/chunk-FN6XFH6R.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@vercel/blob/dist/client.js":
/*!**************************************************!*\
  !*** ./node_modules/@vercel/blob/dist/client.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   completeMultipartUpload: () => (/* binding */ completeMultipartUpload),\n/* harmony export */   createFolder: () => (/* reexport safe */ _chunk_FN6XFH6R_js__WEBPACK_IMPORTED_MODULE_2__.createFolder),\n/* harmony export */   createMultipartUpload: () => (/* binding */ createMultipartUpload),\n/* harmony export */   createMultipartUploader: () => (/* binding */ createMultipartUploader),\n/* harmony export */   generateClientTokenFromReadWriteToken: () => (/* binding */ generateClientTokenFromReadWriteToken),\n/* harmony export */   getPayloadFromClientToken: () => (/* binding */ getPayloadFromClientToken),\n/* harmony export */   handleUpload: () => (/* binding */ handleUpload),\n/* harmony export */   put: () => (/* binding */ put),\n/* harmony export */   upload: () => (/* binding */ upload),\n/* harmony export */   uploadPart: () => (/* binding */ uploadPart)\n/* harmony export */ });\n/* harmony import */ var _chunk_FN6XFH6R_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./chunk-FN6XFH6R.js */ \"(rsc)/./node_modules/@vercel/blob/dist/chunk-FN6XFH6R.js\");\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! crypto */ \"crypto\");\n/* harmony import */ var undici__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! undici */ \"(rsc)/./node_modules/undici/index.js\");\n\n\n// src/client.ts\n\n\nfunction createPutExtraChecks(methodName) {\n  return function extraChecks(options) {\n    if (!options.token.startsWith(\"vercel_blob_client_\")) {\n      throw new _chunk_FN6XFH6R_js__WEBPACK_IMPORTED_MODULE_2__.BlobError(`${methodName} must be called with a client token`);\n    }\n    if (\n      // @ts-expect-error -- Runtime check for DX.\n      options.addRandomSuffix !== void 0 || // @ts-expect-error -- Runtime check for DX.\n      options.allowOverwrite !== void 0 || // @ts-expect-error -- Runtime check for DX.\n      options.cacheControlMaxAge !== void 0\n    ) {\n      throw new _chunk_FN6XFH6R_js__WEBPACK_IMPORTED_MODULE_2__.BlobError(\n        `${methodName} doesn't allow \\`addRandomSuffix\\`, \\`cacheControlMaxAge\\` or \\`allowOverwrite\\`. Configure these options at the server side when generating client tokens.`\n      );\n    }\n  };\n}\nvar put = (0,_chunk_FN6XFH6R_js__WEBPACK_IMPORTED_MODULE_2__.createPutMethod)({\n  allowedOptions: [\"contentType\"],\n  extraChecks: createPutExtraChecks(\"client/`put`\")\n});\nvar createMultipartUpload = (0,_chunk_FN6XFH6R_js__WEBPACK_IMPORTED_MODULE_2__.createCreateMultipartUploadMethod)({\n  allowedOptions: [\"contentType\"],\n  extraChecks: createPutExtraChecks(\"client/`createMultipartUpload`\")\n});\nvar createMultipartUploader = (0,_chunk_FN6XFH6R_js__WEBPACK_IMPORTED_MODULE_2__.createCreateMultipartUploaderMethod)(\n  {\n    allowedOptions: [\"contentType\"],\n    extraChecks: createPutExtraChecks(\"client/`createMultipartUpload`\")\n  }\n);\nvar uploadPart = (0,_chunk_FN6XFH6R_js__WEBPACK_IMPORTED_MODULE_2__.createUploadPartMethod)({\n  allowedOptions: [\"contentType\"],\n  extraChecks: createPutExtraChecks(\"client/`multipartUpload`\")\n});\nvar completeMultipartUpload = (0,_chunk_FN6XFH6R_js__WEBPACK_IMPORTED_MODULE_2__.createCompleteMultipartUploadMethod)(\n  {\n    allowedOptions: [\"contentType\"],\n    extraChecks: createPutExtraChecks(\"client/`completeMultipartUpload`\")\n  }\n);\nvar upload = (0,_chunk_FN6XFH6R_js__WEBPACK_IMPORTED_MODULE_2__.createPutMethod)({\n  allowedOptions: [\"contentType\"],\n  extraChecks(options) {\n    if (options.handleUploadUrl === void 0) {\n      throw new _chunk_FN6XFH6R_js__WEBPACK_IMPORTED_MODULE_2__.BlobError(\n        \"client/`upload` requires the 'handleUploadUrl' parameter\"\n      );\n    }\n    if (\n      // @ts-expect-error -- Runtime check for DX.\n      options.addRandomSuffix !== void 0 || // @ts-expect-error -- Runtime check for DX.\n      options.createPutExtraChecks !== void 0 || // @ts-expect-error -- Runtime check for DX.\n      options.cacheControlMaxAge !== void 0\n    ) {\n      throw new _chunk_FN6XFH6R_js__WEBPACK_IMPORTED_MODULE_2__.BlobError(\n        \"client/`upload` doesn't allow `addRandomSuffix`, `cacheControlMaxAge` or `allowOverwrite`. Configure these options at the server side when generating client tokens.\"\n      );\n    }\n  },\n  async getToken(pathname, options) {\n    var _a, _b;\n    return retrieveClientToken({\n      handleUploadUrl: options.handleUploadUrl,\n      pathname,\n      clientPayload: (_a = options.clientPayload) != null ? _a : null,\n      multipart: (_b = options.multipart) != null ? _b : false,\n      headers: options.headers\n    });\n  }\n});\nasync function importKey(token) {\n  return globalThis.crypto.subtle.importKey(\n    \"raw\",\n    new TextEncoder().encode(token),\n    { name: \"HMAC\", hash: \"SHA-256\" },\n    false,\n    [\"sign\", \"verify\"]\n  );\n}\nasync function signPayload(payload, token) {\n  if (!globalThis.crypto) {\n    return crypto__WEBPACK_IMPORTED_MODULE_0__.createHmac(\"sha256\", token).update(payload).digest(\"hex\");\n  }\n  const signature = await globalThis.crypto.subtle.sign(\n    \"HMAC\",\n    await importKey(token),\n    new TextEncoder().encode(payload)\n  );\n  return Buffer.from(new Uint8Array(signature)).toString(\"hex\");\n}\nasync function verifyCallbackSignature({\n  token,\n  signature,\n  body\n}) {\n  const secret = token;\n  if (!globalThis.crypto) {\n    const digest = crypto__WEBPACK_IMPORTED_MODULE_0__.createHmac(\"sha256\", secret).update(body).digest(\"hex\");\n    const digestBuffer = Buffer.from(digest);\n    const signatureBuffer = Buffer.from(signature);\n    return digestBuffer.length === signatureBuffer.length && crypto__WEBPACK_IMPORTED_MODULE_0__.timingSafeEqual(digestBuffer, signatureBuffer);\n  }\n  const verified = await globalThis.crypto.subtle.verify(\n    \"HMAC\",\n    await importKey(token),\n    hexToArrayByte(signature),\n    new TextEncoder().encode(body)\n  );\n  return verified;\n}\nfunction hexToArrayByte(input) {\n  if (input.length % 2 !== 0) {\n    throw new RangeError(\"Expected string to be an even number of characters\");\n  }\n  const view = new Uint8Array(input.length / 2);\n  for (let i = 0; i < input.length; i += 2) {\n    view[i / 2] = Number.parseInt(input.substring(i, i + 2), 16);\n  }\n  return Buffer.from(view);\n}\nfunction getPayloadFromClientToken(clientToken) {\n  const [, , , , encodedToken] = clientToken.split(\"_\");\n  const encodedPayload = Buffer.from(encodedToken != null ? encodedToken : \"\", \"base64\").toString().split(\".\")[1];\n  const decodedPayload = Buffer.from(encodedPayload != null ? encodedPayload : \"\", \"base64\").toString();\n  return JSON.parse(decodedPayload);\n}\nvar EventTypes = {\n  generateClientToken: \"blob.generate-client-token\",\n  uploadCompleted: \"blob.upload-completed\"\n};\nasync function handleUpload({\n  token,\n  request,\n  body,\n  onBeforeGenerateToken,\n  onUploadCompleted\n}) {\n  var _a, _b, _c, _d;\n  const resolvedToken = (0,_chunk_FN6XFH6R_js__WEBPACK_IMPORTED_MODULE_2__.getTokenFromOptionsOrEnv)({ token });\n  const type = body.type;\n  switch (type) {\n    case \"blob.generate-client-token\": {\n      const { pathname, clientPayload, multipart } = body.payload;\n      const payload = await onBeforeGenerateToken(\n        pathname,\n        clientPayload,\n        multipart\n      );\n      const tokenPayload = (_a = payload.tokenPayload) != null ? _a : clientPayload;\n      const { callbackUrl: providedCallbackUrl, ...tokenOptions } = payload;\n      let callbackUrl = providedCallbackUrl;\n      if (onUploadCompleted && !callbackUrl) {\n        callbackUrl = getCallbackUrl(request);\n      }\n      if (!onUploadCompleted && callbackUrl) {\n        console.warn(\n          \"callbackUrl was provided but onUploadCompleted is not defined. The callback will not be handled.\"\n        );\n      }\n      const oneHourInSeconds = 60 * 60;\n      const now = /* @__PURE__ */ new Date();\n      const validUntil = (_b = payload.validUntil) != null ? _b : now.setSeconds(now.getSeconds() + oneHourInSeconds);\n      return {\n        type,\n        clientToken: await generateClientTokenFromReadWriteToken({\n          ...tokenOptions,\n          token: resolvedToken,\n          pathname,\n          onUploadCompleted: callbackUrl ? {\n            callbackUrl,\n            tokenPayload\n          } : void 0,\n          validUntil\n        })\n      };\n    }\n    case \"blob.upload-completed\": {\n      const signatureHeader = \"x-vercel-signature\";\n      const signature = \"credentials\" in request ? (_c = request.headers.get(signatureHeader)) != null ? _c : \"\" : (_d = request.headers[signatureHeader]) != null ? _d : \"\";\n      if (!signature) {\n        throw new _chunk_FN6XFH6R_js__WEBPACK_IMPORTED_MODULE_2__.BlobError(\"Missing callback signature\");\n      }\n      const isVerified = await verifyCallbackSignature({\n        token: resolvedToken,\n        signature,\n        body: JSON.stringify(body)\n      });\n      if (!isVerified) {\n        throw new _chunk_FN6XFH6R_js__WEBPACK_IMPORTED_MODULE_2__.BlobError(\"Invalid callback signature\");\n      }\n      if (onUploadCompleted) {\n        await onUploadCompleted(body.payload);\n      }\n      return { type, response: \"ok\" };\n    }\n    default:\n      throw new _chunk_FN6XFH6R_js__WEBPACK_IMPORTED_MODULE_2__.BlobError(\"Invalid event type\");\n  }\n}\nasync function retrieveClientToken(options) {\n  const { handleUploadUrl, pathname } = options;\n  const url = isAbsoluteUrl(handleUploadUrl) ? handleUploadUrl : toAbsoluteUrl(handleUploadUrl);\n  const event = {\n    type: EventTypes.generateClientToken,\n    payload: {\n      pathname,\n      clientPayload: options.clientPayload,\n      multipart: options.multipart\n    }\n  };\n  const res = await (0,undici__WEBPACK_IMPORTED_MODULE_1__.fetch)(url, {\n    method: \"POST\",\n    body: JSON.stringify(event),\n    headers: {\n      \"content-type\": \"application/json\",\n      ...options.headers\n    },\n    signal: options.abortSignal\n  });\n  if (!res.ok) {\n    throw new _chunk_FN6XFH6R_js__WEBPACK_IMPORTED_MODULE_2__.BlobError(\"Failed to  retrieve the client token\");\n  }\n  try {\n    const { clientToken } = await res.json();\n    return clientToken;\n  } catch {\n    throw new _chunk_FN6XFH6R_js__WEBPACK_IMPORTED_MODULE_2__.BlobError(\"Failed to retrieve the client token\");\n  }\n}\nfunction toAbsoluteUrl(url) {\n  return new URL(url, location.href).href;\n}\nfunction isAbsoluteUrl(url) {\n  try {\n    return Boolean(new URL(url));\n  } catch {\n    return false;\n  }\n}\nasync function generateClientTokenFromReadWriteToken({\n  token,\n  ...argsWithoutToken\n}) {\n  var _a;\n  if (typeof window !== \"undefined\") {\n    throw new _chunk_FN6XFH6R_js__WEBPACK_IMPORTED_MODULE_2__.BlobError(\n      '\"generateClientTokenFromReadWriteToken\" must be called from a server environment'\n    );\n  }\n  const timestamp = /* @__PURE__ */ new Date();\n  timestamp.setSeconds(timestamp.getSeconds() + 30);\n  const readWriteToken = (0,_chunk_FN6XFH6R_js__WEBPACK_IMPORTED_MODULE_2__.getTokenFromOptionsOrEnv)({ token });\n  const [, , , storeId = null] = readWriteToken.split(\"_\");\n  if (!storeId) {\n    throw new _chunk_FN6XFH6R_js__WEBPACK_IMPORTED_MODULE_2__.BlobError(\n      token ? \"Invalid `token` parameter\" : \"Invalid `BLOB_READ_WRITE_TOKEN`\"\n    );\n  }\n  const payload = Buffer.from(\n    JSON.stringify({\n      ...argsWithoutToken,\n      validUntil: (_a = argsWithoutToken.validUntil) != null ? _a : timestamp.getTime()\n    })\n  ).toString(\"base64\");\n  const securedKey = await signPayload(payload, readWriteToken);\n  if (!securedKey) {\n    throw new _chunk_FN6XFH6R_js__WEBPACK_IMPORTED_MODULE_2__.BlobError(\"Unable to sign client token\");\n  }\n  return `vercel_blob_client_${storeId}_${Buffer.from(\n    `${securedKey}.${payload}`\n  ).toString(\"base64\")}`;\n}\nfunction getCallbackUrl(request) {\n  const reqPath = getPathFromRequestUrl(request.url);\n  if (!reqPath) {\n    console.warn(\n      \"onUploadCompleted provided but no callbackUrl could be determined. Please provide a callbackUrl in onBeforeGenerateToken or set the VERCEL_BLOB_CALLBACK_URL environment variable.\"\n    );\n    return void 0;\n  }\n  if (process.env.VERCEL_BLOB_CALLBACK_URL) {\n    return `${process.env.VERCEL_BLOB_CALLBACK_URL}${reqPath}`;\n  }\n  if (process.env.VERCEL !== \"1\") {\n    console.warn(\n      \"onUploadCompleted provided but no callbackUrl could be determined. Please provide a callbackUrl in onBeforeGenerateToken or set the VERCEL_BLOB_CALLBACK_URL environment variable.\"\n    );\n    return void 0;\n  }\n  if (process.env.VERCEL_ENV === \"preview\") {\n    if (process.env.VERCEL_BRANCH_URL) {\n      return `https://${process.env.VERCEL_BRANCH_URL}${reqPath}`;\n    }\n    if (process.env.VERCEL_URL) {\n      return `https://${process.env.VERCEL_URL}${reqPath}`;\n    }\n  }\n  if (process.env.VERCEL_ENV === \"production\" && process.env.VERCEL_PROJECT_PRODUCTION_URL) {\n    return `https://${process.env.VERCEL_PROJECT_PRODUCTION_URL}${reqPath}`;\n  }\n  return void 0;\n}\nfunction getPathFromRequestUrl(url) {\n  try {\n    const parsedUrl = new URL(url, \"https://dummy.com\");\n    return parsedUrl.pathname + parsedUrl.search;\n  } catch {\n    return null;\n  }\n}\n\n//# sourceMappingURL=client.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHZlcmNlbC9ibG9iL2Rpc3QvY2xpZW50LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFTNkI7O0FBRTdCO0FBQ2lDO0FBQ0Y7QUFDL0I7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHlEQUFTLElBQUksWUFBWTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix5REFBUztBQUN6QixXQUFXLFlBQVk7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLG1FQUFlO0FBQ3pCO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsNEJBQTRCLHFGQUFpQztBQUM3RDtBQUNBO0FBQ0EsQ0FBQztBQUNELDhCQUE4Qix1RkFBbUM7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiwwRUFBc0I7QUFDdkM7QUFDQTtBQUNBLENBQUM7QUFDRCw4QkFBOEIsdUZBQW1DO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG1FQUFlO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix5REFBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IseURBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLCtCQUErQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDhDQUFpQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLG1CQUFtQiw4Q0FBaUI7QUFDcEM7QUFDQTtBQUNBLDZEQUE2RCxtREFBc0I7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLHdCQUF3Qiw0RUFBd0IsR0FBRyxPQUFPO0FBQzFEO0FBQ0E7QUFDQTtBQUNBLGNBQWMscUNBQXFDO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsb0RBQW9EO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IseURBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLGtCQUFrQix5REFBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0EsZ0JBQWdCLHlEQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLFVBQVUsNEJBQTRCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw2Q0FBSztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0EsY0FBYyx5REFBUztBQUN2QjtBQUNBO0FBQ0EsWUFBWSxjQUFjO0FBQzFCO0FBQ0EsSUFBSTtBQUNKLGNBQWMseURBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGNBQWMseURBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qiw0RUFBd0IsR0FBRyxPQUFPO0FBQzNEO0FBQ0E7QUFDQSxjQUFjLHlEQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGNBQWMseURBQVM7QUFDdkI7QUFDQSwrQkFBK0IsUUFBUSxHQUFHO0FBQzFDLE9BQU8sV0FBVyxHQUFHLFFBQVE7QUFDN0IsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxxQ0FBcUMsRUFBRSxRQUFRO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qiw4QkFBOEIsRUFBRSxRQUFRO0FBQ2hFO0FBQ0E7QUFDQSx3QkFBd0IsdUJBQXVCLEVBQUUsUUFBUTtBQUN6RDtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsMENBQTBDLEVBQUUsUUFBUTtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFZRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWFzamlkb3MvLi9ub2RlX21vZHVsZXMvQHZlcmNlbC9ibG9iL2Rpc3QvY2xpZW50LmpzPzdlYjAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgQmxvYkVycm9yLFxuICBjcmVhdGVDb21wbGV0ZU11bHRpcGFydFVwbG9hZE1ldGhvZCxcbiAgY3JlYXRlQ3JlYXRlTXVsdGlwYXJ0VXBsb2FkTWV0aG9kLFxuICBjcmVhdGVDcmVhdGVNdWx0aXBhcnRVcGxvYWRlck1ldGhvZCxcbiAgY3JlYXRlRm9sZGVyLFxuICBjcmVhdGVQdXRNZXRob2QsXG4gIGNyZWF0ZVVwbG9hZFBhcnRNZXRob2QsXG4gIGdldFRva2VuRnJvbU9wdGlvbnNPckVudlxufSBmcm9tIFwiLi9jaHVuay1GTjZYRkg2Ui5qc1wiO1xuXG4vLyBzcmMvY2xpZW50LnRzXG5pbXBvcnQgKiBhcyBjcnlwdG8gZnJvbSBcImNyeXB0b1wiO1xuaW1wb3J0IHsgZmV0Y2ggfSBmcm9tIFwidW5kaWNpXCI7XG5mdW5jdGlvbiBjcmVhdGVQdXRFeHRyYUNoZWNrcyhtZXRob2ROYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbiBleHRyYUNoZWNrcyhvcHRpb25zKSB7XG4gICAgaWYgKCFvcHRpb25zLnRva2VuLnN0YXJ0c1dpdGgoXCJ2ZXJjZWxfYmxvYl9jbGllbnRfXCIpKSB7XG4gICAgICB0aHJvdyBuZXcgQmxvYkVycm9yKGAke21ldGhvZE5hbWV9IG11c3QgYmUgY2FsbGVkIHdpdGggYSBjbGllbnQgdG9rZW5gKTtcbiAgICB9XG4gICAgaWYgKFxuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciAtLSBSdW50aW1lIGNoZWNrIGZvciBEWC5cbiAgICAgIG9wdGlvbnMuYWRkUmFuZG9tU3VmZml4ICE9PSB2b2lkIDAgfHwgLy8gQHRzLWV4cGVjdC1lcnJvciAtLSBSdW50aW1lIGNoZWNrIGZvciBEWC5cbiAgICAgIG9wdGlvbnMuYWxsb3dPdmVyd3JpdGUgIT09IHZvaWQgMCB8fCAvLyBAdHMtZXhwZWN0LWVycm9yIC0tIFJ1bnRpbWUgY2hlY2sgZm9yIERYLlxuICAgICAgb3B0aW9ucy5jYWNoZUNvbnRyb2xNYXhBZ2UgIT09IHZvaWQgMFxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEJsb2JFcnJvcihcbiAgICAgICAgYCR7bWV0aG9kTmFtZX0gZG9lc24ndCBhbGxvdyBcXGBhZGRSYW5kb21TdWZmaXhcXGAsIFxcYGNhY2hlQ29udHJvbE1heEFnZVxcYCBvciBcXGBhbGxvd092ZXJ3cml0ZVxcYC4gQ29uZmlndXJlIHRoZXNlIG9wdGlvbnMgYXQgdGhlIHNlcnZlciBzaWRlIHdoZW4gZ2VuZXJhdGluZyBjbGllbnQgdG9rZW5zLmBcbiAgICAgICk7XG4gICAgfVxuICB9O1xufVxudmFyIHB1dCA9IGNyZWF0ZVB1dE1ldGhvZCh7XG4gIGFsbG93ZWRPcHRpb25zOiBbXCJjb250ZW50VHlwZVwiXSxcbiAgZXh0cmFDaGVja3M6IGNyZWF0ZVB1dEV4dHJhQ2hlY2tzKFwiY2xpZW50L2BwdXRgXCIpXG59KTtcbnZhciBjcmVhdGVNdWx0aXBhcnRVcGxvYWQgPSBjcmVhdGVDcmVhdGVNdWx0aXBhcnRVcGxvYWRNZXRob2Qoe1xuICBhbGxvd2VkT3B0aW9uczogW1wiY29udGVudFR5cGVcIl0sXG4gIGV4dHJhQ2hlY2tzOiBjcmVhdGVQdXRFeHRyYUNoZWNrcyhcImNsaWVudC9gY3JlYXRlTXVsdGlwYXJ0VXBsb2FkYFwiKVxufSk7XG52YXIgY3JlYXRlTXVsdGlwYXJ0VXBsb2FkZXIgPSBjcmVhdGVDcmVhdGVNdWx0aXBhcnRVcGxvYWRlck1ldGhvZChcbiAge1xuICAgIGFsbG93ZWRPcHRpb25zOiBbXCJjb250ZW50VHlwZVwiXSxcbiAgICBleHRyYUNoZWNrczogY3JlYXRlUHV0RXh0cmFDaGVja3MoXCJjbGllbnQvYGNyZWF0ZU11bHRpcGFydFVwbG9hZGBcIilcbiAgfVxuKTtcbnZhciB1cGxvYWRQYXJ0ID0gY3JlYXRlVXBsb2FkUGFydE1ldGhvZCh7XG4gIGFsbG93ZWRPcHRpb25zOiBbXCJjb250ZW50VHlwZVwiXSxcbiAgZXh0cmFDaGVja3M6IGNyZWF0ZVB1dEV4dHJhQ2hlY2tzKFwiY2xpZW50L2BtdWx0aXBhcnRVcGxvYWRgXCIpXG59KTtcbnZhciBjb21wbGV0ZU11bHRpcGFydFVwbG9hZCA9IGNyZWF0ZUNvbXBsZXRlTXVsdGlwYXJ0VXBsb2FkTWV0aG9kKFxuICB7XG4gICAgYWxsb3dlZE9wdGlvbnM6IFtcImNvbnRlbnRUeXBlXCJdLFxuICAgIGV4dHJhQ2hlY2tzOiBjcmVhdGVQdXRFeHRyYUNoZWNrcyhcImNsaWVudC9gY29tcGxldGVNdWx0aXBhcnRVcGxvYWRgXCIpXG4gIH1cbik7XG52YXIgdXBsb2FkID0gY3JlYXRlUHV0TWV0aG9kKHtcbiAgYWxsb3dlZE9wdGlvbnM6IFtcImNvbnRlbnRUeXBlXCJdLFxuICBleHRyYUNoZWNrcyhvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMuaGFuZGxlVXBsb2FkVXJsID09PSB2b2lkIDApIHtcbiAgICAgIHRocm93IG5ldyBCbG9iRXJyb3IoXG4gICAgICAgIFwiY2xpZW50L2B1cGxvYWRgIHJlcXVpcmVzIHRoZSAnaGFuZGxlVXBsb2FkVXJsJyBwYXJhbWV0ZXJcIlxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKFxuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciAtLSBSdW50aW1lIGNoZWNrIGZvciBEWC5cbiAgICAgIG9wdGlvbnMuYWRkUmFuZG9tU3VmZml4ICE9PSB2b2lkIDAgfHwgLy8gQHRzLWV4cGVjdC1lcnJvciAtLSBSdW50aW1lIGNoZWNrIGZvciBEWC5cbiAgICAgIG9wdGlvbnMuY3JlYXRlUHV0RXh0cmFDaGVja3MgIT09IHZvaWQgMCB8fCAvLyBAdHMtZXhwZWN0LWVycm9yIC0tIFJ1bnRpbWUgY2hlY2sgZm9yIERYLlxuICAgICAgb3B0aW9ucy5jYWNoZUNvbnRyb2xNYXhBZ2UgIT09IHZvaWQgMFxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEJsb2JFcnJvcihcbiAgICAgICAgXCJjbGllbnQvYHVwbG9hZGAgZG9lc24ndCBhbGxvdyBgYWRkUmFuZG9tU3VmZml4YCwgYGNhY2hlQ29udHJvbE1heEFnZWAgb3IgYGFsbG93T3ZlcndyaXRlYC4gQ29uZmlndXJlIHRoZXNlIG9wdGlvbnMgYXQgdGhlIHNlcnZlciBzaWRlIHdoZW4gZ2VuZXJhdGluZyBjbGllbnQgdG9rZW5zLlwiXG4gICAgICApO1xuICAgIH1cbiAgfSxcbiAgYXN5bmMgZ2V0VG9rZW4ocGF0aG5hbWUsIG9wdGlvbnMpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHJldHVybiByZXRyaWV2ZUNsaWVudFRva2VuKHtcbiAgICAgIGhhbmRsZVVwbG9hZFVybDogb3B0aW9ucy5oYW5kbGVVcGxvYWRVcmwsXG4gICAgICBwYXRobmFtZSxcbiAgICAgIGNsaWVudFBheWxvYWQ6IChfYSA9IG9wdGlvbnMuY2xpZW50UGF5bG9hZCkgIT0gbnVsbCA/IF9hIDogbnVsbCxcbiAgICAgIG11bHRpcGFydDogKF9iID0gb3B0aW9ucy5tdWx0aXBhcnQpICE9IG51bGwgPyBfYiA6IGZhbHNlLFxuICAgICAgaGVhZGVyczogb3B0aW9ucy5oZWFkZXJzXG4gICAgfSk7XG4gIH1cbn0pO1xuYXN5bmMgZnVuY3Rpb24gaW1wb3J0S2V5KHRva2VuKSB7XG4gIHJldHVybiBnbG9iYWxUaGlzLmNyeXB0by5zdWJ0bGUuaW1wb3J0S2V5KFxuICAgIFwicmF3XCIsXG4gICAgbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHRva2VuKSxcbiAgICB7IG5hbWU6IFwiSE1BQ1wiLCBoYXNoOiBcIlNIQS0yNTZcIiB9LFxuICAgIGZhbHNlLFxuICAgIFtcInNpZ25cIiwgXCJ2ZXJpZnlcIl1cbiAgKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHNpZ25QYXlsb2FkKHBheWxvYWQsIHRva2VuKSB7XG4gIGlmICghZ2xvYmFsVGhpcy5jcnlwdG8pIHtcbiAgICByZXR1cm4gY3J5cHRvLmNyZWF0ZUhtYWMoXCJzaGEyNTZcIiwgdG9rZW4pLnVwZGF0ZShwYXlsb2FkKS5kaWdlc3QoXCJoZXhcIik7XG4gIH1cbiAgY29uc3Qgc2lnbmF0dXJlID0gYXdhaXQgZ2xvYmFsVGhpcy5jcnlwdG8uc3VidGxlLnNpZ24oXG4gICAgXCJITUFDXCIsXG4gICAgYXdhaXQgaW1wb3J0S2V5KHRva2VuKSxcbiAgICBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUocGF5bG9hZClcbiAgKTtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKG5ldyBVaW50OEFycmF5KHNpZ25hdHVyZSkpLnRvU3RyaW5nKFwiaGV4XCIpO1xufVxuYXN5bmMgZnVuY3Rpb24gdmVyaWZ5Q2FsbGJhY2tTaWduYXR1cmUoe1xuICB0b2tlbixcbiAgc2lnbmF0dXJlLFxuICBib2R5XG59KSB7XG4gIGNvbnN0IHNlY3JldCA9IHRva2VuO1xuICBpZiAoIWdsb2JhbFRoaXMuY3J5cHRvKSB7XG4gICAgY29uc3QgZGlnZXN0ID0gY3J5cHRvLmNyZWF0ZUhtYWMoXCJzaGEyNTZcIiwgc2VjcmV0KS51cGRhdGUoYm9keSkuZGlnZXN0KFwiaGV4XCIpO1xuICAgIGNvbnN0IGRpZ2VzdEJ1ZmZlciA9IEJ1ZmZlci5mcm9tKGRpZ2VzdCk7XG4gICAgY29uc3Qgc2lnbmF0dXJlQnVmZmVyID0gQnVmZmVyLmZyb20oc2lnbmF0dXJlKTtcbiAgICByZXR1cm4gZGlnZXN0QnVmZmVyLmxlbmd0aCA9PT0gc2lnbmF0dXJlQnVmZmVyLmxlbmd0aCAmJiBjcnlwdG8udGltaW5nU2FmZUVxdWFsKGRpZ2VzdEJ1ZmZlciwgc2lnbmF0dXJlQnVmZmVyKTtcbiAgfVxuICBjb25zdCB2ZXJpZmllZCA9IGF3YWl0IGdsb2JhbFRoaXMuY3J5cHRvLnN1YnRsZS52ZXJpZnkoXG4gICAgXCJITUFDXCIsXG4gICAgYXdhaXQgaW1wb3J0S2V5KHRva2VuKSxcbiAgICBoZXhUb0FycmF5Qnl0ZShzaWduYXR1cmUpLFxuICAgIG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShib2R5KVxuICApO1xuICByZXR1cm4gdmVyaWZpZWQ7XG59XG5mdW5jdGlvbiBoZXhUb0FycmF5Qnl0ZShpbnB1dCkge1xuICBpZiAoaW5wdXQubGVuZ3RoICUgMiAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiRXhwZWN0ZWQgc3RyaW5nIHRvIGJlIGFuIGV2ZW4gbnVtYmVyIG9mIGNoYXJhY3RlcnNcIik7XG4gIH1cbiAgY29uc3QgdmlldyA9IG5ldyBVaW50OEFycmF5KGlucHV0Lmxlbmd0aCAvIDIpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0Lmxlbmd0aDsgaSArPSAyKSB7XG4gICAgdmlld1tpIC8gMl0gPSBOdW1iZXIucGFyc2VJbnQoaW5wdXQuc3Vic3RyaW5nKGksIGkgKyAyKSwgMTYpO1xuICB9XG4gIHJldHVybiBCdWZmZXIuZnJvbSh2aWV3KTtcbn1cbmZ1bmN0aW9uIGdldFBheWxvYWRGcm9tQ2xpZW50VG9rZW4oY2xpZW50VG9rZW4pIHtcbiAgY29uc3QgWywgLCAsICwgZW5jb2RlZFRva2VuXSA9IGNsaWVudFRva2VuLnNwbGl0KFwiX1wiKTtcbiAgY29uc3QgZW5jb2RlZFBheWxvYWQgPSBCdWZmZXIuZnJvbShlbmNvZGVkVG9rZW4gIT0gbnVsbCA/IGVuY29kZWRUb2tlbiA6IFwiXCIsIFwiYmFzZTY0XCIpLnRvU3RyaW5nKCkuc3BsaXQoXCIuXCIpWzFdO1xuICBjb25zdCBkZWNvZGVkUGF5bG9hZCA9IEJ1ZmZlci5mcm9tKGVuY29kZWRQYXlsb2FkICE9IG51bGwgPyBlbmNvZGVkUGF5bG9hZCA6IFwiXCIsIFwiYmFzZTY0XCIpLnRvU3RyaW5nKCk7XG4gIHJldHVybiBKU09OLnBhcnNlKGRlY29kZWRQYXlsb2FkKTtcbn1cbnZhciBFdmVudFR5cGVzID0ge1xuICBnZW5lcmF0ZUNsaWVudFRva2VuOiBcImJsb2IuZ2VuZXJhdGUtY2xpZW50LXRva2VuXCIsXG4gIHVwbG9hZENvbXBsZXRlZDogXCJibG9iLnVwbG9hZC1jb21wbGV0ZWRcIlxufTtcbmFzeW5jIGZ1bmN0aW9uIGhhbmRsZVVwbG9hZCh7XG4gIHRva2VuLFxuICByZXF1ZXN0LFxuICBib2R5LFxuICBvbkJlZm9yZUdlbmVyYXRlVG9rZW4sXG4gIG9uVXBsb2FkQ29tcGxldGVkXG59KSB7XG4gIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgY29uc3QgcmVzb2x2ZWRUb2tlbiA9IGdldFRva2VuRnJvbU9wdGlvbnNPckVudih7IHRva2VuIH0pO1xuICBjb25zdCB0eXBlID0gYm9keS50eXBlO1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFwiYmxvYi5nZW5lcmF0ZS1jbGllbnQtdG9rZW5cIjoge1xuICAgICAgY29uc3QgeyBwYXRobmFtZSwgY2xpZW50UGF5bG9hZCwgbXVsdGlwYXJ0IH0gPSBib2R5LnBheWxvYWQ7XG4gICAgICBjb25zdCBwYXlsb2FkID0gYXdhaXQgb25CZWZvcmVHZW5lcmF0ZVRva2VuKFxuICAgICAgICBwYXRobmFtZSxcbiAgICAgICAgY2xpZW50UGF5bG9hZCxcbiAgICAgICAgbXVsdGlwYXJ0XG4gICAgICApO1xuICAgICAgY29uc3QgdG9rZW5QYXlsb2FkID0gKF9hID0gcGF5bG9hZC50b2tlblBheWxvYWQpICE9IG51bGwgPyBfYSA6IGNsaWVudFBheWxvYWQ7XG4gICAgICBjb25zdCB7IGNhbGxiYWNrVXJsOiBwcm92aWRlZENhbGxiYWNrVXJsLCAuLi50b2tlbk9wdGlvbnMgfSA9IHBheWxvYWQ7XG4gICAgICBsZXQgY2FsbGJhY2tVcmwgPSBwcm92aWRlZENhbGxiYWNrVXJsO1xuICAgICAgaWYgKG9uVXBsb2FkQ29tcGxldGVkICYmICFjYWxsYmFja1VybCkge1xuICAgICAgICBjYWxsYmFja1VybCA9IGdldENhbGxiYWNrVXJsKHJlcXVlc3QpO1xuICAgICAgfVxuICAgICAgaWYgKCFvblVwbG9hZENvbXBsZXRlZCAmJiBjYWxsYmFja1VybCkge1xuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgXCJjYWxsYmFja1VybCB3YXMgcHJvdmlkZWQgYnV0IG9uVXBsb2FkQ29tcGxldGVkIGlzIG5vdCBkZWZpbmVkLiBUaGUgY2FsbGJhY2sgd2lsbCBub3QgYmUgaGFuZGxlZC5cIlxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY29uc3Qgb25lSG91ckluU2Vjb25kcyA9IDYwICogNjA7XG4gICAgICBjb25zdCBub3cgPSAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKTtcbiAgICAgIGNvbnN0IHZhbGlkVW50aWwgPSAoX2IgPSBwYXlsb2FkLnZhbGlkVW50aWwpICE9IG51bGwgPyBfYiA6IG5vdy5zZXRTZWNvbmRzKG5vdy5nZXRTZWNvbmRzKCkgKyBvbmVIb3VySW5TZWNvbmRzKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGUsXG4gICAgICAgIGNsaWVudFRva2VuOiBhd2FpdCBnZW5lcmF0ZUNsaWVudFRva2VuRnJvbVJlYWRXcml0ZVRva2VuKHtcbiAgICAgICAgICAuLi50b2tlbk9wdGlvbnMsXG4gICAgICAgICAgdG9rZW46IHJlc29sdmVkVG9rZW4sXG4gICAgICAgICAgcGF0aG5hbWUsXG4gICAgICAgICAgb25VcGxvYWRDb21wbGV0ZWQ6IGNhbGxiYWNrVXJsID8ge1xuICAgICAgICAgICAgY2FsbGJhY2tVcmwsXG4gICAgICAgICAgICB0b2tlblBheWxvYWRcbiAgICAgICAgICB9IDogdm9pZCAwLFxuICAgICAgICAgIHZhbGlkVW50aWxcbiAgICAgICAgfSlcbiAgICAgIH07XG4gICAgfVxuICAgIGNhc2UgXCJibG9iLnVwbG9hZC1jb21wbGV0ZWRcIjoge1xuICAgICAgY29uc3Qgc2lnbmF0dXJlSGVhZGVyID0gXCJ4LXZlcmNlbC1zaWduYXR1cmVcIjtcbiAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IFwiY3JlZGVudGlhbHNcIiBpbiByZXF1ZXN0ID8gKF9jID0gcmVxdWVzdC5oZWFkZXJzLmdldChzaWduYXR1cmVIZWFkZXIpKSAhPSBudWxsID8gX2MgOiBcIlwiIDogKF9kID0gcmVxdWVzdC5oZWFkZXJzW3NpZ25hdHVyZUhlYWRlcl0pICE9IG51bGwgPyBfZCA6IFwiXCI7XG4gICAgICBpZiAoIXNpZ25hdHVyZSkge1xuICAgICAgICB0aHJvdyBuZXcgQmxvYkVycm9yKFwiTWlzc2luZyBjYWxsYmFjayBzaWduYXR1cmVcIik7XG4gICAgICB9XG4gICAgICBjb25zdCBpc1ZlcmlmaWVkID0gYXdhaXQgdmVyaWZ5Q2FsbGJhY2tTaWduYXR1cmUoe1xuICAgICAgICB0b2tlbjogcmVzb2x2ZWRUb2tlbixcbiAgICAgICAgc2lnbmF0dXJlLFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KVxuICAgICAgfSk7XG4gICAgICBpZiAoIWlzVmVyaWZpZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEJsb2JFcnJvcihcIkludmFsaWQgY2FsbGJhY2sgc2lnbmF0dXJlXCIpO1xuICAgICAgfVxuICAgICAgaWYgKG9uVXBsb2FkQ29tcGxldGVkKSB7XG4gICAgICAgIGF3YWl0IG9uVXBsb2FkQ29tcGxldGVkKGJvZHkucGF5bG9hZCk7XG4gICAgICB9XG4gICAgICByZXR1cm4geyB0eXBlLCByZXNwb25zZTogXCJva1wiIH07XG4gICAgfVxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgQmxvYkVycm9yKFwiSW52YWxpZCBldmVudCB0eXBlXCIpO1xuICB9XG59XG5hc3luYyBmdW5jdGlvbiByZXRyaWV2ZUNsaWVudFRva2VuKG9wdGlvbnMpIHtcbiAgY29uc3QgeyBoYW5kbGVVcGxvYWRVcmwsIHBhdGhuYW1lIH0gPSBvcHRpb25zO1xuICBjb25zdCB1cmwgPSBpc0Fic29sdXRlVXJsKGhhbmRsZVVwbG9hZFVybCkgPyBoYW5kbGVVcGxvYWRVcmwgOiB0b0Fic29sdXRlVXJsKGhhbmRsZVVwbG9hZFVybCk7XG4gIGNvbnN0IGV2ZW50ID0ge1xuICAgIHR5cGU6IEV2ZW50VHlwZXMuZ2VuZXJhdGVDbGllbnRUb2tlbixcbiAgICBwYXlsb2FkOiB7XG4gICAgICBwYXRobmFtZSxcbiAgICAgIGNsaWVudFBheWxvYWQ6IG9wdGlvbnMuY2xpZW50UGF5bG9hZCxcbiAgICAgIG11bHRpcGFydDogb3B0aW9ucy5tdWx0aXBhcnRcbiAgICB9XG4gIH07XG4gIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgYm9keTogSlNPTi5zdHJpbmdpZnkoZXZlbnQpLFxuICAgIGhlYWRlcnM6IHtcbiAgICAgIFwiY29udGVudC10eXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgLi4ub3B0aW9ucy5oZWFkZXJzXG4gICAgfSxcbiAgICBzaWduYWw6IG9wdGlvbnMuYWJvcnRTaWduYWxcbiAgfSk7XG4gIGlmICghcmVzLm9rKSB7XG4gICAgdGhyb3cgbmV3IEJsb2JFcnJvcihcIkZhaWxlZCB0byAgcmV0cmlldmUgdGhlIGNsaWVudCB0b2tlblwiKTtcbiAgfVxuICB0cnkge1xuICAgIGNvbnN0IHsgY2xpZW50VG9rZW4gfSA9IGF3YWl0IHJlcy5qc29uKCk7XG4gICAgcmV0dXJuIGNsaWVudFRva2VuO1xuICB9IGNhdGNoIHtcbiAgICB0aHJvdyBuZXcgQmxvYkVycm9yKFwiRmFpbGVkIHRvIHJldHJpZXZlIHRoZSBjbGllbnQgdG9rZW5cIik7XG4gIH1cbn1cbmZ1bmN0aW9uIHRvQWJzb2x1dGVVcmwodXJsKSB7XG4gIHJldHVybiBuZXcgVVJMKHVybCwgbG9jYXRpb24uaHJlZikuaHJlZjtcbn1cbmZ1bmN0aW9uIGlzQWJzb2x1dGVVcmwodXJsKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIEJvb2xlYW4obmV3IFVSTCh1cmwpKTtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5hc3luYyBmdW5jdGlvbiBnZW5lcmF0ZUNsaWVudFRva2VuRnJvbVJlYWRXcml0ZVRva2VuKHtcbiAgdG9rZW4sXG4gIC4uLmFyZ3NXaXRob3V0VG9rZW5cbn0pIHtcbiAgdmFyIF9hO1xuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHRocm93IG5ldyBCbG9iRXJyb3IoXG4gICAgICAnXCJnZW5lcmF0ZUNsaWVudFRva2VuRnJvbVJlYWRXcml0ZVRva2VuXCIgbXVzdCBiZSBjYWxsZWQgZnJvbSBhIHNlcnZlciBlbnZpcm9ubWVudCdcbiAgICApO1xuICB9XG4gIGNvbnN0IHRpbWVzdGFtcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpO1xuICB0aW1lc3RhbXAuc2V0U2Vjb25kcyh0aW1lc3RhbXAuZ2V0U2Vjb25kcygpICsgMzApO1xuICBjb25zdCByZWFkV3JpdGVUb2tlbiA9IGdldFRva2VuRnJvbU9wdGlvbnNPckVudih7IHRva2VuIH0pO1xuICBjb25zdCBbLCAsICwgc3RvcmVJZCA9IG51bGxdID0gcmVhZFdyaXRlVG9rZW4uc3BsaXQoXCJfXCIpO1xuICBpZiAoIXN0b3JlSWQpIHtcbiAgICB0aHJvdyBuZXcgQmxvYkVycm9yKFxuICAgICAgdG9rZW4gPyBcIkludmFsaWQgYHRva2VuYCBwYXJhbWV0ZXJcIiA6IFwiSW52YWxpZCBgQkxPQl9SRUFEX1dSSVRFX1RPS0VOYFwiXG4gICAgKTtcbiAgfVxuICBjb25zdCBwYXlsb2FkID0gQnVmZmVyLmZyb20oXG4gICAgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgLi4uYXJnc1dpdGhvdXRUb2tlbixcbiAgICAgIHZhbGlkVW50aWw6IChfYSA9IGFyZ3NXaXRob3V0VG9rZW4udmFsaWRVbnRpbCkgIT0gbnVsbCA/IF9hIDogdGltZXN0YW1wLmdldFRpbWUoKVxuICAgIH0pXG4gICkudG9TdHJpbmcoXCJiYXNlNjRcIik7XG4gIGNvbnN0IHNlY3VyZWRLZXkgPSBhd2FpdCBzaWduUGF5bG9hZChwYXlsb2FkLCByZWFkV3JpdGVUb2tlbik7XG4gIGlmICghc2VjdXJlZEtleSkge1xuICAgIHRocm93IG5ldyBCbG9iRXJyb3IoXCJVbmFibGUgdG8gc2lnbiBjbGllbnQgdG9rZW5cIik7XG4gIH1cbiAgcmV0dXJuIGB2ZXJjZWxfYmxvYl9jbGllbnRfJHtzdG9yZUlkfV8ke0J1ZmZlci5mcm9tKFxuICAgIGAke3NlY3VyZWRLZXl9LiR7cGF5bG9hZH1gXG4gICkudG9TdHJpbmcoXCJiYXNlNjRcIil9YDtcbn1cbmZ1bmN0aW9uIGdldENhbGxiYWNrVXJsKHJlcXVlc3QpIHtcbiAgY29uc3QgcmVxUGF0aCA9IGdldFBhdGhGcm9tUmVxdWVzdFVybChyZXF1ZXN0LnVybCk7XG4gIGlmICghcmVxUGF0aCkge1xuICAgIGNvbnNvbGUud2FybihcbiAgICAgIFwib25VcGxvYWRDb21wbGV0ZWQgcHJvdmlkZWQgYnV0IG5vIGNhbGxiYWNrVXJsIGNvdWxkIGJlIGRldGVybWluZWQuIFBsZWFzZSBwcm92aWRlIGEgY2FsbGJhY2tVcmwgaW4gb25CZWZvcmVHZW5lcmF0ZVRva2VuIG9yIHNldCB0aGUgVkVSQ0VMX0JMT0JfQ0FMTEJBQ0tfVVJMIGVudmlyb25tZW50IHZhcmlhYmxlLlwiXG4gICAgKTtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIGlmIChwcm9jZXNzLmVudi5WRVJDRUxfQkxPQl9DQUxMQkFDS19VUkwpIHtcbiAgICByZXR1cm4gYCR7cHJvY2Vzcy5lbnYuVkVSQ0VMX0JMT0JfQ0FMTEJBQ0tfVVJMfSR7cmVxUGF0aH1gO1xuICB9XG4gIGlmIChwcm9jZXNzLmVudi5WRVJDRUwgIT09IFwiMVwiKSB7XG4gICAgY29uc29sZS53YXJuKFxuICAgICAgXCJvblVwbG9hZENvbXBsZXRlZCBwcm92aWRlZCBidXQgbm8gY2FsbGJhY2tVcmwgY291bGQgYmUgZGV0ZXJtaW5lZC4gUGxlYXNlIHByb3ZpZGUgYSBjYWxsYmFja1VybCBpbiBvbkJlZm9yZUdlbmVyYXRlVG9rZW4gb3Igc2V0IHRoZSBWRVJDRUxfQkxPQl9DQUxMQkFDS19VUkwgZW52aXJvbm1lbnQgdmFyaWFibGUuXCJcbiAgICApO1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgaWYgKHByb2Nlc3MuZW52LlZFUkNFTF9FTlYgPT09IFwicHJldmlld1wiKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52LlZFUkNFTF9CUkFOQ0hfVVJMKSB7XG4gICAgICByZXR1cm4gYGh0dHBzOi8vJHtwcm9jZXNzLmVudi5WRVJDRUxfQlJBTkNIX1VSTH0ke3JlcVBhdGh9YDtcbiAgICB9XG4gICAgaWYgKHByb2Nlc3MuZW52LlZFUkNFTF9VUkwpIHtcbiAgICAgIHJldHVybiBgaHR0cHM6Ly8ke3Byb2Nlc3MuZW52LlZFUkNFTF9VUkx9JHtyZXFQYXRofWA7XG4gICAgfVxuICB9XG4gIGlmIChwcm9jZXNzLmVudi5WRVJDRUxfRU5WID09PSBcInByb2R1Y3Rpb25cIiAmJiBwcm9jZXNzLmVudi5WRVJDRUxfUFJPSkVDVF9QUk9EVUNUSU9OX1VSTCkge1xuICAgIHJldHVybiBgaHR0cHM6Ly8ke3Byb2Nlc3MuZW52LlZFUkNFTF9QUk9KRUNUX1BST0RVQ1RJT05fVVJMfSR7cmVxUGF0aH1gO1xuICB9XG4gIHJldHVybiB2b2lkIDA7XG59XG5mdW5jdGlvbiBnZXRQYXRoRnJvbVJlcXVlc3RVcmwodXJsKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgcGFyc2VkVXJsID0gbmV3IFVSTCh1cmwsIFwiaHR0cHM6Ly9kdW1teS5jb21cIik7XG4gICAgcmV0dXJuIHBhcnNlZFVybC5wYXRobmFtZSArIHBhcnNlZFVybC5zZWFyY2g7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5leHBvcnQge1xuICBjb21wbGV0ZU11bHRpcGFydFVwbG9hZCxcbiAgY3JlYXRlRm9sZGVyLFxuICBjcmVhdGVNdWx0aXBhcnRVcGxvYWQsXG4gIGNyZWF0ZU11bHRpcGFydFVwbG9hZGVyLFxuICBnZW5lcmF0ZUNsaWVudFRva2VuRnJvbVJlYWRXcml0ZVRva2VuLFxuICBnZXRQYXlsb2FkRnJvbUNsaWVudFRva2VuLFxuICBoYW5kbGVVcGxvYWQsXG4gIHB1dCxcbiAgdXBsb2FkLFxuICB1cGxvYWRQYXJ0XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2xpZW50LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@vercel/blob/dist/client.js\n");

/***/ })

};
;